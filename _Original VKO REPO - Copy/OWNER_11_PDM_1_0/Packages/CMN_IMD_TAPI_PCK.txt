create or replace PACKAGE cmn_imd_tapi_pck
IS
-- Table API package for table cmn_ifc_msg_definitions
-- Generated by VI TAPI generator version 6.2  (TAPI generated 03-Jan-2022  05:40:57)

-- Generated global constants
g_con_pack        CONSTANT     VARCHAR2(30) := 'CMN_IMD_TAPI_PCK';
g_con_table_name  CONSTANT     VARCHAR2(61) := 'CMN_IFC_MSG_DEFINITIONS';
g_lock_conflicts  PLS_INTEGER := 0;


FUNCTION imd_select_row( i_imd_ID   IN  cmn_ifc_msg_definitions.ID%TYPE
                       , o_rt_imd   OUT cmn_ifc_msg_definitions%ROWTYPE )
RETURN BOOLEAN
;

FUNCTION imd_select_row_uk( i_imd_NAME   IN  cmn_ifc_msg_definitions.NAME%TYPE
                          , o_rt_imd  OUT cmn_ifc_msg_definitions%ROWTYPE )
RETURN BOOLEAN
;

FUNCTION imd_select_row_upd( i_imd_ID   IN  cmn_ifc_msg_definitions.ID%TYPE
                           , o_rt_imd   OUT cmn_ifc_msg_definitions%ROWTYPE )
RETURN BOOLEAN
;

FUNCTION imd_select_row_upd_uk( i_imd_NAME   IN  cmn_ifc_msg_definitions.NAME%TYPE
                              , o_rt_imd  OUT cmn_ifc_msg_definitions%ROWTYPE )
RETURN BOOLEAN
;

PROCEDURE imd_lock_row( i_imd_ID   IN  cmn_ifc_msg_definitions.ID%TYPE )
;

PROCEDURE imd_lock_row_nowait( i_imd_ID   IN  cmn_ifc_msg_definitions.ID%TYPE )
;


END cmn_imd_tapi_pck;
/



PACKAGE BODY cmn_imd_tapi_pck
IS




FUNCTION IMD_SELECT_ROW( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE
                       , O_RT_IMD   OUT CMN_IFC_MSG_DEFINITIONS%ROWTYPE )
RETURN BOOLEAN
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_select_row';
   L_FOUND                BOOLEAN      := FALSE;
BEGIN
   DECLARE
      CURSOR C_IMD ( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
      IS 
           SELECT *
             FROM CMN_IFC_MSG_DEFINITIONS IMD
            WHERE IMD.ID = I_IMD_ID ;
   BEGIN                                                         
      VIU_MODULE.ENTER_MODULE( I_MODULE => CON_PROC );

      BEGIN
         OPEN C_IMD( I_IMD_ID => I_IMD_ID );
         FETCH C_IMD INTO O_RT_IMD;
         L_FOUND := C_IMD%FOUND;
         CLOSE C_IMD;
      END;

      VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC 
                             , I_DEBUG_INFO => CASE L_FOUND WHEN TRUE THEN 'found' ELSE 'notfound' END );

      RETURN L_FOUND;

   EXCEPTION
      WHEN OTHERS
      THEN
         IF C_IMD%ISOPEN
         THEN
            CLOSE C_IMD;
         END IF;

         VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                                , I_DEBUG_INFO => SQLERRM );

         VIU_INFO.RAISE_INFO( I_CALLING_PROCEDURE => CON_PROC );
   END;                                                          
END IMD_SELECT_ROW;

FUNCTION IMD_SELECT_ROW_UK( I_IMD_NAME   IN  CMN_IFC_MSG_DEFINITIONS.NAME%TYPE
                          , O_RT_IMD  OUT CMN_IFC_MSG_DEFINITIONS%ROWTYPE )
RETURN BOOLEAN
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_select_row_uk';
   L_FOUND                BOOLEAN      := FALSE;
BEGIN
   DECLARE
      CURSOR C_IMD ( I_IMD_NAME   IN  CMN_IFC_MSG_DEFINITIONS.NAME%TYPE )
      IS
         SELECT *
           FROM CMN_IFC_MSG_DEFINITIONS IMD
          WHERE IMD.NAME = I_IMD_NAME ;
   BEGIN                                                         
      VIU_MODULE.ENTER_MODULE( I_MODULE => CON_PROC );

      BEGIN
         OPEN C_IMD(I_IMD_NAME => I_IMD_NAME);
         FETCH C_IMD INTO O_RT_IMD;
         L_FOUND := C_IMD%FOUND;
         CLOSE C_IMD;
      END;

      VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                             , I_DEBUG_INFO => CASE L_FOUND WHEN TRUE THEN 'found' ELSE 'notfound' END );

      RETURN L_FOUND;

   EXCEPTION
   WHEN OTHERS
    THEN
      IF C_IMD%ISOPEN
      THEN
         CLOSE C_IMD;
      END IF;
      VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                             , I_DEBUG_INFO => SQLERRM );

      VIU_INFO.RAISE_INFO( I_CALLING_PROCEDURE => CON_PROC );
   END;                                                          
END IMD_SELECT_ROW_UK;

FUNCTION IMD_SELECT_ROW_UPD( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE
                           , O_RT_IMD   OUT CMN_IFC_MSG_DEFINITIONS%ROWTYPE )
RETURN BOOLEAN
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_select_row_upd';
   L_FOUND                BOOLEAN      := FALSE;

   CURSOR C_IMD ( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
   IS
           SELECT *
             FROM CMN_IFC_MSG_DEFINITIONS IMD
            WHERE IMD.ID = I_IMD_ID 
         FOR UPDATE;
BEGIN
   VIU_MODULE.ENTER_MODULE( I_MODULE => CON_PROC );

   
   OPEN C_IMD( I_IMD_ID => I_IMD_ID );
   FETCH C_IMD INTO O_RT_IMD;
   L_FOUND := C_IMD%FOUND;
   CLOSE C_IMD;

   VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                          , I_DEBUG_INFO => CASE L_FOUND WHEN TRUE THEN 'found' ELSE 'notfound' END );

   RETURN L_FOUND;

EXCEPTION
   WHEN OTHERS
   THEN
      IF C_IMD%ISOPEN
      THEN
         CLOSE C_IMD;
      END IF;

      VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                             , I_DEBUG_INFO => SQLERRM );

      VIU_INFO.RAISE_INFO( I_CALLING_PROCEDURE => CON_PROC );

END IMD_SELECT_ROW_UPD;

FUNCTION IMD_SELECT_ROW_UPD_UK( I_IMD_NAME   IN  CMN_IFC_MSG_DEFINITIONS.NAME%TYPE
                              , O_RT_IMD  OUT CMN_IFC_MSG_DEFINITIONS%ROWTYPE )
RETURN BOOLEAN
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_select_row_upd_uk';
   L_FOUND                BOOLEAN      := FALSE;
BEGIN
   BEGIN
      VIU_MODULE.ENTER_MODULE( I_MODULE => CON_PROC );

      
      L_FOUND := IMD_SELECT_ROW_UK( I_IMD_NAME   =>  I_IMD_NAME
                                  , O_RT_IMD => O_RT_IMD );
      IF L_FOUND
      THEN
         
         L_FOUND := IMD_SELECT_ROW_UPD( I_IMD_ID => O_RT_IMD.ID
                                      , O_RT_IMD => O_RT_IMD );
      END IF;

      VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                             , I_DEBUG_INFO => CASE L_FOUND WHEN TRUE THEN 'found' ELSE 'notfound' END );

      RETURN L_FOUND;

   EXCEPTION
      WHEN OTHERS
      THEN
        VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                               , I_DEBUG_INFO => SQLERRM);

        VIU_INFO.RAISE_INFO(I_CALLING_PROCEDURE => CON_PROC);
   END;
END IMD_SELECT_ROW_UPD_UK;

PROCEDURE IMD_LOCK_ROW( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_lock_row';
BEGIN
  DECLARE
     CURSOR C_IMD ( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
     IS
             SELECT ''
               FROM CMN_IFC_MSG_DEFINITIONS IMD
              WHERE IMD.ID = I_IMD_ID 
         FOR UPDATE;

   BEGIN                                                         
      VIU_MODULE.ENTER_MODULE(I_MODULE => CON_PROC);

      BEGIN
         
         IF I_IMD_ID IS NOT NULL
         THEN
            BEGIN
                
                IMD_LOCK_ROW_NOWAIT( I_IMD_ID => I_IMD_ID );
            EXCEPTION
               WHEN VIU_CONSTANT.EXC_LOCKFAILED
               THEN
                  
                  G_LOCK_CONFLICTS := G_LOCK_CONFLICTS + 1;

                  
                  VIU_INFO.RESET_PACKAGE_VARIABLES;

                  
                  OPEN C_IMD( I_IMD_ID => I_IMD_ID );
                  CLOSE C_IMD;
               END;
         END IF;
      END;

      VIU_MODULE.LEAVE_MODULE( I_MODULE => CON_PROC );

   EXCEPTION
      WHEN OTHERS
      THEN
         IF C_IMD%ISOPEN
         THEN
            CLOSE C_IMD;
         END IF;

         VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                                , I_DEBUG_INFO => SQLERRM );

         VIU_INFO.RAISE_INFO(I_CALLING_PROCEDURE => CON_PROC );
   END;                                                          
END IMD_LOCK_ROW;

PROCEDURE IMD_LOCK_ROW_NOWAIT( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
IS
   CON_PROC  CONSTANT     VARCHAR2(61) := G_CON_PACK || '.imd_lock_row_nowait';
BEGIN
   DECLARE
      CURSOR C_IMD ( I_IMD_ID   IN  CMN_IFC_MSG_DEFINITIONS.ID%TYPE )
      IS
              SELECT ''
                FROM CMN_IFC_MSG_DEFINITIONS IMD
               WHERE IMD.ID = I_IMD_ID 
          FOR UPDATE NOWAIT;

   BEGIN                                                         
      VIU_MODULE.ENTER_MODULE(I_MODULE => CON_PROC);

      BEGIN

         
         IF I_IMD_ID IS NOT NULL
         THEN
            
            OPEN C_IMD( I_IMD_ID => I_IMD_ID );

            CLOSE C_IMD;
         END IF;
      END;

      VIU_MODULE.LEAVE_MODULE( I_MODULE => CON_PROC );

   EXCEPTION
      WHEN OTHERS
      THEN
        IF C_IMD%ISOPEN
        THEN
           CLOSE C_IMD;
        END IF;

        VIU_MODULE.LEAVE_MODULE( I_MODULE     => CON_PROC
                               , I_DEBUG_INFO => SQLERRM );

        VIU_INFO.RAISE_INFO( I_IFO_NR            => VIU_CONSTANT.C_IFO_LOCKFAILED
                           , I_CALLING_PROCEDURE => CON_PROC
                           , I_SEVERITY          => VIU_INFO.C_SEVERITY_ERROR
                           , I_INFO_ARGUMENTS    => G_CON_TABLE_NAME
                           , I_ADDITIONAL_DATA   =>   'ID = "'||I_IMD_ID||'"' );
   END;                                                          
END IMD_LOCK_ROW_NOWAIT;


END CMN_IMD_TAPI_PCK;
/