create or replace PACKAGE lm_topology_administration IS

   g_con_package CONSTANT lm_constant.st_proc_name := 'LM_TOPOLOGY_ADMINISTRATION';
   
   TYPE g_it_dst IS
      TABLE OF lm_physical_destinations.id%TYPE
      INDEX BY BINARY_INTEGER;

   TYPE g_it_rst IS
      TABLE OF lm_route_segments.id%TYPE
      INDEX BY BINARY_INTEGER;
   
   TYPE g_it_segments_processed IS
      TABLE OF lm_route_segments.id%TYPE
      INDEX BY BINARY_INTEGER;

/* TOP_001: checks if combination of given area,zone and section exists */
PROCEDURE chk_area_zone_section
   ( i_area_id_cust    IN lm_areas_v.id_cust%TYPE
   , i_zone_id_cust    IN lm_zones_v.id_cust%TYPE
   , i_section_id_cust IN lm_sections_v.id_cust%TYPE
   );
   
/* TOP_002:  Checks if a given combination of area, zone and node exists */
PROCEDURE chk_area_zone_node
   ( i_area_id_cust          IN lm_areas_v.id_cust%TYPE
   , i_zone_id_cust          IN lm_zones_v.id_cust%TYPE
   , i_identifier_within_sct IN lm_nodes.identifier_within_sct%TYPE
    );

/* TOP_007 Check if task instruction must be evaluated subject to controlled routing */
PROCEDURE check_controlled_routing
   ( i_tin_id            IN     lm_task_instructions.id%type
   , i_pid               IN     lm_packages.pid%TYPE
   , i_source            IN     VARCHAR2
   , i_tdn_id            IN     lm_task_definitions.tdn_id_backup%TYPE
   , i_tdn_id_backup     IN     lm_task_definitions.tdn_id_backup%TYPE
   , i_ind_contr_routing IN     lm_task_definitions.ind_controlled_routing%TYPE
   , o_ind_use_backup       OUT BOOLEAN
   );

/* TOP_009 Load all final expected stations for a task */
PROCEDURE load_final_stations
   ( i_tin_id                    IN     lm_task_instructions.id%TYPE
   , i_ind_use_backup_task       IN     BOOLEAN
   , o_nt_task_stations_final       OUT nt_stn_id
   );

/* TOP_008 Load all eligible stations for a task */
PROCEDURE load_stations
   ( i_tin_id                    IN     lm_task_instructions.id%TYPE
   , i_tdn_id                    IN     lm_task_definitions.id%TYPE
   , i_tin_id_active             IN     lm_task_instructions.id%TYPE
   , i_handler                   IN     lm_task_instructions.handler%TYPE
   , i_rst_id                    IN     lm_route_segments.id%TYPE
   , i_time_limit_pay            IN     lm_task_instructions.time_limit_process_activity%TYPE
   , i_snp_id_primary            IN     lm_task_assignments.snp_id%TYPE
   , i_source                    IN     VARCHAR2
   , i_nt_exclude_stations       IN     nt_stn_id
   , i_ind_use_backup_task       IN     BOOLEAN
   , i_pid                       IN     lm_packages.pid%TYPE
   , i_bid                       IN     lm_packages.bid%TYPE
   , i_bid_extension             IN     lm_packages.bid_extension%TYPE
   , i_task_type                 IN     lm_task_definitions.task_instruction_type%TYPE
   , i_origin                    IN     lm_task_instructions.origin%TYPE
   , o_nt_available_stations        OUT nt_stn_id
   , o_nt_unavailable_stations      OUT nt_stn_id
   , o_nt_allowed_stations          OUT nt_stn_ranks
   , o_route_impossible             OUT BOOLEAN
   , o_nt_stn_id_fallback           OUT nt_stn_id
   );

/* TOP_034 Select a task assignment for a package. */
PROCEDURE select_task_assignment
   ( i_rst_id             IN     lm_route_segments.id%TYPE
   , i_tdn_id             IN     lm_task_definitions.id%TYPE
   , i_nt_final_stations  IN     nt_stn_id
   , i_source             IN     VARCHAR2
   , i_pid                IN     lm_packages.pid%TYPE
   , i_bid                IN     lm_packages.bid%TYPE
   , i_bid_extension      IN     lm_packages.bid_extension%TYPE
   , i_task_type          IN     lm_task_definitions.task_instruction_type%TYPE
   , i_origin             IN     lm_task_instructions.origin%TYPE
   , o_rt_tat                OUT lm_task_assignments%ROWTYPE
   , o_route_impossible      OUT BOOLEAN
   , o_nt_stn_id_fallback    OUT nt_stn_id
   );

/* TOP_010 Check non-final task station versus the primary station group */
PROCEDURE check_task_route
   ( i_snp_id              IN     lm_task_assignments.snp_id%TYPE
   , i_nt_stn_id           IN     nt_stn_id
   , i_source              IN     VARCHAR2
   , i_pid                 IN     lm_packages.pid%TYPE
   , i_bid                 IN     lm_packages.bid%TYPE
   , i_bid_extension       IN     lm_packages.bid_extension%TYPE
   , i_task_type           IN     lm_task_definitions.task_instruction_type%TYPE
   , i_origin              IN     lm_task_instructions.origin%TYPE
   , o_nt_allowed_stations    OUT nt_stn_ranks
   , o_route_impossible       OUT BOOLEAN
   , o_nt_stn_id_fallback     OUT nt_stn_id
   );

/* TOP_011 Handle situation with no available stations */
PROCEDURE handle_no_available_stations
   ( i_rt_tat                  IN     lm_task_assignments%ROWTYPE
   , i_nt_unavailable_stations IN     nt_stn_id
   , i_nt_task_stations_final  IN     nt_stn_id
   , i_pay_id                  IN     lm_process_activities.id%TYPE
   , i_priority_indicator      IN     lm_packages.priority_indicator%TYPE
   , i_origin                  IN     lm_task_instructions.origin%TYPE
   , i_source                  IN     VARCHAR2
   , i_pid                     IN     lm_packages.pid%TYPE
   , i_bid                     IN     lm_packages.bid%TYPE
   , i_bid_extension           IN     lm_packages.bid_extension%TYPE
   , i_task_type               IN     lm_task_definitions.task_instruction_type%TYPE
   , o_nt_stn_id                  OUT nt_stn_id
   , o_nt_final_stn_id            OUT nt_stn_id
   );

/* TOP_012 (Dis)connect a Task Instruction to/from a backup task type */
PROCEDURE update_temp_task
   ( i_tin_id              IN lm_task_instructions.id%type
   , i_tdn_id_backup       IN lm_task_definitions.id%TYPE
   , i_ind_use_backup_task IN BOOLEAN
   , i_ind_stns_selected   IN BOOLEAN
   );

/* TOP_013 Update a Task Instruction's rank of an assigned bag store STATION */
PROCEDURE update_store_rank
   ( i_tin_id                 IN lm_task_instructions.id%type
   , i_nt_allowed_stations    IN nt_stn_ranks
   , i_nt_determined_stations IN nt_stn_id
   );

/* TOP_003: Determine stations given task and location */
PROCEDURE determine_stations
   ( i_tin_id              IN     lm_task_instructions.id%TYPE
   , i_source              IN     VARCHAR2
   , i_ind_use_backup_task IN     BOOLEAN
   , i_nt_exclude_stations IN     nt_stn_id
   , o_nt_stn_id              OUT nt_stn_id
   , o_nt_final_stn_id        OUT nt_stn_id
   );
 
/* TOP_004: Determine physical destinations for stations */
PROCEDURE determine_destinations
   ( i_nt_stn_id                   IN     nt_stn_id
   , i_ind_for_package_instruction IN     BOOLEAN DEFAULT TRUE
   , o_it_pon_id                      OUT lm_topology_administration.g_it_dst
   , o_rt_haa                         OUT lm_handling_areas%ROWTYPE
   );

/* TOP_005: determine from which system component a message originates */
FUNCTION get_sct_id
   ( i_area_id_cust    IN lm_areas_v.id_cust%TYPE
   , i_zone_id_cust    IN lm_zones_v.id_cust%TYPE
   , i_section_id_cust IN lm_sections_v.id_cust%TYPE
   )
RETURN lm_system_components.ID%TYPE;

/* TOP_006: fetch physical destination for a station */
PROCEDURE get_destination
   ( i_station IN     lm_stations.id%TYPE
   , o_pon_id     OUT lm_physical_destinations.id%TYPE
   , o_sct_id     OUT lm_system_components.id%TYPE
   );
   
/* TOP_016: Evaluate the destinations of packages with an active taskinst */
PROCEDURE evaluate_pck_instr_for_pck
   ( i_pid IN lm_packages.pid%TYPE
   );
   
/* TOP_015: Evaluate the destinations of packages with an active taskinst */
PROCEDURE evaluate_task_instr_for_pck
   ( i_pid                     IN     lm_packages.pid%TYPE
   , i_tin_id                  IN     lm_task_instructions.id%TYPE
   , i_source                  IN     VARCHAR2 := 'NULL'
   , i_nt_exclude_stations     IN     nt_stn_id
   , o_new_determined_stations    OUT BOOLEAN
   );
   
/* TOP_019: Store the determined stations */
PROCEDURE store_determined_stations
   ( i_tin_id          IN lm_task_instructions.id%TYPE
   , i_nt_stn_id       IN nt_stn_id
   , i_nt_final_stn_id IN nt_stn_id
   );

/* TOP_020 get stations of a station group, given a collection and final expected stations */
PROCEDURE get_stations
   ( i_snp_id                 IN     lm_station_groups.id%TYPE
   , i_nt_stations            IN     nt_stn_id
   , i_nt_final_stations      IN     nt_stn_id
   , i_pay_id                 IN     lm_process_activities.id%TYPE
   , i_priority_indicator     IN     lm_packages.priority_indicator%TYPE
   , o_nt_determined_stations    OUT nt_stn_id
   , o_nt_used_final_stations    OUT nt_stn_id
   );

/* TOP_021 return the loadfactor for a group of stations */
PROCEDURE loadfactor
   ( i_nt_stations     IN     nt_stn_id
   , i_pay_id          IN     lm_process_activities.id%TYPE
   , i_tin_id_exclude  IN     lm_task_instructions.id%TYPE DEFAULT NULL
   , i_ind_loadbalance IN     BOOLEAN DEFAULT TRUE
   , o_load_factor        OUT NUMBER
   );

/* TOP_022: Return the AREA ID CUST by a given ARA, ZNE or SEN */
FUNCTION get_area_id_cust
   ( i_sct_id   IN lm_system_components.id%TYPE
   , i_sct_type IN lm_system_components.sct_type%TYPE
   )
RETURN lm_system_components.ID_CUST%TYPE;

/* TOP_023 Select a specific station_group_member of a station group */
PROCEDURE select_member_of_group
   ( i_snp_id                 IN     lm_station_groups.id%TYPE
   , i_nt_stations            IN     nt_stn_id
   , i_nt_final_stations      IN     nt_stn_id
   , i_pay_id                 IN     lm_process_activities.id%TYPE
   , o_snp_id                    OUT lm_station_groups.id%TYPE
   , o_stn_id                    OUT lm_station_group_members.stn_id_member_station%TYPE
   , o_nt_used_final_stations    OUT nt_stn_id
   );

/* TOP_024 consider the secondary station_groups for a station_group */
PROCEDURE select_secondary_group
   ( i_snp_id      IN     lm_station_groups.id%TYPE
   , i_nt_stations IN     nt_stn_id
   , i_pay_id      IN     lm_process_activities.id%TYPE
   , o_snp_id         OUT lm_station_groups.id%TYPE
   );

/* TOP_025 fetch all stations for a station group, that are part of a given collection */
PROCEDURE determine_stations_in_group
   ( i_snp_id      IN     lm_station_group_members.snp_id_define%TYPE
   , i_nt_stations IN     nt_stn_id
   , o_nt_stations    OUT nt_stn_id
   );

/* TOP_026 return the station record with IND_FALLBACK = Y */
PROCEDURE get_fallback_station
   ( o_rt_stn OUT lm_stations%ROWTYPE
   );
   
/* TOP_027 Deal with the exceptions that can occur during determination of stations */
PROCEDURE process_tat_exception
   ( i_pid           IN     lm_packages.pid%TYPE
   , i_bid           IN     lm_packages.bid%TYPE
   , i_bid_extension IN     lm_packages.bid_extension%TYPE
   , i_task_type     IN     lm_task_definitions.task_instruction_type%TYPE
   , i_error_type    IN     VARCHAR2
   , i_source        IN     VARCHAR2
   , i_origin        IN     lm_task_instructions.origin%TYPE
   , i_stn_found     IN     BOOLEAN
   , o_stn_id           OUT lm_stations.id%TYPE
   );
   
/* TOP_028 re-evaluate the input task instruction */
PROCEDURE evaluate_taskinstruction
   ( i_pid                     IN     lm_packages.pid%TYPE
   , i_tin_id                  IN     lm_task_instructions.id%TYPE
   , i_source                  IN     VARCHAR2
   , i_nt_exclude_stations     IN     nt_stn_id
   , o_new_determined_stations    OUT BOOLEAN
   );
   
/* TOP_029 Handle changed derived station availability */
PROCEDURE process_stn_availability_infl
   ( i_route_influence_timestamp IN TIMESTAMP
   );
   
/* TOP_033 Get upstream route segments of a node */
PROCEDURE get_nde_upstream_rst
   ( i_area_id_cust          IN     lm_areas_v.id_cust%TYPE
   , i_zone_id_cust          IN     lm_zones_v.id_cust%TYPE
   , i_identifier_within_sct IN     lm_nodes.identifier_within_sct%TYPE
   , o_it_rst                   OUT lm_topology_administration.g_it_rst
   );

/* TOP_031 Get downstream route segments of a node */
PROCEDURE get_nde_downstream_rst
 (i_area_id_cust          IN     lm_areas_v.id_cust%TYPE
 ,i_zone_id_cust          IN     lm_zones_v.id_cust%TYPE
 ,i_identifier_within_sct IN     lm_nodes.identifier_within_sct%TYPE
 ,o_it_rst                   OUT lm_topology_administration.g_it_rst
 );

/* TOP_035 Handle changed handling area access availability */
PROCEDURE process_has_availability_infl
   (i_route_influence_timestamp IN TIMESTAMP
   );

/* TOP_036 Determine the NODES representing a DESTINATION */
FUNCTION get_nde_from_pon
   ( i_pon_id IN lm_physical_destinations.id%TYPE
   )
RETURN nt_nde_id;

/* TOP_037 Determine Expected Time of Arrival at assigned stations */
PROCEDURE determine_eta_stn
   ( i_rt_pae         IN     lm_packages%ROWTYPE
   , i_rst_id         IN     lm_route_segments.id%TYPE
   , i_event_type     IN     lm_event_types.id%TYPE
   , i_event_time     IN     lm_package_events.event_time%TYPE
   , o_nt_stn_id_cust    OUT nt_stn_id_cust
   , o_haa_id_cust       OUT lm_handling_areas.id_cust%TYPE
   , o_eta               OUT lm_package_events.event_time%TYPE
   );

/* TOP_038 Translate package destinations to stations or handling area*/
PROCEDURE translate_pdn_to_stn
   ( i_pid            IN     lm_packages.pid%TYPE
   , o_nt_stn_id_cust    OUT nt_stn_id_cust
   , o_haa_id_cust       OUT lm_handling_areas.id_cust%TYPE
   );
   
/* TOP_039 Translate physical destinations to stations */
PROCEDURE translate_pon_to_stn
   ( i_nt_pon_id  IN     nt_pon_id
   , o_nt_stn_id     OUT nt_stn_id
   );

/* TOP_040 Count the number of packages in the system present on a certainset of segments*/
PROCEDURE count_bags_in_segment_group
   ( i_nt_brn_id           IN      nt_id_coll
   , o_nt_brp_id               OUT nt_id_coll
   , o_nt_counted_packages     OUT nt_counted_packages
   , o_nt_pon_id               OUT nt_pon_id
   );
 
/* TOP_41 Determine Stations EBS */
PROCEDURE determine_stations_ebs
   ( i_tin_id                  IN     lm_task_instructions.id%TYPE
   , i_source                  IN     VARCHAR2
   , i_pae_rst_id              IN     lm_packages.rst_id%TYPE
   , i_task_type               IN     lm_task_definitions.task_instruction_type%TYPE
   , i_pcm_name                IN     lm_physical_class_dom.name%TYPE
   , i_time_limit              IN     TIMESTAMP
   , i_sep_id                  IN     lm_segregation_groups.id%TYPE
   , i_pid                     IN     lm_packages.pid%TYPE
   , i_bid                     IN     lm_packages.bid%TYPE
   , i_bid_extension           IN     lm_packages.bid_extension%TYPE
   , i_origin                  IN     lm_task_instructions.origin%TYPE
   , io_nt_determined_stations IN OUT nt_stn_id
   );

END LM_TOPOLOGY_ADMINISTRATION;
/




package body lm_topology_administration is












































































































exc_resource_busy           exception;
pragma exception_init(exc_resource_busy, -51);


procedure chk_area_zone_section
   ( i_area_id_cust    in lm_areas_v.id_cust%type
   , i_zone_id_cust    in lm_zones_v.id_cust%type
   , i_section_id_cust in lm_sections_v.id_cust%type
   )
is
   
   cursor c_area_zone_section
   ( i_area_id_cust    in lm_areas_v.id_cust%type
   , i_zone_id_cust    in lm_zones_v.id_cust%type
   , i_section_id_cust in lm_sections_v.id_cust%type
   )
   is
   select ara.id_cust  area_id_cust
   ,      zne.id_cust  zone_id_cust
   ,      sen.id_cust  section_id_cust
   from   lm_areas_v     ara
   ,      lm_zones_v     zne
   ,      lm_sections_v  sen
   where  ara.id_cust     = i_area_id_cust
   and    zne.id_cust (+) = i_zone_id_cust
   and    sen.id_cust (+) = i_section_id_cust
   and    zne.area_id (+) = ara.area_id
   and    sen.zone_id (+) = zne.zone_id
   ;

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.CHK_AREA_ZONE_SECTION';

l_rt_azs c_area_zone_section%rowtype;


































begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   if i_area_id_cust is null
   then
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_areaverificationerror
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        =>    'AreaID:"'
                                                       || i_area_id_cust
                                                       || '", ZoneID:"'
                                                       || i_zone_id_cust
                                                       || '", SectionID:"'
                                                       || i_section_id_cust
                                                       || '"'
                         );
   end if;

   
   open c_area_zone_section( i_area_id_cust         => i_area_id_cust
                           , i_zone_id_cust         => i_zone_id_cust
                           , i_section_id_cust      => i_section_id_cust
                           );

   fetch c_area_zone_section
   into  l_rt_azs;

   close c_area_zone_section;

   if l_rt_azs.area_id_cust is null
   then   
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_areaverificationerror
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        =>    'AreaID:"'
                                                       || i_area_id_cust
                                                       || '", ZoneID:"'
                                                       || i_zone_id_cust
                                                       || '", SectionID:"'
                                                       || i_section_id_cust
                                                       || '"'
                         );
   elsif    l_rt_azs.zone_id_cust <> i_zone_id_cust
         or (     i_zone_id_cust is not null
              and l_rt_azs.zone_id_cust is null )
   then   
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_zoneverificationerror
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        =>    'AreaID:"'
                                                       || i_area_id_cust
                                                       || '", ZoneID:"'
                                                       || i_zone_id_cust
                                                       || '", SectionID:"'
                                                       || i_section_id_cust
                                                       || '"'
                         );
   elsif    l_rt_azs.section_id_cust <> i_section_id_cust
         or (     i_section_id_cust is not null
              and l_rt_azs.section_id_cust is null )
   then   
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_sectionverificationerror
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        =>    'AreaID:"'
                                                       || i_area_id_cust
                                                       || '", ZoneID:"'
                                                       || i_zone_id_cust
                                                       || '", SectionID:"'
                                                       || i_section_id_cust
                                                       || '"'
                         );
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_area_zone_section%isopen
      then
         close c_area_zone_section;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end chk_area_zone_section;


procedure chk_area_zone_node
   ( i_area_id_cust          in lm_areas_v.id_cust%type
   , i_zone_id_cust          in lm_zones_v.id_cust%type
   , i_identifier_within_sct in lm_nodes.identifier_within_sct%type
   )
is


cursor c_azn
 (i_area_id_cust in lm_areas_v.id_cust%type
 ,i_zone_id_cust in lm_zones_v.id_cust%type
 ,i_identifier_within_sct in lm_nodes.identifier_within_sct%type
 )
 is
select ara.id_cust as area_id_cust
,      zne.id_cust as zone_id_cust
,      nde.identifier_within_sct as identifier_within_sct
from   lm_areas_v ara
,      lm_zones_v zne
,      lm_nodes nde
where  ara.area_id = zne.area_id
and    ara.id_cust = i_area_id_cust
and    zne.zone_id = nde.sct_id
and    zne.id_cust = i_zone_id_cust
and    nde.identifier_within_sct = i_identifier_within_sct;

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.CHK_AREA_ZONE_NODE';

l_rt_azn c_azn%rowtype;
l_found boolean;
































begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   open c_azn( i_area_id_cust               => i_area_id_cust
             , i_zone_id_cust               => i_zone_id_cust
             , i_identifier_within_sct      => i_identifier_within_sct
             );

   fetch c_azn
   into  l_rt_azn;

   l_found  := c_azn%found;

   close c_azn;

   if not l_found
   then
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_invalidnodeid
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        =>    'AreaID:"'
                                                       || i_area_id_cust
                                                       || '", ZoneID:"'
                                                       || i_zone_id_cust
                                                       || '", NodeID:"'
                                                       || i_identifier_within_sct
                                                       || '"'
                         );
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_azn%isopen
      then
         close c_azn;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end chk_area_zone_node;


procedure check_controlled_routing
   ( i_tin_id            in     lm_task_instructions.id%type
   , i_pid               in     lm_packages.pid%type
   , i_source            in     varchar2
   , i_tdn_id            in     lm_task_definitions.tdn_id_backup%type
   , i_tdn_id_backup     in     lm_task_definitions.tdn_id_backup%type
   , i_ind_contr_routing in     lm_task_definitions.ind_controlled_routing%type
   , o_ind_use_backup       out boolean
   )
is
   










   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.check_controlled_routing';

   
   cursor c_tin_exists
     ( i_tin_id     in lm_task_instructions.id%type
      ,i_pid        in lm_task_instructions.pid%type
      ,i_tdn_id     in lm_task_definitions.id%type
      ,i_tdn_backup in lm_task_definitions.tdn_id_backup%type
     )
   is
   select ''                                          
   from   lm_task_definitions  tdn
   ,      lm_task_instructions tin
   where  tin.tdn_id           = tdn.id
   and    tin.pss_id           in ( lm_constant.g_con_pss_name_open
                                  , lm_constant.g_con_pss_name_suspect
                                  )                   
   and    tin.pid             != i_pid                
   and    tdn.id               = i_tdn_id             
   and    tin.tdn_id_temporary = i_tdn_backup         
   and    not exists                                  
         (select *                                    
          from   lm_tin_active_of_package_v tinv
          ,      lm_determined_stations     dsn
          ,      lm_task_stations           tsn
          where  tinv.pid               = i_pid
          and    tsn.tin_id             = i_tin_id
          and    tsn.tsn_type           = lm_constant.g_con_tsn_nonfinal
          and    dsn.tin_id             = tinv.id
          and    dsn.ind_final_expected = lm_constant.g_con_yesno_no
          and    dsn.stn_id             = tsn.stn_id
         )
   and  ( not exists                                  
           (select ''                                 
            from   lm_task_stations tsn               
            where  tsn.tin_id             = tin.id    
            and    tsn.tsn_type           = lm_constant.g_con_tsn_nonfinal
           )
          or
          not exists                                  
           (select ''                                 
            from   lm_task_stations tsn               
            where  tsn.tin_id   = i_tin_id
            and    tsn.tsn_type = lm_constant.g_con_tsn_nonfinal
           )
          or
          exists                                      
           (select ''
            from   lm_task_stations          tsn1   
            ,      lm_task_stations          tsn2   
            ,      lm_station_availabilities say1   
            where  tsn1.tin_id             = i_tin_id
            and    tsn2.tin_id             = tin.id
            and    tsn1.tsn_type           = lm_constant.g_con_tsn_nonfinal
            and    tsn2.tsn_type           = lm_constant.g_con_tsn_nonfinal
            and    tsn1.stn_id             = tsn2.stn_id
            and    say1.stn_id             = tsn1.stn_id
            and    say1.ssd_id             in ( lm_constant.g_con_ssd_id_available
                                              , lm_constant.g_con_ssd_id_initial
                                              )
            and    say1.ind_available_derived = lm_constant.g_con_yesno_yes
            and    nvl(say1.sod_id, lm_constant.g_con_sod_id_logged_on) = lm_constant.g_con_sod_id_logged_on
            and    (tin.handler in
                    (select son.id_cust
                     from   lm_scope_of_operation son
                     where  son.say_stn_id = tsn2.stn_id
                    )
                    or
                    not exists
                    (select son.id_cust
                     from   lm_scope_of_operation son
                     where  son.say_stn_id = tsn2.stn_id
                    )
                   )
           )
        )
   ;
                                                      
   l_rt_tin_exists c_tin_exists%rowtype;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_ind_use_backup := false;

   if      (   i_source != lm_constant.g_con_src_logistic_backup
            or i_source is null)
       and i_tdn_id_backup is not null
       and i_ind_contr_routing = lm_constant.g_con_yesno_yes
   then
      
      
      
      
      
      
      
      
      
      open c_tin_exists(i_tin_id     => i_tin_id
                       ,i_pid        => i_pid
                       ,i_tdn_id     => i_tdn_id
                       ,i_tdn_backup => i_tdn_id_backup);
      fetch c_tin_exists into  l_rt_tin_exists;
      o_ind_use_backup := c_tin_exists%found;
      close c_tin_exists;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_tin_exists%isopen
      then
         close c_tin_exists;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end check_controlled_routing;


procedure load_final_stations
   ( i_tin_id                    in     lm_task_instructions.id%type
   , i_ind_use_backup_task       in     boolean
   , o_nt_task_stations_final       out nt_stn_id
   )
is
   









   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.load_final_stations';

   
   cursor c_get_final_taskstations
   ( i_tin_id              lm_task_instructions.id%type
   , i_ind_use_backup_task in varchar2
   )
   is
   
   
   
   select tsn.stn_id
   from   lm_task_stations          tsn
   where  tsn.tin_id   = i_tin_id
   and    (( tsn.tsn_type           = lm_constant.g_con_tsn_final
             and
             i_ind_use_backup_task  = lm_constant.g_con_yesno_no
           )
           or
           ( tsn.tsn_type           = lm_constant.g_con_tsn_nonfinal
             and
             i_ind_use_backup_task  = lm_constant.g_con_yesno_yes
           )
          )
   ;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   o_nt_task_stations_final    := nt_stn_id();
   
   for rec_finals in c_get_final_taskstations
                     ( i_tin_id              => i_tin_id
                     , i_ind_use_backup_task => case
                                                  when i_ind_use_backup_task
                                                  then lm_constant.g_con_yesno_yes
                                                  else lm_constant.g_con_yesno_no
                                                end
                     )
   loop
      
      o_nt_task_stations_final.extend;
      o_nt_task_stations_final( o_nt_task_stations_final.count )    := rec_finals.stn_id;
   end loop;
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end load_final_stations;


procedure load_stations
   ( i_tin_id                    in     lm_task_instructions.id%type
   , i_tdn_id                    in     lm_task_definitions.id%type
   , i_tin_id_active             in     lm_task_instructions.id%type
   , i_handler                   in     lm_task_instructions.handler%type
   , i_rst_id                    in     lm_route_segments.id%type
   , i_time_limit_pay            in     lm_task_instructions.time_limit_process_activity%type
   , i_snp_id_primary            in     lm_task_assignments.snp_id%type
   , i_source                    in     varchar2
   , i_nt_exclude_stations       in     nt_stn_id
   , i_ind_use_backup_task       in     boolean
   , i_pid                       in     lm_packages.pid%type
   , i_bid                       in     lm_packages.bid%type
   , i_bid_extension             in     lm_packages.bid_extension%type
   , i_task_type                 in     lm_task_definitions.task_instruction_type%type
   , i_origin                    in     lm_task_instructions.origin%type
   , o_nt_available_stations        out nt_stn_id
   , o_nt_unavailable_stations      out nt_stn_id
   , o_nt_allowed_stations          out nt_stn_ranks
   , o_route_impossible             out boolean
   , o_nt_stn_id_fallback           out nt_stn_id
   )
is
   









   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.load_stations';

   


   cursor c_all_stns( i_tdn_id              in lm_task_definitions.id%type
                    , i_tin_id              in lm_task_instructions.id%type
                    , i_handler             in lm_task_instructions.handler%type
                    , i_rst_id              in lm_packages.rst_id%type
                    , i_nt_exclude_stations in nt_stn_id
                    , i_ind_use_backup_task in varchar2
                    )
   is
      select /*+ CARDINALITY (STN 10) */ stn.stn_id
      ,      stn.ind_task_station
      ,      stn.cache_positions
      ,      stn.bagstore_type
      ,      case
                
                
                
                
                
                
                when stn.stn_id not member of i_nt_exclude_stations
                and  stn.stn_id not in ( select esn.stn_id
                                         from   lm_evaluated_stations esn
                                         where  esn.tin_id = i_tin_id
                                         and    esn.time_recirculation_obsolete is not null
                                       )
                then lm_constant.g_con_yesno_yes
                else lm_constant.g_con_yesno_no
             end ind_consider
      ,      case
                
                
                
                when (     stn.ssd_id in (lm_constant.g_con_ssd_id_initial
                                         ,lm_constant.g_con_ssd_id_available)
                       and nvl ( stn.sod_id,lm_constant.g_con_sod_id_logged_on) = lm_constant.g_con_sod_id_logged_on
                       and ( stn.stn_id in ( select son.say_stn_id
                                             from   lm_scope_of_operation son
                                             where  son.id_cust = i_handler
                                           )
                             or
                             stn.stn_id not in ( select son.say_stn_id
                                                 from   lm_scope_of_operation son
                                               )
                           )
                     )
                or
                
                
                
                     stn.stn_id in ( select spy.stn_id
                                     from   lm_station_proximities spy
                                     where  spy.rst_id = i_rst_id
                                     and    spy.ind_restrict_to_logoff_req = lm_constant.g_con_yesno_no
                                   )
                or
                
                
                
                
                     (     stn.ssd_id in (lm_constant.g_con_ssd_id_initial
                                         ,lm_constant.g_con_ssd_id_available)
                       and stn.sod_id = lm_constant.g_con_sod_id_logoff_req
                       and ( stn.stn_id in ( select son.say_stn_id
                                             from   lm_scope_of_operation son
                                             where  son.id_cust = i_handler
                                           )
                             or
                             stn.stn_id not in ( select son.say_stn_id
                                                 from   lm_scope_of_operation son
                                               )
                           )
                       and stn.stn_id in ( select spy.stn_id
                                           from   lm_station_proximities spy
                                           where  spy.rst_id = i_rst_id
                                           and    spy.ind_restrict_to_logoff_req = lm_constant.g_con_yesno_yes
                                         )
                     )
                then lm_constant.g_con_yesno_yes
                else lm_constant.g_con_yesno_no
             end as ind_reported_available
      ,      case
                
                
                when stn.ind_available_derived = lm_constant.g_con_yesno_yes
                or
                
                
                
                     stn.stn_id in ( select spy.stn_id
                                     from   lm_station_proximities spy
                                     where  spy.rst_id = i_rst_id
                                     and    spy.ind_restrict_to_logoff_req = lm_constant.g_con_yesno_no
                                   )
                then lm_constant.g_con_yesno_yes
                else lm_constant.g_con_yesno_no
             end as ind_route_available
   from   (
           
           select tsn.stn_id
           ,      lm_constant.g_con_yesno_yes as ind_task_station
           ,      stn.cache_positions
           ,      stn.bagstore_type
           ,      say.ssd_id
           ,      say.sod_id
           ,      say.ind_available_derived
           from   lm_task_stations          tsn
           ,      lm_station_availabilities say
           ,      lm_stations               stn
           where  tsn.tin_id             = i_tin_id
           and    tsn.stn_id             = stn.id
           and    say.stn_id             = tsn.stn_id
           and    (( tsn.tsn_type           = lm_constant.g_con_tsn_nonfinal
                     and
                     i_ind_use_backup_task  = lm_constant.g_con_yesno_no
                   )
                   or
                   ( tsn.tsn_type           = lm_constant.g_con_tsn_temp_storage
                     and
                     i_ind_use_backup_task  = lm_constant.g_con_yesno_yes
                   )
                  )
           union all
           
           
           
           select stn.id
           ,      lm_constant.g_con_yesno_no as ind_task_station
           ,      stn.cache_positions
           ,      stn.bagstore_type
           ,      say.ssd_id
           ,      say.sod_id
           ,      say.ind_available_derived
           from   lm_stations stn
           ,      lm_station_availabilities say
           ,      lm_task_handling thg
           where  stn.id     = say.stn_id
           and    stn.id     = thg.stn_id
           and    thg.tdn_id = i_tdn_id
           and    (( not exists (select ''
                                 from   lm_task_stations tsn
                                 where  tsn.tin_id   = i_tin_id
                                 and    tsn.tsn_type = lm_constant.g_con_tsn_nonfinal
                                )
                     and
                     i_ind_use_backup_task = lm_constant.g_con_yesno_no
                   )
                   or
                   ( not exists (select ''
                                 from   lm_task_stations tsn
                                 where  tsn.tin_id   = i_tin_id
                                 and    tsn.tsn_type = lm_constant.g_con_tsn_temp_storage
                                )
                     and
                     i_ind_use_backup_task = lm_constant.g_con_yesno_yes
                   )
                  )
          ) stn;

   
   cursor c_dsn( i_tin_id  in lm_task_instructions.id%type)
   is
      select nt_stn_id(dsn.stn_id)
      from   lm_determined_stations dsn
      where  dsn.tin_id             = i_tin_id
      and    dsn.ind_final_expected = lm_constant.g_con_yesno_no
   ;
   
   l_load_factor                number;
   l_nt_task_stations_nonfinal  nt_stn_id := nt_stn_id();
   l_nt_task_bagstore_stations  nt_stn_id := nt_stn_id();
   l_nt_dsn_active              nt_stn_id := nt_stn_id();
   l_rank_to_consider           lm_task_instructions.store_rank%type;
   l_bagstore_receptive         boolean;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   o_nt_available_stations     := nt_stn_id();
   o_nt_unavailable_stations   := nt_stn_id();

   
   for rec_stn in c_all_stns( i_tdn_id              => i_tdn_id
                            , i_tin_id              => i_tin_id
                            , i_handler             => i_handler
                            , i_rst_id              => i_rst_id
                            , i_nt_exclude_stations => i_nt_exclude_stations
                            , i_ind_use_backup_task => case
                                                        when i_ind_use_backup_task
                                                        then lm_constant.g_con_yesno_yes
                                                        else lm_constant.g_con_yesno_no
                                                       end
                            )
   loop
      if rec_stn.ind_task_station = lm_constant.g_con_yesno_yes
      then
         
         l_nt_task_stations_nonfinal.extend;
         l_nt_task_stations_nonfinal(l_nt_task_stations_nonfinal.count) := rec_stn.stn_id;
      end if; 
      
      if rec_stn.bagstore_type is not null
      then
         
         l_nt_task_bagstore_stations.extend;
         l_nt_task_bagstore_stations(l_nt_task_bagstore_stations.count) := rec_stn.stn_id;
      end if; 

      
      if rec_stn.ind_consider = lm_constant.g_con_yesno_yes
      then
         
            
         if rec_stn.cache_positions is not null
         then
            
            
            lm_stn_tapi_pck.stn_lock_row(rec_stn.stn_id);
                           
            
            lm_topology_administration.loadfactor( i_nt_stations     => nt_stn_id(rec_stn.stn_id)
                                                 , i_pay_id          => null
                                                 , i_tin_id_exclude  => i_tin_id_active
                                                 , i_ind_loadbalance => false
                                                 , o_load_factor     => l_load_factor
                                                 );
         end if;
                     
         
         
         
         
         
         
         
         
         if rec_stn.cache_positions is null
         or rec_stn.cache_positions > l_load_factor
         then
            if  rec_stn.ind_reported_available = lm_constant.g_con_yesno_yes
            and rec_stn.ind_route_available = lm_constant.g_con_yesno_yes
            then
               
               o_nt_available_stations.extend;
               o_nt_available_stations( o_nt_available_stations.count ) := rec_stn.stn_id;
            else
               
               
               
               o_nt_unavailable_stations.extend;
               o_nt_unavailable_stations( o_nt_unavailable_stations.count) := rec_stn.stn_id;
            end if;  
         end if;     
      end if;    

   end loop;
   
   
   
   
   check_task_route( i_snp_id              => i_snp_id_primary
                   , i_nt_stn_id           => l_nt_task_stations_nonfinal
                   , i_source              => i_source
                   , i_pid                 => i_pid
                   , i_bid                 => i_bid
                   , i_bid_extension       => i_bid_extension
                   , i_task_type           => i_task_type
                   , i_origin              => i_origin
                   , o_nt_allowed_stations => o_nt_allowed_stations
                   , o_route_impossible    => o_route_impossible
                   , o_nt_stn_id_fallback  => o_nt_stn_id_fallback
                   );
   if o_route_impossible
   then
      
      o_nt_available_stations   := nt_stn_id();
      o_nt_unavailable_stations := nt_stn_id();
   else
      if l_nt_task_bagstore_stations.count > 0
      then
         
         
         
         
         

         
         
         open c_dsn(i_tin_id => i_tin_id_active);
         fetch c_dsn into l_nt_dsn_active;
         close c_dsn;

         
         
         
         
         
         
         
         
         
         for idx_stn_allowed in 1..o_nt_allowed_stations.count
         loop
            if o_nt_allowed_stations(idx_stn_allowed).stn_id member of l_nt_dsn_active
               and
               ( o_nt_allowed_stations(idx_stn_allowed).stn_id member of o_nt_available_stations
                 or
                 o_nt_allowed_stations(idx_stn_allowed).stn_id member of o_nt_unavailable_stations
               )
            then
               
               l_rank_to_consider := o_nt_allowed_stations(idx_stn_allowed).rank;
               exit; 
            end if;
         end loop;
    
         
         
         
         for idx_stn_allowed in 1..o_nt_allowed_stations.count
         loop
            if o_nt_allowed_stations(idx_stn_allowed).stn_id member of l_nt_task_bagstore_stations
               and
               ( o_nt_allowed_stations(idx_stn_allowed).stn_id member of o_nt_available_stations
                 or
                 o_nt_allowed_stations(idx_stn_allowed).stn_id member of o_nt_unavailable_stations
               )
            then
               
               l_bagstore_receptive := lm_rbs_administration.station_receptive
                                        ( i_stn_id           => o_nt_allowed_stations(idx_stn_allowed).stn_id
                                        , i_ind_highest_rank => (o_nt_allowed_stations(idx_stn_allowed).rank = 1)
                                        , i_time_limit_pay   => i_time_limit_pay
                                        , i_tin_id_exclude   => i_tin_id_active
                                        , i_pid              => i_pid
                                        , i_source           => i_source
                                        );
               if (o_nt_allowed_stations(idx_stn_allowed).rank > 1
                   and
                   not l_bagstore_receptive
                  )
                  or
                  l_rank_to_consider < o_nt_allowed_stations(idx_stn_allowed).rank
               then
                  
                  o_nt_available_stations   := o_nt_available_stations
                                               multiset except
                                               nt_stn_id(o_nt_allowed_stations(idx_stn_allowed).stn_id);
                  o_nt_unavailable_stations := o_nt_unavailable_stations
                                               multiset except
                                               nt_stn_id(o_nt_allowed_stations(idx_stn_allowed).stn_id);
               end if;
            end if;
            if o_nt_allowed_stations(idx_stn_allowed).stn_id member of o_nt_available_stations
               and
               not l_bagstore_receptive
            then
               
               o_nt_unavailable_stations := o_nt_unavailable_stations
                                            multiset union distinct
                                            nt_stn_id(o_nt_allowed_stations(idx_stn_allowed).stn_id);
               o_nt_available_stations   := o_nt_available_stations
                                            multiset except
                                            nt_stn_id(o_nt_allowed_stations(idx_stn_allowed).stn_id);
            end if;
         end loop; 
      end if;          
   end if;          

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_dsn%isopen
      then
         close c_dsn;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end load_stations;


procedure select_task_assignment
   ( i_rst_id             in     lm_route_segments.id%type
   , i_tdn_id             in     lm_task_definitions.id%type
   , i_nt_final_stations  in     nt_stn_id
   , i_source             in     varchar2
   , i_pid                in     lm_packages.pid%type
   , i_bid                in     lm_packages.bid%type
   , i_bid_extension      in     lm_packages.bid_extension%type
   , i_task_type          in     lm_task_definitions.task_instruction_type%type
   , i_origin             in     lm_task_instructions.origin%type
   , o_rt_tat                out lm_task_assignments%rowtype
   , o_route_impossible      out boolean
   , o_nt_stn_id_fallback    out nt_stn_id
   )
is



































   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.SELECT_TASK_ASSIGNMENT';

   
   cursor c_get_task_assignments
   (i_tdn_id in lm_task_definitions.id%type
   ,i_rst_id in lm_route_segments.id%type
   )
   is
      
      

      
      
      
      
      
      select tat.*
      from   lm_task_assignments      tat
      ,      lm_segment_group_members sgr
      where  tat.tdn_id = i_tdn_id
      and    tat.tgr_id = sgr.tgr_id
      and    sgr.lst_id = (select rst.lst_id
                           from   lm_route_segments rst
                           where rst.id = i_rst_id
                          )
      order by tat.snp_id_heading_to nulls first
      ,        tat.mom_id
      ,        tat.sct_id nulls first
      ;

   l_found           boolean;
   l_rt_mon          lm_modes_of_operation%rowtype;
   l_nt_stations     nt_stn_id := nt_stn_id();
   l_fallback_stn_id lm_stations.id%type;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   o_nt_stn_id_fallback        := nt_stn_id();

   
   for l_rt_gta in c_get_task_assignments( i_rst_id => i_rst_id
                                         , i_tdn_id => i_tdn_id
                                         )
   loop
      case
         when l_rt_gta.sct_id is null
            and l_rt_gta.snp_id_heading_to is null
         then
            
            
            
            o_rt_tat := l_rt_gta;
         when l_rt_gta.sct_id is not null
            and l_rt_gta.mom_id = lm_constant.g_con_mom_mom_mode_normal
         then
            
            
            o_rt_tat := l_rt_gta;
         when l_rt_gta.sct_id is not null
            and l_rt_gta.mom_id = lm_constant.g_con_mom_mom_mode_reverse
         then
            
            
            
            l_found := lm_mon_tapi_pck.mon_select_row( i_mon_sct_id => l_rt_gta.sct_id
                                                     , o_rt_mon => l_rt_mon
                                                     );
            if l_found
               and l_rt_gta.mom_id = l_rt_mon.mom_id
            then
               o_rt_tat := l_rt_gta;
            end if;
         when l_rt_gta.snp_id_heading_to is not null
         then
            
            
            if i_nt_final_stations is not empty
            then
               
               
               
               
               lm_topology_administration.determine_stations_in_group( i_snp_id      => l_rt_gta.snp_id_heading_to
                                                                     , i_nt_stations => i_nt_final_stations
                                                                     , o_nt_stations => l_nt_stations
                                                                     );
               if l_nt_stations is not empty
               then
                  o_rt_tat := l_rt_gta;
                  exit;
               end if;
            end if;
         else
            
            o_rt_tat := null;
            exit;
      end case;
   end loop;

   if o_rt_tat.snp_id is null
   then
      
      o_route_impossible := true;

      
      lm_topology_administration.process_tat_exception( i_pid           => i_pid
                                                      , i_bid           => i_bid
                                                      , i_bid_extension => i_bid_extension
                                                      , i_task_type     => i_task_type
                                                      , i_error_type    => lm_constant.g_con_mae_route_impossible
                                                      , i_source        => i_source
                                                      , i_origin        => i_origin
                                                      , i_stn_found     => false
                                                      , o_stn_id        => l_fallback_stn_id
                                                      );
      if l_fallback_stn_id is not null
      then
         
         o_nt_stn_id_fallback.extend;
         o_nt_stn_id_fallback(1) := l_fallback_stn_id;
      end if;
   else
      o_route_impossible := false;
   end if;
   
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_task_assignments%isopen
      then
         close c_get_task_assignments;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end select_task_assignment;


procedure check_task_route
   ( i_snp_id              in     lm_task_assignments.snp_id%type
   , i_nt_stn_id           in     nt_stn_id
   , i_source              in     varchar2
   , i_pid                 in     lm_packages.pid%type
   , i_bid                 in     lm_packages.bid%type
   , i_bid_extension       in     lm_packages.bid_extension%type
   , i_task_type           in     lm_task_definitions.task_instruction_type%type
   , i_origin              in     lm_task_instructions.origin%type
   , o_nt_allowed_stations    out nt_stn_ranks
   , o_route_impossible       out boolean
   , o_nt_stn_id_fallback     out nt_stn_id
   )
is
   








   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.check_task_route';

   
   cursor c_station_group_membership
    (i_snp_id in lm_station_groups.id%type
    ,i_nt_stn_id in nt_stn_id
    )
    is
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   select rt_stn_rank
          ( member_station
          , dense_rank () over (order by snp_rank nulls first)
          )
   from   ( select /*+ INDEX(sgm LM_SGM_SNP_DEFINE_FK_I) */
                   sgm.stn_id_member_station as member_station
                   ,      connect_by_root snp.rank  as snp_rank
                   from   lm_station_group_members sgm
                   ,      lm_station_groups        snp
                   where  (sgm.stn_id_member_station in ( select /*+ cardinality(stn 1) */ column_value
                                                          from table(i_nt_stn_id) stn
                                                        )
                           or i_nt_stn_id is empty
                          )
                   and    sgm.snp_id_define = snp.id
                   start with sgm.snp_id_define in ( select snp1.id id
                                                     from   lm_station_groups snp1
                                                     start with snp1.id = i_snp_id
                                                     connect by snp1.snp_id_alternative = prior snp1.id
                                                   )
                   connect by sgm.snp_id_define = prior sgm.snp_id_member_group
          )
   where  member_station is not null
   order by snp_rank nulls first      
   ,        member_station;           
   
   l_fallback_stn_id lm_stations.id%type;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_route_impossible    := false;
   o_nt_stn_id_fallback  := nt_stn_id();
   o_nt_allowed_stations := nt_stn_ranks();

   open c_station_group_membership( i_snp_id    => i_snp_id
                                  , i_nt_stn_id => i_nt_stn_id
                                  );
   fetch c_station_group_membership
   bulk collect into o_nt_allowed_stations;
   close c_station_group_membership;

   if o_nt_allowed_stations.count = 0
   then
      o_route_impossible := true;

      
      
      
      
      
      lm_topology_administration.process_tat_exception( i_pid           => i_pid
                                                      , i_bid           => i_bid
                                                      , i_bid_extension => i_bid_extension
                                                      , i_task_type     => i_task_type
                                                      , i_error_type    => lm_constant.g_con_mae_route_impossible
                                                      , i_source        => i_source
                                                      , i_origin        => i_origin
                                                      , i_stn_found     => false
                                                      , o_stn_id        => l_fallback_stn_id
                                                      );
      if l_fallback_stn_id is not null
      then
         
         o_nt_stn_id_fallback.extend;
         o_nt_stn_id_fallback(1) := l_fallback_stn_id;
      end if;
   end if;
      

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_station_group_membership%isopen
      then
         close c_station_group_membership;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end check_task_route;


procedure handle_no_available_stations
   ( i_rt_tat                  in     lm_task_assignments%rowtype
   , i_nt_unavailable_stations in     nt_stn_id
   , i_nt_task_stations_final  in     nt_stn_id
   , i_pay_id                  in     lm_process_activities.id%type
   , i_priority_indicator      in     lm_packages.priority_indicator%type
   , i_origin                  in     lm_task_instructions.origin%type
   , i_source                  in     varchar2
   , i_pid                     in     lm_packages.pid%type
   , i_bid                     in     lm_packages.bid%type
   , i_bid_extension           in     lm_packages.bid_extension%type
   , i_task_type               in     lm_task_definitions.task_instruction_type%type
   , o_nt_stn_id                  out nt_stn_id
   , o_nt_final_stn_id            out nt_stn_id
   )
is
   









   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.handle_no_available_stations';
   
   l_fallback_stn_id        lm_stations.id%type;
   l_bagstore_stations      integer;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_nt_stn_id       := nt_stn_id();
   o_nt_final_stn_id := nt_stn_id();

   
   
   
   
   if i_nt_unavailable_stations is not empty
   then
      
      select /*+ cardinality (stn1 5) */ count(1)
      into   l_bagstore_stations
      from   lm_stations_store_v              stn
      ,      table(i_nt_unavailable_stations) stn1
      where  stn.id = stn1.column_value;

      if l_bagstore_stations = i_nt_unavailable_stations.count
         or
         (i_origin = lm_constant.g_con_origin_csci_sm
          and
          lm_common.get_parameter_value( i_prr_name => lm_constant.g_con_pve_ind_use_unavail_stns) = lm_constant.g_con_yesno_yes
         )
      then
         
         
         
         
         
         lm_topology_administration.get_stations( i_snp_id                 => i_rt_tat.snp_id
                                                , i_nt_stations            => i_nt_unavailable_stations
                                                , i_nt_final_stations      => i_nt_task_stations_final
                                                , i_pay_id                 => case i_rt_tat.ind_use_segr_for_loadbalancing
                                                                                 when lm_constant.g_con_yesno_yes
                                                                                 then
                                                                                    i_pay_id
                                                                                 else
                                                                                    null
                                                                                 end
                                                , i_priority_indicator     => i_priority_indicator
                                                , o_nt_determined_stations => o_nt_stn_id
                                                , o_nt_used_final_stations => o_nt_final_stn_id
                                                );
      end if;  
   end if;   
   
   
   
   
   
   lm_topology_administration.process_tat_exception( i_pid           => i_pid
                                                   , i_bid           => i_bid
                                                   , i_bid_extension => i_bid_extension
                                                   , i_task_type     => i_task_type
                                                   , i_error_type    => lm_constant.g_con_mae_station_unavailable
                                                   , i_source        => i_source
                                                   , i_origin        => i_origin
                                                   , i_stn_found     => (o_nt_stn_id is not empty)
                                                   , o_stn_id        => l_fallback_stn_id
                                                   );
   if l_fallback_stn_id is not null
   then
      
      o_nt_stn_id.extend;
      o_nt_stn_id(1) := l_fallback_stn_id;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end handle_no_available_stations;


procedure update_temp_task
   ( i_tin_id              in lm_task_instructions.id%type
   , i_tdn_id_backup       in lm_task_definitions.id%type
   , i_ind_use_backup_task in boolean
   , i_ind_stns_selected   in boolean
   )
is
   









   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.update_temp_task';

   l_retval                 number;
   l_rt_tin                 lm_task_instructions%rowtype;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if i_ind_stns_selected
   then
      if i_tdn_id_backup is not null
      then
         
         if lm_tin_tapi_pck.tin_select_row( i_tin_id => i_tin_id
                                          , o_rt_tin => l_rt_tin)
         then
            if i_ind_use_backup_task
            then
               
               l_rt_tin.tdn_id_temporary  := i_tdn_id_backup;
            else
               
               l_rt_tin.tdn_id_temporary  := null;
            end if;
            l_retval := lm_tin_tapi_pck.tin_update_row( i_tin_id  => i_tin_id
                                                      , io_rt_tin => l_rt_tin);
         end if;
      end if;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end update_temp_task;


procedure update_store_rank
   ( i_tin_id                 in lm_task_instructions.id%type
   , i_nt_allowed_stations    in nt_stn_ranks
   , i_nt_determined_stations in nt_stn_id
   )
is
   








   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.update_store_rank';

   cursor c_stn_rank( b_nt_determined_stations nt_stn_id
                    , b_nt_allowed_stations    nt_stn_ranks
                    )
   is
     
   select /*+ cardinality (asn 5) cardinality (dsn 5) */ min(asn.rank)
   from   lm_stations_store_v             stn
   ,      table(b_nt_determined_stations) dsn
   ,      table(b_nt_allowed_stations)    asn
   where  asn.stn_id       = stn.id
   and    dsn.column_value = asn.stn_id;

   l_retval                 number;
   l_rt_tin                 lm_task_instructions%rowtype;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if lm_tin_tapi_pck.tin_select_row( i_tin_id => i_tin_id
                                    , o_rt_tin => l_rt_tin)
   then
      open c_stn_rank( b_nt_determined_stations => i_nt_determined_stations
                     , b_nt_allowed_stations    => i_nt_allowed_stations
                     );
      fetch c_stn_rank into l_rt_tin.store_rank; 
      close c_stn_rank;
      l_retval := lm_tin_tapi_pck.tin_update_row( i_tin_id  => i_tin_id
                                                , io_rt_tin => l_rt_tin);
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end update_store_rank;


procedure determine_stations
   ( i_tin_id              in     lm_task_instructions.id%type
   , i_source              in     varchar2
   , i_ind_use_backup_task in     boolean
   , i_nt_exclude_stations in     nt_stn_id
   , o_nt_stn_id              out nt_stn_id
   , o_nt_final_stn_id        out nt_stn_id
   )
is
   



















































   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.DETERMINE_STATIONS';

   

   cursor c_get_pae_tdn_by_tin
    ( i_tin_id in lm_task_instructions.id%type
    )
   is
   select pae.pid
   ,      pae.bid
   ,      pae.bid_extension
   ,      pae.priority_indicator
   ,      pae.rgp_id
   ,      pae.pcm_name
   ,      pae.rst_id
   ,      tin.sep_id
   ,      tin.pay_id
   ,      tin.time_limit
   ,      tin.time_limit_process_activity
   ,      tin.origin
   ,      tin.handler
   ,      tdn.id tdn_id
   ,      tdn.tdn_id_backup
   ,      tdn.task_instruction_type
   ,      tdn.ind_controlled_routing
   ,      tinv.id tin_id_active
   from   lm_task_definitions tdn
   ,      lm_task_instructions tin
   ,      lm_packages pae
   ,      lm_tin_active_of_package_v tinv
   where  tin.pid      = pae.pid
   and    tin.tdn_id   = tdn.id
   and    tin.id       = i_tin_id
   and    tinv.pid (+) = tin.pid;      

   l_exception_processed        boolean := false;
   l_nt_task_stations_final     nt_stn_id := nt_stn_id(); 
   l_nt_available_stations      nt_stn_id := nt_stn_id(); 
   l_nt_unavailable_stations    nt_stn_id := nt_stn_id(); 
   l_nt_allowed_stations        nt_stn_ranks := nt_stn_ranks(); 
                                                                
   l_rt_tat                     lm_task_assignments%rowtype;
   l_ind_use_backup             boolean;
   l_rt_gpt                     c_get_pae_tdn_by_tin%rowtype;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_nt_stn_id       := nt_stn_id();
   o_nt_final_stn_id := nt_stn_id();

   
   open  c_get_pae_tdn_by_tin( i_tin_id => i_tin_id);
   fetch c_get_pae_tdn_by_tin into l_rt_gpt;
   close c_get_pae_tdn_by_tin;

   if not i_ind_use_backup_task
   then
      check_controlled_routing( i_tin_id            => i_tin_id
                              , i_pid               => l_rt_gpt.pid
                              , i_source            => i_source
                              , i_tdn_id            => l_rt_gpt.tdn_id
                              , i_tdn_id_backup     => l_rt_gpt.tdn_id_backup
                              , i_ind_contr_routing => l_rt_gpt.ind_controlled_routing
                              , o_ind_use_backup    => l_ind_use_backup
                              );
      if l_ind_use_backup
      then
         lm_topology_administration.determine_stations( i_tin_id              => i_tin_id
                                                      , i_source              => i_source
                                                      , i_ind_use_backup_task => true
                                                      , i_nt_exclude_stations => nt_stn_id()
                                                      , o_nt_stn_id           => o_nt_stn_id
                                                      , o_nt_final_stn_id     => o_nt_final_stn_id
                                                      );
         viu_module.leave_module( i_module      => l_con_proc_name );
         return;
      end if;
   else
      
      
      l_rt_gpt.tdn_id := l_rt_gpt.tdn_id_backup;
   end if;

   load_final_stations( i_tin_id                    => i_tin_id
                      , i_ind_use_backup_task       => i_ind_use_backup_task
                      , o_nt_task_stations_final    => l_nt_task_stations_final
                      );
   
   

   
   lm_topology_administration.select_task_assignment( i_rst_id             => l_rt_gpt.rst_id
                                                    , i_tdn_id             => l_rt_gpt.tdn_id
                                                    , i_nt_final_stations  => l_nt_task_stations_final
                                                    , i_source             => i_source
                                                    , i_pid                => l_rt_gpt.pid
                                                    , i_bid                => l_rt_gpt.bid
                                                    , i_bid_extension      => l_rt_gpt.bid_extension
                                                    , i_task_type          => l_rt_gpt.task_instruction_type
                                                    , i_origin             => l_rt_gpt.origin
                                                    , o_rt_tat             => l_rt_tat
                                                    , o_route_impossible   => l_exception_processed
                                                    , o_nt_stn_id_fallback => o_nt_stn_id
                                                    );
   
   if not l_exception_processed
   then
      
      
      load_stations( i_tin_id                    => i_tin_id
                   , i_tdn_id                    => l_rt_gpt.tdn_id
                   , i_tin_id_active             => l_rt_gpt.tin_id_active
                   , i_handler                   => l_rt_gpt.handler
                   , i_rst_id                    => l_rt_gpt.rst_id
                   , i_time_limit_pay            => l_rt_gpt.time_limit_process_activity
                   , i_snp_id_primary            => l_rt_tat.snp_id
                   , i_source                    => i_source
                   , i_nt_exclude_stations       => i_nt_exclude_stations
                   , i_ind_use_backup_task       => i_ind_use_backup_task
                   , i_pid                       => l_rt_gpt.pid
                   , i_bid                       => l_rt_gpt.bid
                   , i_bid_extension             => l_rt_gpt.bid_extension
                   , i_task_type                 => l_rt_gpt.task_instruction_type
                   , i_origin                    => l_rt_gpt.origin
                   , o_nt_available_stations     => l_nt_available_stations
                   , o_nt_unavailable_stations   => l_nt_unavailable_stations
                   , o_nt_allowed_stations       => l_nt_allowed_stations
                   , o_route_impossible          => l_exception_processed
                   , o_nt_stn_id_fallback        => o_nt_stn_id
                   );
   end if;

   if not l_exception_processed
   then
      
      
      
      

      
      
      

      
      
      
      
      
      
      lm_topology_administration.get_stations( i_snp_id                 => l_rt_tat.snp_id
                                             , i_nt_stations            => l_nt_available_stations
                                             , i_nt_final_stations      => l_nt_task_stations_final
                                             , i_pay_id                 => case l_rt_tat.ind_use_segr_for_loadbalancing
                                                                              when lm_constant.g_con_yesno_yes
                                                                              then
                                                                                 l_rt_gpt.pay_id
                                                                              else
                                                                                 null
                                                                              end
                                             , i_priority_indicator     => l_rt_gpt.priority_indicator
                                             , o_nt_determined_stations => o_nt_stn_id
                                             , o_nt_used_final_stations => o_nt_final_stn_id
                                             );

      
      
      
      if o_nt_stn_id is empty
      then
         if i_source in ( lm_constant.g_con_src_logistic_backup
                        , lm_constant.g_con_src_recirculation
                        )
         then
            
            
            viu_module.leave_module( i_module      => l_con_proc_name );
            return;
         end if;

         if     not i_ind_use_backup_task
            and l_rt_gpt.tdn_id_backup is not null
         then
            
            
            
            determine_stations( i_tin_id              => i_tin_id
                              , i_source              => i_source
                              , i_nt_exclude_stations => nt_stn_id()
                              , i_ind_use_backup_task => true
                              , o_nt_stn_id           => o_nt_stn_id
                              , o_nt_final_stn_id     => o_nt_final_stn_id
                              );

            viu_module.leave_module( i_module      => l_con_proc_name );
            return;
         end if;

         
         
         
         handle_no_available_stations( i_rt_tat                  => l_rt_tat
                                     , i_nt_unavailable_stations => l_nt_unavailable_stations
                                     , i_nt_task_stations_final  => l_nt_task_stations_final
                                     , i_pay_id                  => l_rt_gpt.pay_id
                                     , i_priority_indicator      => l_rt_gpt.priority_indicator
                                     , i_origin                  => l_rt_gpt.origin
                                     , i_source                  => i_source
                                     , i_pid                     => l_rt_gpt.pid
                                     , i_bid                     => l_rt_gpt.bid
                                     , i_bid_extension           => l_rt_gpt.bid_extension
                                     , i_task_type               => l_rt_gpt.task_instruction_type
                                     , o_nt_stn_id               => o_nt_stn_id
                                     , o_nt_final_stn_id         => o_nt_final_stn_id
                                     );
      end if; 

   end if;  

   update_temp_task( i_tin_id              => i_tin_id
                   , i_tdn_id_backup       => l_rt_gpt.tdn_id_backup
                   , i_ind_use_backup_task => i_ind_use_backup_task
                   , i_ind_stns_selected   => (o_nt_stn_id is not empty)
                   );

   update_store_rank( i_tin_id                 => i_tin_id
                    , i_nt_allowed_stations    => l_nt_allowed_stations
                    , i_nt_determined_stations => o_nt_stn_id
                    );

   
   
   
   
   
   
   
   
   
   
    
   lm_topology_administration.determine_stations_ebs
      ( i_tin_id                  => i_tin_id
      , i_source                  => i_source
      , i_pae_rst_id              => l_rt_gpt.rst_id
      , i_task_type               => l_rt_gpt.task_instruction_type
      , i_pcm_name                => l_rt_gpt.pcm_name
      , i_time_limit              => l_rt_gpt.time_limit
      , i_sep_id                  => l_rt_gpt.sep_id
      , i_pid                     => l_rt_gpt.pid
      , i_bid                     => l_rt_gpt.bid
      , i_bid_extension           => l_rt_gpt.bid_extension
      , i_origin                  => l_rt_gpt.origin
      , io_nt_determined_stations => o_nt_stn_id
      );

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_pae_tdn_by_tin%isopen
      then
         close c_get_pae_tdn_by_tin;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end determine_stations;


procedure determine_destinations
   ( i_nt_stn_id                   in     nt_stn_id
   , i_ind_for_package_instruction in     boolean default true
   , o_it_pon_id                      out lm_topology_administration.g_it_dst
   , o_rt_haa                         out lm_handling_areas%rowtype
   )
is


cursor c_haa_access_stations
 (i_nt_stn_id in nt_stn_id)
 is
select /*+ CARDINALITY (stn, 5) */ distinct han.haa_id
from   lm_handling_area_stations han
,      table(i_nt_stn_id)        stn
where  stn.column_value = han.stn_id (+);


cursor c_stn_list
 (i_nt_stn_id in nt_stn_id)
 is
select listagg(column_value, '; ') within group (order by column_value)
from   table(i_nt_stn_id);

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.DETERMINE_DESTINATIONS';

l_duplicate_found boolean;
l_pon_id lm_physical_destinations.id%type;
l_found boolean;
l_haa_id lm_handling_areas.id%type;
l_sct_id lm_physical_destinations.sct_id%type;
l_all_virtual_stn boolean := true;
l_stn_list varchar2(200);



































begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   for idx_dest in 1 .. case
                           when i_ind_for_package_instruction
                              then least(lm_constant.g_con_top_max_destinations,i_nt_stn_id.count)
                              else i_nt_stn_id.count
                        end
   loop
      l_duplicate_found := false;
      
      lm_topology_administration.get_destination( i_station      => i_nt_stn_id( idx_dest )
                                                , o_pon_id       => l_pon_id
                                                , o_sct_id       => l_sct_id
                                                );

      
      
      
      for idx_chk in 1 .. o_it_pon_id.count
      loop
         if l_pon_id = o_it_pon_id( idx_chk )
         then
            
            l_duplicate_found := true;
         end if;
      end loop;

      if not l_duplicate_found
      then
         
         o_it_pon_id( idx_dest )  := l_pon_id;
      end if;

      
      l_all_virtual_stn := l_all_virtual_stn and l_sct_id is null;

   end loop;

   if l_all_virtual_stn
   then
      
      open c_haa_access_stations( i_nt_stn_id => i_nt_stn_id);
      fetch c_haa_access_stations
      into  l_haa_id;
      if c_haa_access_stations%found
      then
         
         l_found := lm_haa_tapi_pck.haa_select_row( i_haa_id => l_haa_id
                                                  , o_rt_haa => o_rt_haa
                                                  );
         
         fetch c_haa_access_stations
         into  l_haa_id;
         if c_haa_access_stations%found
         then
            open c_stn_list(i_nt_stn_id => i_nt_stn_id);
            fetch c_stn_list into l_stn_list;
            close c_stn_list;
            viu_info.operator_info(i_ifo_nr            => viu_constant.c_ifo_toomanyhandlingareas
                                  ,i_calling_procedure => l_con_proc_name
                                  ,i_severity          => viu_info.c_severity_warning
                                  ,i_info_arguments    => null
                                  ,i_additional_data   => 'Station list: ' || l_stn_list
                                  );
         end if;
      end if;
      close c_haa_access_stations;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_haa_access_stations%isopen
      then
         close c_haa_access_stations;
      end if;
      if c_stn_list%isopen
      then
         close c_stn_list;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end determine_destinations;


function get_sct_id
   ( i_area_id_cust    in lm_areas_v.id_cust%type
   , i_zone_id_cust    in lm_zones_v.id_cust%type
   , i_section_id_cust in lm_sections_v.id_cust%type
   )
return lm_system_components.id%type
is

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.GET_SCT_ID';

l_sct_id lm_system_components.id%type;


cursor c_get_area_id
 (i_area_id_cust lm_areas_v.id_cust%type
 )
 is
select aea.area_id as sct_id
from   lm_areas_v aea
where  aea.id_cust = i_area_id_cust;

cursor c_get_zone_id
 (i_area_id_cust in lm_areas_v.id_cust%type
 ,i_zone_id_cust in lm_zones_v.id_cust%type
 )
 is
select zne.zone_id as zne_id
from   lm_areas_v     ara
,      lm_zones_v     zne
where  zne.area_id = ara.area_id
and    ara.id_cust = i_area_id_cust
and    zne.id_cust = i_zone_id_cust
;

cursor c_get_section_id
 (i_area_id_cust in lm_areas_v.id_cust%type
 ,i_zone_id_cust in lm_zones_v.id_cust%type
 ,i_section_id_cust in lm_sections_v.id_cust%type
 )
 is
select sen.section_id as sen_id
from   lm_areas_v     ara
,      lm_zones_v     zne
,      lm_sections_v  sen
where  zne.area_id = ara.area_id
and    sen.zone_id = zne.zone_id
and    ara.id_cust = i_area_id_cust
and    zne.id_cust = i_zone_id_cust
and    sen.id_cust = i_section_id_cust
;


























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if i_zone_id_cust is null   
   then
      open c_get_area_id( i_area_id_cust      => i_area_id_cust );

      fetch c_get_area_id
      into  l_sct_id;

      close c_get_area_id;
   elsif i_section_id_cust is null   
   then
      open c_get_zone_id( i_area_id_cust      => i_area_id_cust
                        , i_zone_id_cust      => i_zone_id_cust
                        );

      fetch c_get_zone_id
      into  l_sct_id;

      close c_get_zone_id;
   else   
      open c_get_section_id( i_area_id_cust         => i_area_id_cust
                           , i_zone_id_cust         => i_zone_id_cust
                           , i_section_id_cust      => i_section_id_cust
                           );

      fetch c_get_section_id
      into  l_sct_id;

      close c_get_section_id;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
   return l_sct_id;
exception
   when others
   then
      if c_get_area_id%isopen
      then
         close c_get_area_id;
      end if;

      if c_get_zone_id%isopen
      then
         close c_get_zone_id;
      end if;

      if c_get_section_id%isopen
      then
         close c_get_section_id;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end;


procedure get_destination
   ( i_station in     lm_stations.id%type
   , o_pon_id     out lm_physical_destinations.id%type
   , o_sct_id     out lm_system_components.id%type
   )
is


cursor c_destinations
 (i_stn_id lm_stations.id%type
 )
 is
select sre.pon_id
,      pon.sct_id
from   lm_station_reachabilities sre
,      lm_system_components sct
,      lm_modes_of_operation mon
,      lm_physical_destinations pon
where  sre.sct_id = sct.id (+)
and    sct.id = mon.sct_id (+)
and    sre.pon_id = pon.id
and    sre.mom_id = nvl(mon.mom_id, lm_constant.g_con_mom_mom_mode_normal)
and    sre.stn_id = i_stn_id
;

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.GET_DESTINATION';





























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   open c_destinations( i_stn_id      => i_station );

   
   fetch c_destinations
   into  o_pon_id
   ,     o_sct_id;

   if c_destinations%notfound
   then   
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_nophysicaldestfound
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        => 'station: ''' || i_station || ''''
                         );
   end if;

   close c_destinations;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_destinations%isopen
      then
         close c_destinations;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end;


procedure evaluate_pck_instr_for_pck
   ( i_pid in lm_packages.pid%type
   )
is




























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.EVALUATE_PCK_INSTR_FOR_PCK';

   
   cursor c_get_determined_station
    (i_tin_id in lm_task_instructions.id%type
    )
    is
   select dsn.stn_id stn_id
   ,      dsn.ind_final_expected
   from   lm_determined_stations dsn
   where  dsn.tin_id = i_tin_id
   and    dsn.ind_final_expected = lm_constant.g_con_yesno_no;

   
   cursor c_active_tin_by_pid
    (i_pid in lm_packages.pid%type
    )
   is
   
   select tpev.id as tin_id
   from   lm_tin_active_of_package_v tpev
   where  tpev.pid = i_pid
   and    tpev.pss_id in (lm_constant.g_con_pss_name_open, lm_constant.g_con_pss_name_suspect);

   l_pon_found                boolean;
   l_pae_found                boolean;
   l_pin_created              boolean := false;
   l_rows_updated             number;
   l_pin_event_time           lm_package_instructions.date_created%type;
   l_rt_pae                   lm_packages%rowtype;
   l_rt_pon                   lm_physical_destinations%rowtype;
   l_nt_stn_id                nt_stn_id := nt_stn_id();
   l_it_pon_id                lm_topology_administration.g_it_dst;
   l_it_pon_id_cust           lm_common.g_it_pon_id_cust;
   l_pin_ims_id               lm_package_instructions.ims_id%type;
   l_rt_pin                   lm_package_instructions%rowtype;
   l_tin_id                   lm_task_instructions.id%type;
   rec_get_determined_station c_get_determined_station%rowtype;
   l_rt_haa                   lm_handling_areas%rowtype;
   l_nt_screeninginstruction  nt_screeninginstruction;
   l_package_instruction      lm_common.g_rt_package_instruction;
   pragma autonomous_transaction;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );
   
   l_pae_found  := lm_pae_tapi_pck.pae_select_row_upd( i_pae_pid      => i_pid
                                                     , o_rt_pae       => l_rt_pae
                                                     );

   


   open c_active_tin_by_pid( i_pid      => l_rt_pae.pid );

   fetch c_active_tin_by_pid
   into  l_tin_id;

   if c_active_tin_by_pid%notfound
   then
      close c_active_tin_by_pid;

      
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_notaskinstrfound
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_additional_data        => 'PID: ' || l_rt_pae.pid
                         );
   else
      close c_active_tin_by_pid;
   end if;

   
   for rec_get_determined_station in c_get_determined_station( i_tin_id      => l_tin_id )
   loop
      l_nt_stn_id.extend;
      l_nt_stn_id( l_nt_stn_id.count )  := rec_get_determined_station.stn_id;
   end loop;

   
   lm_topology_administration.determine_destinations( i_nt_stn_id      => l_nt_stn_id
                                                    , o_it_pon_id      => l_it_pon_id
                                                    , o_rt_haa         => l_rt_haa
                                                    );

   



   if l_it_pon_id.count > 0
   then
      
      l_pin_event_time  := lm_common.default_timestamp;
      
      lm_package_administration.store_package_instruction( i_pid            => l_rt_pae.pid
                                                         , i_pty_id         => l_rt_pae.pty_id
                                                         , i_it_pon_id      => l_it_pon_id
                                                         , i_haa_id         => l_rt_haa.id
                                                         , o_rt_pin         => l_rt_pin
                                                         );
      l_pin_created     := true;
   end if;

   


   if l_pin_created
   then
      



      if l_rt_pae.pss_id = lm_constant.g_con_pss_name_suspect
      then
         viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_packageinstructionerror
                               , i_calling_procedure      => l_con_proc_name
                               , i_severity               => viu_info.c_severity_notification
                               , i_additional_data        => 'Message: PackageInstruction; PID:' || l_rt_pae.pid
                               );
      else
         



         for idx_pon in l_it_pon_id.first .. l_it_pon_id.last
         loop
            l_pon_found                  := lm_pon_tapi_pck.pon_select_row( i_pon_id      => l_it_pon_id( idx_pon )
                                                                          , o_rt_pon      => l_rt_pon
                                                                          );
            l_it_pon_id_cust( idx_pon )  := l_rt_pon.id_cust;
         end loop;

         l_nt_screeninginstruction := lm_package_administration.get_screeninginstruction(i_pid => l_rt_pae.pid);

         
         
         
         
         
         
         
         l_package_instruction.instruction.it_pon_id_cust          := l_it_pon_id_cust;
         l_package_instruction.instruction.destination_haa_id_cust := l_rt_haa.id_cust;
         l_package_instruction.instruction.priority_indicator      := l_rt_pae.priority_indicator;
         l_package_instruction.instruction.release_group_id        := l_rt_pae.rgp_id;
         l_package_instruction.screeninginstruction                := l_nt_screeninginstruction;
         l_package_instruction.recovery.screeninginfo              := nt_screeninginfo();
         lm_package_administration.send_instruction_for_package(i_pty_id     => l_rt_pae.pty_id
                                                               ,i_event_time => lm_common.default_timestamp
                                                               ,i_pid        => l_rt_pae.pid
                                                               ,i_lic_id     => l_rt_pae.lic
                                                               ,i_pi         => l_package_instruction
                                                               ,o_ims_id     => l_pin_ims_id
                                                               );
         



         l_rt_pin.ims_id  := l_pin_ims_id;
         l_rows_updated   := lm_pin_tapi_pck.pin_update_row( i_pin_id       => l_rt_pin.id
                                                           , io_rt_pin      => l_rt_pin
                                                           );
      end if;
   end if;

   


   commit;   
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      rollback;   

      if c_active_tin_by_pid%isopen
      then
         close c_active_tin_by_pid;
      end if;

      if c_get_determined_station%isopen
      then
         close c_get_determined_station;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end evaluate_pck_instr_for_pck;


procedure evaluate_task_instr_for_pck
   ( i_pid                     in     lm_packages.pid%type
   , i_tin_id                  in     lm_task_instructions.id%type
   , i_source                  in     varchar2 := 'NULL'
   , i_nt_exclude_stations     in     nt_stn_id
   , o_new_determined_stations    out boolean
   )
is
   l_con_proc_name           constant lm_constant.st_proc_name := g_con_package
                                                               || '.EVALUATE_TASK_INSTR_FOR_PCK';

   



























   pragma autonomous_transaction;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   
   
   
   
   
   
   lm_topology_administration.evaluate_taskinstruction( i_pid                     => i_pid
                                                      , i_tin_id                  => i_tin_id
                                                      , i_source                  => i_source
                                                      , i_nt_exclude_stations     => i_nt_exclude_stations
                                                      , o_new_determined_stations => o_new_determined_stations
                                                      );

   
   
   commit;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      rollback;  

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end evaluate_task_instr_for_pck;


procedure store_determined_stations
   ( i_tin_id          in lm_task_instructions.id%type
   , i_nt_stn_id       in nt_stn_id
   , i_nt_final_stn_id in nt_stn_id
   )
is

l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.STORE_DETERMINED_STATIONS';

l_rt_dsn lm_determined_stations%rowtype;

























begin
   viu_module.enter_module( i_module      => l_con_proc_name );
   
   l_rt_dsn.tin_id  := i_tin_id;

   
   for idx_stn in 1 .. i_nt_stn_id.count
   loop
      l_rt_dsn.stn_id  := i_nt_stn_id( idx_stn );
      l_rt_dsn.ind_final_expected := lm_constant.g_con_yesno_no;
      lm_dsn_tapi_pck.dsn_insert_row( io_rt_dsn      => l_rt_dsn );
   end loop;

   
   for idx_final_stn in 1 .. i_nt_final_stn_id.count
   loop
      l_rt_dsn.stn_id := i_nt_final_stn_id( idx_final_stn );
      l_rt_dsn.ind_final_expected := lm_constant.g_con_yesno_yes;
      lm_dsn_tapi_pck.dsn_insert_row( io_rt_dsn      => l_rt_dsn );
   end loop;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end store_determined_stations;


procedure get_stations
   ( i_snp_id                 in     lm_station_groups.id%type
   , i_nt_stations            in     nt_stn_id
   , i_nt_final_stations      in     nt_stn_id
   , i_pay_id                 in     lm_process_activities.id%type
   , i_priority_indicator     in     lm_packages.priority_indicator%type
   , o_nt_determined_stations    out nt_stn_id
   , o_nt_used_final_stations    out nt_stn_id
   )
is
   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.GET_STATIONS';

   













   
   cursor c_station_group_alternatives(i_snp_id in lm_station_groups.id%type)
   is
   select snp.id as snp_id
   from   lm_station_groups snp
   where  snp.snp_id_alternative = i_snp_id
   order by snp.rank
   ;

   l_rt_snp        lm_station_groups%rowtype;
   l_found         boolean;
   l_nt_stations   nt_stn_id := nt_stn_id();
   l_snp_id        lm_station_groups.id%type;
   l_stn_id        lm_stations.id%type;
   l_sec_snp_id    lm_station_groups.id%type;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_nt_determined_stations := nt_stn_id();
   o_nt_used_final_stations := nt_stn_id();

   
   if i_nt_stations is not empty
   then
      

      
      l_found := lm_snp_tapi_pck.snp_select_row( i_snp_id => i_snp_id
                                               , o_rt_snp => l_rt_snp
                                               );

      
      lm_topology_administration.determine_stations_in_group( i_snp_id      => i_snp_id
                                                            , i_nt_stations => i_nt_stations
                                                            , o_nt_stations => l_nt_stations
                                                            );
      if l_nt_stations is empty
      then
         
         for l_rt_alt_snp_id in c_station_group_alternatives( i_snp_id => i_snp_id )
         loop
            o_nt_used_final_stations.delete;
            lm_topology_administration.get_stations( i_snp_id                 => l_rt_alt_snp_id.snp_id
                                                   , i_nt_stations            => i_nt_stations
                                                   , i_nt_final_stations      => i_nt_final_stations
                                                   , i_pay_id                 => i_pay_id
                                                   , i_priority_indicator     => i_priority_indicator
                                                   , o_nt_determined_stations => o_nt_determined_stations
                                                   , o_nt_used_final_stations => o_nt_used_final_stations
                                                   );
            if o_nt_determined_stations is not empty
            then
               
               viu_module.leave_module( i_module      => l_con_proc_name );
               return;
            end if;
         end loop;
      else
         
         lm_topology_administration.select_secondary_group( i_snp_id      => i_snp_id
                                                          , i_nt_stations => i_nt_stations
                                                          , i_pay_id      => i_pay_id
                                                          , o_snp_id      => l_sec_snp_id
                                                          );

         if l_sec_snp_id is not null
         then
            
            lm_topology_administration.get_stations( i_snp_id                 => l_sec_snp_id
                                                   , i_nt_stations            => i_nt_stations
                                                   , i_nt_final_stations      => i_nt_final_stations
                                                   , i_pay_id                 => i_pay_id
                                                   , i_priority_indicator     => i_priority_indicator
                                                   , o_nt_determined_stations => o_nt_determined_stations
                                                   , o_nt_used_final_stations => o_nt_used_final_stations
                                                   );
            viu_module.leave_module( i_module      => l_con_proc_name );
            return;
         end if;
      end if;

      
      
      if l_nt_stations is not empty
      then
         
         if l_rt_snp.ind_loadbalance_groupwise = lm_constant.g_con_snp_load_yes
            or ( l_rt_snp.ind_loadbalance_groupwise = lm_constant.g_con_snp_load_conditional
                 and i_priority_indicator = lm_constant.g_con_yesno_yes
               )
         then
            
            
            lm_topology_administration.determine_stations_in_group( i_snp_id      => i_snp_id
                                                                  , i_nt_stations => i_nt_stations
                                                                  , o_nt_stations => o_nt_determined_stations
                                                                  );
         else
            
            
            lm_topology_administration.select_member_of_group( i_snp_id                 => i_snp_id
                                                             , i_nt_stations            => i_nt_stations
                                                             , i_nt_final_stations      => i_nt_final_stations
                                                             , i_pay_id                 => i_pay_id
                                                             , o_snp_id                 => l_snp_id
                                                             , o_stn_id                 => l_stn_id
                                                             , o_nt_used_final_stations => o_nt_used_final_stations
                                                             );
            
            

            if l_stn_id is not null
            then
               
               o_nt_determined_stations.extend;
               o_nt_determined_stations( o_nt_determined_stations.count ) := l_stn_id;
            else
               
               l_found := lm_snp_tapi_pck.snp_select_row( i_snp_id => l_snp_id
                                                        , o_rt_snp => l_rt_snp
                                                        );
               if l_rt_snp.ind_loadbalance_groupwise = lm_constant.g_con_snp_load_yes
                  or ( l_rt_snp.ind_loadbalance_groupwise = lm_constant.g_con_snp_load_conditional
                       and i_priority_indicator = lm_constant.g_con_yesno_yes
                     )
               then
                  
                  
                  lm_topology_administration.determine_stations_in_group( i_snp_id      => l_snp_id
                                                                        , i_nt_stations => i_nt_stations
                                                                        , o_nt_stations => o_nt_determined_stations
                                                                        );
               else
                  
                  
                  o_nt_used_final_stations.delete;
                  lm_topology_administration.get_stations( i_snp_id                 => l_snp_id
                                                         , i_nt_stations            => i_nt_stations
                                                         , i_nt_final_stations      => i_nt_final_stations
                                                         , i_pay_id                 => i_pay_id
                                                         , i_priority_indicator     => i_priority_indicator
                                                         , o_nt_determined_stations => o_nt_determined_stations
                                                         , o_nt_used_final_stations => o_nt_used_final_stations
                                                         );
               end if;
            end if;
         end if;
      end if;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_stations;


procedure loadfactor
   ( i_nt_stations     in     nt_stn_id
   , i_pay_id          in     lm_process_activities.id%type
   , i_tin_id_exclude  in     lm_task_instructions.id%type default null
   , i_ind_loadbalance in     boolean default true
   , o_load_factor        out number
   )
is

























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.LOADFACTOR';


   
   cursor c_get_load_factor
   ( b_nt_stations             in nt_stn_id
   , b_limit_consider_open_pck in timestamp
   , b_tin_id_exclude          in lm_task_instructions.id%type
   )
   is
   






























































































   select nvl(sum( 1/count_dsn ), 0) as weighted_packages
   from
      ( select /*+ CARDINALITY(stn 1) ORDERED */
          ( select count(*)
            from lm_determined_stations dsn2
            where dsn2.tin_id             = dsn.tin_id
          ) count_dsn
        from   table (b_nt_stations)  stn
        ,      lm_task_handling       thg
        ,      lm_task_instructions   tin
        ,      lm_determined_stations dsn
        where  dsn.stn_id             = stn.column_value
        and    thg.stn_id             = stn.column_value
        and    (dsn.tin_id           != b_tin_id_exclude
                or
                b_tin_id_exclude     is null
               )
        and    (case tin.pss_id when lm_constant.get_pss_id_open then nvl(tin.tdn_id_temporary, tin.tdn_id) end) = thg.tdn_id
        and    (b_limit_consider_open_pck is null  
                or                                 
                                                   
                (case tin.pss_id when lm_constant.get_pss_id_open then tin.event_time end) > b_limit_consider_open_pck
               )
        and    (case tin.pss_id when lm_constant.get_pss_id_open then tin.id end) = dsn.tin_id
      );

   
   cursor c_get_pay_load_factor
   ( b_nt_stations             in nt_stn_id
   , b_pay_id                  in lm_process_activities.id%type
   , b_limit_consider_open_pck in timestamp
   , b_tin_id_exclude          in lm_task_instructions.id%type
   )
   is
   




















































   select nvl(sum( 1/count_dsn ), 0) as weighted_packages
   from
      ( select /*+ ordered cardinality(stn, 4) */
         ( select count(*)
           from   lm_determined_stations dsn2
           where  dsn2.tin_id             = tin.id
         ) count_dsn
        from   table (b_nt_stations)  stn
        ,      lm_tin_loadbalancing_v tin
        ,      lm_determined_stations dsn
        where  dsn.tin_id  = tin.id
        and    dsn.stn_id  = stn.column_value
        and    tin.pay_id  = b_pay_id
        and    (dsn.tin_id != b_tin_id_exclude
                or
                b_tin_id_exclude is null
               )
        and    (( tin.pss_id         =  lm_constant.g_con_pss_name_open
                  and tin.event_time >= nvl(b_limit_consider_open_pck, tin.event_time)
                )
                or tin.pss_id = lm_constant.g_con_pss_name_closed
               )
      );

   l_weighted_packages        number;

   l_lf_interval              interval day to second;
   l_limit_consider_open_pck  timestamp := null;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if i_ind_loadbalance
   then
      
      l_lf_interval := lm_common.varchar_to_interval
                       ( lm_common.get_parameter_value( i_prr_name => lm_constant.g_con_pve_loadbalancing ));
      l_limit_consider_open_pck := lm_common.default_timestamp - l_lf_interval;
   end if;

   
   if i_pay_id is null
   then
      
      open c_get_load_factor( b_nt_stations             => i_nt_stations
                            , b_limit_consider_open_pck => l_limit_consider_open_pck
                            , b_tin_id_exclude          => i_tin_id_exclude
                            );
      fetch c_get_load_factor into l_weighted_packages;
      close c_get_load_factor;
   else
      
      open c_get_pay_load_factor( b_nt_stations             => i_nt_stations
                                , b_pay_id                  => i_pay_id
                                , b_limit_consider_open_pck => l_limit_consider_open_pck
                                , b_tin_id_exclude          => i_tin_id_exclude
                                );
      fetch c_get_pay_load_factor into l_weighted_packages;
      close c_get_pay_load_factor;
   end if;

   
   
   o_load_factor := l_weighted_packages/i_nt_stations.count;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_load_factor%isopen
      then
         close c_get_load_factor;
      end if;

      if c_get_pay_load_factor%isopen
      then
         close c_get_pay_load_factor;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end loadfactor;


function get_area_id_cust
   ( i_sct_id   in lm_system_components.id%type
   , i_sct_type in lm_system_components.sct_type%type
   )
return lm_system_components.id_cust%type
is

l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.GET_AREA_ID_CUST';

l_found boolean;
l_rt_sct lm_system_components%rowtype;
l_return_value lm_system_components.id_cust%type;




























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if i_sct_type = lm_constant.g_con_sct_type_ara
   then
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => i_sct_id
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      l_return_value  := l_rt_sct.id_cust;
   elsif i_sct_type = lm_constant.g_con_sct_type_zne
   then
      
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => i_sct_id
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => l_rt_sct.sct_id_zone_area
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      l_return_value  := l_rt_sct.id_cust;
   elsif i_sct_type = lm_constant.g_con_sct_type_sen
   then
      
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => i_sct_id
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => l_rt_sct.sct_id_section_zone
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      
      l_found         := lm_sct_tapi_pck.sct_select_row( i_sct_id      => l_rt_sct.sct_id_zone_area
                                                       , o_rt_sct      => l_rt_sct
                                                       );
      l_return_value  := l_rt_sct.id_cust;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
   return l_return_value;
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_area_id_cust;


procedure select_member_of_group
   ( i_snp_id                 in     lm_station_groups.id%type
   , i_nt_stations            in     nt_stn_id
   , i_nt_final_stations      in     nt_stn_id
   , i_pay_id                 in     lm_process_activities.id%type
   , o_snp_id                    out lm_station_groups.id%type
   , o_stn_id                    out lm_station_group_members.stn_id_member_station%type
   , o_nt_used_final_stations    out nt_stn_id
   )
 is
   













   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.SELECT_MEMBER_OF_GROUP';

   
   cursor c_get_station_group_member_cnt
    (i_snp_id in lm_station_groups.id%type
    )
   is
   select sgm.snp_id_member_group
   ,      sgm.stn_id_member_station
   ,      ( select count(*)
            from   lm_station_group_members
            where  snp_id_define = i_snp_id
          ) as sgm_count
   from   lm_station_group_members sgm
   where  sgm.snp_id_define = i_snp_id;

   
   cursor c_get_station_group_members
    (i_snp_id in lm_station_groups.id%type
    )
   is
   select sgm.stn_id_member_station
   ,      sgm.snp_id_member_group
   ,      sgm.snp_id_heading_to
   ,      sgm.mom_id
   from   lm_station_group_members sgm
   where  sgm.snp_id_define = i_snp_id;

   
   cursor c_get_ht_station_group_members
    (i_snp_id in lm_station_groups.id%type
    )
   is
   select sgm.stn_id_member_station
   ,      sgm.snp_id_member_group
   ,      sgm.snp_id_heading_to
   from   lm_station_group_members sgm
   where  sgm.snp_id_define = i_snp_id
   and    sgm.snp_id_heading_to is not null;

   
   cursor c_get_mode_of_operation
    (i_stn_id in lm_station_group_members.stn_id_member_station%type
    ,i_mom_id in lm_station_group_members.mom_id%type
    )
   is
   
   
   
   
   
   select mon.mom_id
   from   lm_station_reachabilities sry
   ,      lm_modes_of_operation mon
   where  sry.stn_id = i_stn_id
   and    sry.sct_id = mon.sct_id
   and    sry.mom_id = i_mom_id;

   l_nt_usable_final_stations nt_stn_id := nt_stn_id();
   l_mom_id                   lm_modes_of_operation.mom_id%type;
   l_load_factor              number;
   l_found                    boolean;
   l_rt_sgm_count             c_get_station_group_member_cnt%rowtype;
   l_nt_stations              nt_stn_id := nt_stn_id();
   l_lowest_load_factor       number;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_nt_used_final_stations := nt_stn_id();

   
   open c_get_station_group_member_cnt( i_snp_id => i_snp_id );
   fetch c_get_station_group_member_cnt into l_rt_sgm_count;
   l_found := c_get_station_group_member_cnt%found;
   close c_get_station_group_member_cnt;

   
   
   if not l_found
   then
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_nostationgroupmembers
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_warning
                            , i_additional_data        => 'Station group: ' || i_snp_id
                            );
   elsif l_rt_sgm_count.sgm_count = 1
      and l_rt_sgm_count.snp_id_member_group is not null
   then
      
      o_snp_id := l_rt_sgm_count.snp_id_member_group;
   elsif l_rt_sgm_count.sgm_count = 1
      and l_rt_sgm_count.stn_id_member_station is not null
   then
      
      o_stn_id := l_rt_sgm_count.stn_id_member_station;
   else
      

      
      if i_nt_final_stations is not empty
      then
         
         for l_rt_ht_sgr in c_get_ht_station_group_members( i_snp_id => i_snp_id )
         loop
            
            
            if l_rt_ht_sgr.stn_id_member_station is not null
            then
               
               
               l_nt_stations.delete;
               
               if l_rt_ht_sgr.stn_id_member_station member i_nt_stations
               then
                  
                  l_nt_stations.extend;
                  l_nt_stations(1) := l_rt_ht_sgr.stn_id_member_station;
               end if;
            else
               
               lm_topology_administration.determine_stations_in_group( i_snp_id      => l_rt_ht_sgr.snp_id_member_group
                                                                     , i_nt_stations => i_nt_stations
                                                                     , o_nt_stations => l_nt_stations
                                                                     );

            end if;

            if l_nt_stations is not empty
            then
               
               lm_topology_administration.determine_stations_in_group( i_snp_id      => l_rt_ht_sgr.snp_id_heading_to
                                                                     , i_nt_stations => i_nt_final_stations
                                                                     , o_nt_stations => l_nt_usable_final_stations
                                                                     );
               if l_nt_usable_final_stations is not empty
               then
                  
                  lm_topology_administration.loadfactor( i_nt_stations => l_nt_usable_final_stations
                                                       , i_pay_id      => i_pay_id
                                                       , o_load_factor => l_load_factor
                                                       );
                  if l_lowest_load_factor is null
                     or l_load_factor < l_lowest_load_factor
                  then
                     if l_rt_ht_sgr.snp_id_member_group is not null
                     then
                        
                        o_snp_id := l_rt_ht_sgr.snp_id_member_group;
                        o_stn_id := null;
                     else
                        
                        o_stn_id := l_rt_ht_sgr.stn_id_member_station;
                        o_snp_id := null;
                     end if;
                     
                     o_nt_used_final_stations.delete;
                     o_nt_used_final_stations := l_nt_usable_final_stations;

                     l_lowest_load_factor := l_load_factor;
                  end if;
               end if;
            end if;
         end loop;
      end if;

      
      
      if o_snp_id is null
         and o_stn_id is null
      then
         for l_rt_sgr in c_get_station_group_members( i_snp_id => i_snp_id )
         loop
            
            if l_rt_sgr.stn_id_member_station is not null
            then
               
               
               l_nt_stations.delete;
               
               if l_rt_sgr.stn_id_member_station member i_nt_stations
               then
                  
                  
                  if l_rt_sgr.mom_id is not null
                  then
                     
                     open c_get_mode_of_operation( i_stn_id => l_rt_sgr.stn_id_member_station
                                                 , i_mom_id => l_rt_sgr.mom_id
                                                );
                     fetch c_get_mode_of_operation into l_mom_id;
                     close c_get_mode_of_operation;
                     
                     
                     
                     if (    l_mom_id is null
                         and l_rt_sgr.mom_id = lm_constant.g_con_mom_mom_mode_normal
                        )
                        or l_mom_id = l_rt_sgr.mom_id
                     then
                        
                        l_nt_stations.extend;
                        l_nt_stations(1) := l_rt_sgr.stn_id_member_station;
                     end if;
                  else
                     
                     l_nt_stations.extend;
                     l_nt_stations(1) := l_rt_sgr.stn_id_member_station;
                  end if;
               end if;
            else
               
               lm_topology_administration.determine_stations_in_group( i_snp_id      => l_rt_sgr.snp_id_member_group
                                                                     , i_nt_stations => i_nt_stations
                                                                     , o_nt_stations => l_nt_stations
                                                                     );
            end if;

            if l_nt_stations is not empty
            then
               
               lm_topology_administration.loadfactor( i_nt_stations => l_nt_stations
                                                    , i_pay_id      => i_pay_id
                                                    , o_load_factor => l_load_factor
                                                    );
               if l_lowest_load_factor is null
                  or l_load_factor < l_lowest_load_factor
               then

                  if l_rt_sgr.snp_id_member_group is not null
                  then
                     
                     o_snp_id := l_rt_sgr.snp_id_member_group;
                     o_stn_id := null;
                  else
                     
                     o_stn_id := l_rt_sgr.stn_id_member_station;
                     o_snp_id := null;
                  end if;
                  l_lowest_load_factor := l_load_factor;
               end if;
            end if;
         end loop;
      end if;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_station_group_member_cnt%isopen
      then
         close c_get_station_group_member_cnt;
      end if;
      if c_get_mode_of_operation%isopen
      then
         close c_get_mode_of_operation;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end select_member_of_group;


procedure select_secondary_group
   ( i_snp_id      in     lm_station_groups.id%type
   , i_nt_stations in     nt_stn_id
   , i_pay_id      in     lm_process_activities.id%type
   , o_snp_id         out lm_station_groups.id%type
   )
is
   














   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.SELECT_SECONDARY_GROUP';

   l_rt_snp                 lm_station_groups%rowtype;
   l_load_factor            number;
   l_load_factor_sec        number;
   l_nt_stations            nt_stn_id := nt_stn_id();
   l_found                  boolean;
   l_lowest_sec_loadfactor  number;

   
   cursor c_station_group_secondaries(i_snp_id in lm_station_groups.id%type)
   is
   select snp.id as snp_id
   ,      snp.switch_to_secondary
   from   lm_station_groups snp
   where  snp.snp_id_secondary = i_snp_id
   ;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   for l_rt_sgs in c_station_group_secondaries( i_snp_id => i_snp_id )
   loop
      
      if c_station_group_secondaries%rowcount = 1
      then
         
         l_found := lm_snp_tapi_pck.snp_select_row( i_snp_id => i_snp_id
                                                  , o_rt_snp => l_rt_snp
                                                  );

         
         lm_topology_administration.determine_stations_in_group( i_snp_id      => i_snp_id
                                                               , i_nt_stations => i_nt_stations
                                                               , o_nt_stations => l_nt_stations
                                                               );

         if l_nt_stations is not empty
         then
            
            lm_topology_administration.loadfactor( i_nt_stations => l_nt_stations
                                                 , i_pay_id      => i_pay_id
                                                 , o_load_factor => l_load_factor
                                                 );
            if l_load_factor = 0
            then
               
               
               exit;
            end if;
         end if;
      end if;

      l_nt_stations.delete;
      
      lm_topology_administration.determine_stations_in_group( i_snp_id      => l_rt_sgs.snp_id
                                                            , i_nt_stations => i_nt_stations
                                                            , o_nt_stations => l_nt_stations
                                                            );

      if l_nt_stations is not empty
      then
         
         lm_topology_administration.loadfactor( i_nt_stations => l_nt_stations
                                              , i_pay_id      => i_pay_id
                                              , o_load_factor => l_load_factor_sec
                                              );

         
         if (l_load_factor - l_load_factor_sec) >= l_rt_sgs.switch_to_secondary
         then
            if l_lowest_sec_loadfactor is null
               or l_load_factor_sec < l_lowest_sec_loadfactor
            then
               
               l_lowest_sec_loadfactor := l_load_factor_sec;
               o_snp_id := l_rt_sgs.snp_id;
            end if;
         end if;
      end if;
   end loop;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end select_secondary_group;


procedure determine_stations_in_group
   ( i_snp_id      in     lm_station_group_members.snp_id_define%type
   , i_nt_stations in     nt_stn_id
   , o_nt_stations    out nt_stn_id
   )
is
   















   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.DETERMINE_STATIONS_IN_GROUP';

   
   cursor c_sgm_station_group_stations
    (i_snp_id in lm_station_groups.id%type
    )
   is
   select sgm.stn_id_member_station
   ,      sgm.mom_id
   from   lm_station_group_members sgm
   where  sgm.stn_id_member_station is not null
   start with sgm.snp_id_define = i_snp_id
   connect by sgm.snp_id_define = prior sgm.snp_id_member_group;


   
   cursor c_get_mode_of_operation
    ( i_stn_id in lm_station_group_members.stn_id_member_station%type
    , i_mom_id in lm_station_group_members.mom_id%type
    )
   is
   
   
   
   
   
   select mon.mom_id
   from   lm_station_reachabilities sry
   ,      lm_modes_of_operation mon
   where  sry.stn_id = i_stn_id
   and    sry.sct_id = mon.sct_id
   and    sry.mom_id = i_mom_id;

   l_mom_id lm_modes_of_operation.mom_id%type;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_nt_stations := nt_stn_id();

   
   
   for l_rt_sas in c_sgm_station_group_stations( i_snp_id => i_snp_id )
   loop
      
      if l_rt_sas.stn_id_member_station member i_nt_stations
      then
         
         if l_rt_sas.mom_id is not null
         then
            
            open c_get_mode_of_operation( i_stn_id => l_rt_sas.stn_id_member_station
                                        , i_mom_id => l_rt_sas.mom_id
                                        );
            fetch c_get_mode_of_operation
            into  l_mom_id;
            if c_get_mode_of_operation%notfound
            then
              
              l_mom_id := lm_constant.g_con_mom_mom_mode_normal;
            end if;
            close c_get_mode_of_operation;
            
            
            if  l_mom_id = l_rt_sas.mom_id
            then
               
               o_nt_stations.extend;
               o_nt_stations(o_nt_stations.count) := l_rt_sas.stn_id_member_station;
            end if;
         else
            
            o_nt_stations.extend;
            o_nt_stations(o_nt_stations.count) := l_rt_sas.stn_id_member_station;
         end if;
      end if;
   end loop;

   
   o_nt_stations := set(o_nt_stations);

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_mode_of_operation%isopen
      then
         close c_get_mode_of_operation;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end determine_stations_in_group;


procedure get_fallback_station
   ( o_rt_stn out lm_stations%rowtype
   )
is

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.GET_FALLBACK_STATION';

l_found boolean;


cursor c_get_fallback_station
 is
select stn.*
from   lm_stations stn
where  stn.ind_fallback = lm_constant.g_con_yesno_yes;



























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   
   
   open c_get_fallback_station;
   fetch c_get_fallback_station into o_rt_stn;
   l_found := c_get_fallback_station%found;
   close c_get_fallback_station;

   
   if not l_found
   then
      
      viu_info.raise_info( i_ifo_nr =>               viu_constant.c_ifo_nofallbackstationfound
                         , i_calling_procedure =>    l_con_proc_name
                         , i_severity =>             viu_info.c_severity_error
                         );
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_get_fallback_station%isopen
      then
         close c_get_fallback_station;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_fallback_station;


procedure process_tat_exception
   ( i_pid           in     lm_packages.pid%type
   , i_bid           in     lm_packages.bid%type
   , i_bid_extension in     lm_packages.bid_extension%type
   , i_task_type     in     lm_task_definitions.task_instruction_type%type
   , i_error_type    in     varchar2
   , i_source        in     varchar2
   , i_origin        in     lm_task_instructions.origin%type
   , i_stn_found     in     boolean
   , o_stn_id           out lm_stations.id%type
   )
is
   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.PROCESS_TAT_EXCEPTION';
   

















































   l_rt_taskreport_result   lm_package_administration.g_rt_taskreport_result;

   l_rt_stn                 lm_stations%rowtype;
   l_it_lpc                 nt_lpc := nt_lpc();

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   
   
   
   if i_source = lm_constant.g_con_src_recirculation
   then
      null;
      
      
      

   elsif i_origin = lm_constant.g_con_origin_csci_lm
   then
      if not i_stn_found
      then
         
         
         
         lm_topology_administration.get_fallback_station( o_rt_stn => l_rt_stn );
         o_stn_id := l_rt_stn.id;

         
         viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_fallbacknewpackage
                               , i_calling_procedure      => l_con_proc_name
                               , i_severity               => viu_info.c_severity_warning
                               , i_info_arguments         => i_pid
                               , i_additional_data        => 'Stations could not be determined because of error: ' || i_error_type
                               );
      end if;
   else
      
      
      
      if i_error_type = lm_constant.g_con_mae_station_unavailable
         and
         i_source     = lm_constant.g_con_src_bagstore_relocation
      then
         
         
         null;
      else
         l_rt_taskreport_result.it_lpc := l_it_lpc; 
         l_rt_taskreport_result.error  := i_error_type;
         lm_package_administration.send_task_report( i_event_time        => lm_common.default_timestamp
                                                   , i_bid               => i_bid
                                                   , i_bid_extension     => i_bid_extension
                                                   , i_pid               => i_pid
                                                   , i_area_id_cust      => null
                                                   , i_zone_id_cust      => null
                                                   , i_stn_id_cust       => null
                                                   , i_tasktype          => i_task_type
                                                   , i_register_reason   => null
                                                   , i_deregister_reason => null
                                                   , i_rt_result         => l_rt_taskreport_result
                                                   , i_rt_bir            => null
                                                   );

         
         viu_info.operator_info( i_ifo_nr            => case i_error_type
                                                        when lm_constant.g_con_mae_route_impossible
                                                           then viu_constant.c_ifo_trtrouteimpossible
                                                        when lm_constant.g_con_mae_station_unavailable
                                                           then viu_constant.c_ifo_trtstationunavailable
                                                        end
                               , i_calling_procedure      => l_con_proc_name
                               , i_severity               => viu_info.c_severity_warning
                               , i_info_arguments         => i_pid
                               );

      end if;

      
      
      
      
      if i_stn_found
      then
         viu_info.operator_info(i_ifo_nr            => viu_constant.c_ifo_unavailablestnselected
                               ,i_calling_procedure => l_con_proc_name
                               ,i_severity          => viu_info.c_severity_warning
                               ,i_info_arguments    => i_pid
                               );
      end if;

   end if; 

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end process_tat_exception;


procedure evaluate_taskinstruction
   ( i_pid                     in     lm_packages.pid%type
   , i_tin_id                  in     lm_task_instructions.id%type
   , i_source                  in     varchar2
   , i_nt_exclude_stations     in     nt_stn_id
   , o_new_determined_stations    out boolean
   )
is







































   l_con_proc_name   constant lm_constant.st_proc_name := g_con_package||'.EVALUATE_TASKINSTRUCTION';


   
   cursor c_active_tin_by_pid
   (i_pid in lm_packages.pid%type
   )
   is
   
   select tpev.id as tin_id
   from   lm_tin_active_of_package_v tpev
   where  tpev.pid = i_pid
   and    tpev.pss_id in (lm_constant.g_con_pss_name_open, lm_constant.g_con_pss_name_suspect)
   ;
   
   
   cursor c_get_determined_station
    (i_tin_id in lm_task_instructions.id%type
    )
   is
   select dsn.stn_id stn_id
   ,      dsn.ind_final_expected
   from   lm_determined_stations dsn
   where  dsn.tin_id = i_tin_id
   and    dsn.ind_final_expected = lm_constant.g_con_yesno_no;

   
   cursor c_stn_id_cust( i_nt_stn_id in nt_stn_id)
   is
   select /*+ CARDINALITY (dsn, 1) */
          stn.id_cust
   from   lm_stations        stn
   ,      table(i_nt_stn_id) dsn
   where  dsn.column_value = stn.id;

   l_pon_found                boolean;
   l_pae_found                boolean;
   l_tin_found                boolean;
   l_tdn_found                boolean;
   l_pss_found                boolean;
   l_pin_created              boolean := false;
   l_rows_updated             number;
   l_rt_pae                   lm_packages%rowtype;
   l_rt_pon                   lm_physical_destinations%rowtype;
   l_rt_dsn                   lm_determined_stations%rowtype;
   l_rt_tin                   lm_task_instructions%rowtype;
   l_rt_tdn                   lm_task_definitions%rowtype;
   l_rt_pss                   lm_package_statuses%rowtype;
   l_it_pon_id                lm_topology_administration.g_it_dst;
   l_it_pon_id_cust           lm_common.g_it_pon_id_cust;
   l_nt_non_final_stn_old     nt_stn_id := nt_stn_id();
   l_nt_stn_id_new            nt_stn_id := nt_stn_id();
   l_nt_final_stn_id_new      nt_stn_id := nt_stn_id();
   l_pin_ims_id               lm_package_instructions.ims_id%type;
   l_rt_pin                   lm_package_instructions%rowtype;
   l_rt_haa                   lm_handling_areas%rowtype;
   l_nt_screeninginstruction  nt_screeninginstruction;
   l_rt_taskreport_result     lm_package_administration.g_rt_taskreport_result;
   l_package_instruction      lm_common.g_rt_package_instruction;

   l_nt_stn_id_cust           nt_stn_id_cust;
   l_haa_id_cust              lm_handling_areas.id_cust%type;
   l_eta                      timestamp;
   l_it_failed_dir_dummy      lm_tracking.g_it_faileddirection;
   l_tin_id_actual            lm_task_instructions.id%type;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   o_new_determined_stations  := false;

   if i_tin_id is null
   then
      
      viu_module.leave_module( i_module      => l_con_proc_name );
      return;
   end if;
      
   
   l_pae_found := lm_pae_tapi_pck.pae_select_row_upd( i_pae_pid => i_pid
                                                    , o_rt_pae  => l_rt_pae
                                                    );

   
   open c_active_tin_by_pid(i_pid => i_pid);
   fetch c_active_tin_by_pid
   into  l_tin_id_actual;

   
   
   if c_active_tin_by_pid%notfound
   then
      l_tin_id_actual := null;
   end if;
   close c_active_tin_by_pid;

   if l_tin_id_actual = i_tin_id
   then
      

      

      
      
      
      
      
      lm_topology_administration.determine_stations( i_tin_id              => i_tin_id
                                                   , i_source              => i_source
                                                   , i_ind_use_backup_task => false
                                                   , i_nt_exclude_stations => i_nt_exclude_stations
                                                   , o_nt_stn_id           => l_nt_stn_id_new
                                                   , o_nt_final_stn_id     => l_nt_final_stn_id_new
                                                   );

      
      
      if l_nt_stn_id_new.count > 0
      then
         
         for idx_old in c_get_determined_station( i_tin_id      => i_tin_id )
         loop
            l_nt_non_final_stn_old.extend;
            l_nt_non_final_stn_old( l_nt_non_final_stn_old.count )  := idx_old.stn_id;
         end loop;

         




         if l_nt_non_final_stn_old <> l_nt_stn_id_new
         then
            
            o_new_determined_stations  := true;
            
            lm_package_administration.del_determined_stations_by_tin( i_tin_id      => i_tin_id );

            
            for idx_stn in 1 .. l_nt_stn_id_new.count
            loop
               l_rt_dsn.stn_id              := l_nt_stn_id_new( idx_stn );
               l_rt_dsn.tin_id              := i_tin_id;
               l_rt_dsn.ind_final_expected  := lm_constant.g_con_yesno_no;
               lm_dsn_tapi_pck.dsn_insert_row( io_rt_dsn      => l_rt_dsn );
            end loop;
            
            for idx_stn in 1 .. l_nt_final_stn_id_new.count
            loop
               l_rt_dsn.stn_id              := l_nt_final_stn_id_new( idx_stn );
               l_rt_dsn.tin_id              := i_tin_id;
               l_rt_dsn.ind_final_expected  := lm_constant.g_con_yesno_yes;
               lm_dsn_tapi_pck.dsn_insert_row( io_rt_dsn      => l_rt_dsn );
            end loop;
            
            lm_topology_administration.determine_destinations( i_nt_stn_id      => l_nt_stn_id_new
                                                             , o_it_pon_id      => l_it_pon_id
                                                             , o_rt_haa         => l_rt_haa
                                                             );
            



            if l_it_pon_id.count > 0
            then
               
               lm_package_administration.store_package_instruction( i_pid            => l_rt_pae.pid
                                                                  , i_pty_id         => l_rt_pae.pty_id
                                                                  , i_it_pon_id      => l_it_pon_id
                                                                  , i_haa_id         => l_rt_haa.id
                                                                  , o_rt_pin         => l_rt_pin
                                                                  );
               l_pin_created  := true;
            end if;
            


            if l_pin_created
            then
               



               if l_rt_pae.pss_id = lm_constant.g_con_pss_name_suspect
               then
                  viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_packageinstructionerror
                                        , i_calling_procedure      => l_con_proc_name
                                        , i_severity               => viu_info.c_severity_notification
                                        , i_additional_data        => 'Message: PackageInstruction; PID:' || l_rt_pae.pid
                                        );
               else
                  



                  if l_rt_pae.ind_suspended_deregistration = lm_constant.g_con_yesno_yes
                  then
                     
                     viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_packageinstrwithheld
                                           , i_calling_procedure      => l_con_proc_name
                                           , i_severity               => viu_info.c_severity_notification
                                           , i_info_arguments         => l_rt_pae.pid
                                           );
                  else
                     
                     for idx_pon in l_it_pon_id.first .. l_it_pon_id.last
                     loop
                        l_pon_found                  := lm_pon_tapi_pck.pon_select_row( i_pon_id      => l_it_pon_id( idx_pon )
                                                                                      , o_rt_pon      => l_rt_pon
                                                                                      );
                        l_it_pon_id_cust( idx_pon )  := l_rt_pon.id_cust;
                     end loop;

                     l_nt_screeninginstruction := lm_package_administration.get_screeninginstruction(i_pid => l_rt_pae.pid);

                     
                     
                     
                     
                     
                     
                     
                     l_package_instruction.instruction.it_pon_id_cust          := l_it_pon_id_cust;
                     l_package_instruction.instruction.destination_haa_id_cust := l_rt_haa.id_cust;
                     l_package_instruction.instruction.priority_indicator      := l_rt_pae.priority_indicator;
                     l_package_instruction.instruction.release_group_id        := l_rt_pae.rgp_id;
                     l_package_instruction.screeninginstruction                := l_nt_screeninginstruction;
                     l_package_instruction.recovery.screeninginfo              := nt_screeninginfo();
                     lm_package_administration.send_instruction_for_package(i_pty_id     => l_rt_pae.pty_id
                                                                           ,i_event_time => lm_common.default_timestamp
                                                                           ,i_pid        => l_rt_pae.pid
                                                                           ,i_lic_id     => l_rt_pae.lic
                                                                           ,i_pi         => l_package_instruction
                                                                           ,o_ims_id     => l_pin_ims_id
                                                                           );
                                                                             
                     



                     l_rt_pin.ims_id                   := l_pin_ims_id;
                     l_rows_updated                    := lm_pin_tapi_pck.pin_update_row( i_pin_id       => l_rt_pin.id
                                                                                        , io_rt_pin      => l_rt_pin
                                                                                        );
                  end if;

                  
                  l_rt_pae.expected_time_to_arrive  := null;
                  l_rows_updated                    := lm_pae_tapi_pck.pae_update_row( i_pae_pid      => l_rt_pae.pid
                                                                                     , io_rt_pae      => l_rt_pae
                                                                                     );
                  
                  l_tin_found  := lm_tin_tapi_pck.tin_select_row(i_tin_id => i_tin_id
                                                                ,o_rt_tin => l_rt_tin);
                  l_tdn_found  := lm_tdn_tapi_pck.tdn_select_row(i_tdn_id => l_rt_tin.tdn_id
                                                                ,o_rt_tdn => l_rt_tdn);


                  
                  if  l_rt_tdn.tdn_id_backup is not null
                  then
                     
                     
                     
                     l_rt_taskreport_result.result_type := lm_constant.g_con_prt_contr_routing_result;
                     if l_rt_tin.tdn_id_temporary is not null
                     then
                        
                        l_rt_taskreport_result.controlled_routing := lm_constant.g_con_truefalse_false;
                     else
                        
                        l_rt_taskreport_result.controlled_routing := lm_constant.g_con_truefalse_true;
                     end if;
                     
                     
                     open c_stn_id_cust( i_nt_stn_id => l_nt_stn_id_new);
                     fetch c_stn_id_cust
                     bulk collect into l_rt_taskreport_result.it_stn_id_cust;
                     close c_stn_id_cust;

                     lm_package_administration.send_task_report( i_event_time        => lm_common.default_timestamp
                                                               , i_bid               => l_rt_pae.bid
                                                               , i_bid_extension     => l_rt_pae.bid_extension
                                                               , i_pid               => l_rt_pae.pid
                                                               , i_area_id_cust      => null
                                                               , i_zone_id_cust      => null
                                                               , i_stn_id_cust       => null
                                                               , i_tasktype          => l_rt_tdn.task_instruction_type
                                                               , i_register_reason   => null
                                                               , i_deregister_reason => null
                                                               , i_rt_result         => l_rt_taskreport_result
                                                               , i_rt_bir            => null
                                                               );
                  end if;

                  
                  lm_topology_administration.determine_eta_stn( i_rt_pae         => l_rt_pae
                                                              , i_rst_id         => null     
                                                              , i_event_type     => lm_constant.g_con_ete_name_reevaluation
                                                              , i_event_time     => lm_common.default_timestamp
                                                              , o_nt_stn_id_cust => l_nt_stn_id_cust
                                                              , o_haa_id_cust    => l_haa_id_cust
                                                              , o_eta            => l_eta
                                                              );

                  
                  l_pss_found := lm_pss_tapi_pck.pss_select_row( i_pss_id => l_rt_pae.pss_id
                                                               , o_rt_pss => l_rt_pss
                                                               );
                  lm_package_administration.send_baggage_event( i_event_time          => lm_common.default_timestamp
                                                              , i_pid                 => l_rt_pae.pid
                                                              , i_bid                 => l_rt_pae.bid
                                                              , i_bid_extension       => l_rt_pae.bid_extension
                                                              , i_nt_carrier          => l_rt_pae.carrier
                                                              , i_event_type          => lm_constant.g_con_mae_tracking
                                                              , i_lst_id_cust         => null
                                                              , i_area_id_cust        => null
                                                              , i_zone_id_cust        => null
                                                              , i_section_id_cust     => null
                                                              , i_region              => null
                                                              , i_region_exception    => null
                                                              , i_rst_id              => l_rt_pae.rst_id
                                                              , i_nt_stn_id_cust      => l_nt_stn_id_cust
                                                              , i_haa_id_cust         => l_haa_id_cust
                                                              , i_eta                 => l_eta
                                                              , i_pss_id_cust         => l_rt_pss.name
                                                              , i_it_failed_direction => l_it_failed_dir_dummy
                                                              );

               end if;   
            end if;      
         else
            
            
            

            
            
            
            

            
            
            
            if i_source not in ( lm_constant.g_con_src_logistic_backup
                               , lm_constant.g_con_src_bagstore_relocation
                               )
            then
               viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_nonewstationsfound
                                     , i_calling_procedure      => l_con_proc_name
                                     , i_severity               => viu_info.c_severity_warning
                                     , i_additional_data        => 'Task instruction: ' || i_tin_id
                                     );
            end if;
         end if;
      end if;   
   else
      
      
      
      
      
      viu_info.operator_info(i_ifo_nr            => viu_constant.c_ifo_discardtaskinstruction
                            ,i_calling_procedure => l_con_proc_name
                            ,i_severity          => viu_info.c_severity_notification
                            ,i_info_arguments    => i_tin_id||'##'||i_pid
                            ,i_additional_data   => 'Newer TaskInstruction is '||l_tin_id_actual
                            );
   end if; 

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_active_tin_by_pid%isopen
      then
         close c_active_tin_by_pid;
      end if;
      if c_get_determined_station%isopen
      then
         close c_get_determined_station;
      end if;
      if c_stn_id_cust%isopen
      then
         close c_stn_id_cust;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end evaluate_taskinstruction;


procedure process_stn_availability_infl
   ( i_route_influence_timestamp in timestamp
   )
is
   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.PROCESS_STN_AVAILABILITY_INFL';

   






















































   
   cursor c_say_dirty
    is
   select say.stn_id
   ,      say.ssd_id
   ,      say.ind_available_derived
   ,      say.sod_id
   ,      say.function_mode
   ,      listagg(son.id_cust,',') within group (order by son.id_cust) as scope_of_operation
   from   lm_scope_of_operation son
   ,      lm_station_availabilities say
   where  son.say_stn_id (+) = say.stn_id
   and    say.ind_dirty      = lm_constant.g_con_yesno_yes
   group by stn_id
   ,      say.ssd_id
   ,      say.ind_available_derived
   ,      say.sod_id
   ,      say.function_mode;

   l_route_infl_timestamp     lm_constant.st_timestamp; 
   l_route_infl_timestamp_fmt varchar2(240);
   l_rt_sah                   lm_stn_availabilities_history%rowtype;
   l_rt_say                   lm_station_availabilities%rowtype;
   l_upd_rec_count            pls_integer;
   l_say_found                boolean;
   l_nt_tin_processed         nt_id_coll := nt_id_coll();
   l_nt_stn_id_report         nt_stn_id  := nt_stn_id();
   l_nt_stn_id_eval           nt_stn_id  := nt_stn_id();

   pragma autonomous_transaction;
begin
   
   viu_module.enter_module( i_module      => l_con_proc_name );
   
   l_route_infl_timestamp      := nvl( i_route_influence_timestamp
                                     , lm_common.default_timestamp
                                     );
   l_route_infl_timestamp_fmt  := lm_common.timestamp_to_varchar( i_timestamp => l_route_infl_timestamp );

   
   
   for rec_say in c_say_dirty
   loop
      lm_stn_tapi_pck.stn_lock_row_nowait(i_stn_id => rec_say.stn_id);

      
      l_nt_stn_id_report.extend(1);
      l_nt_stn_id_report( l_nt_stn_id_report.count ) := rec_say.stn_id;

      
      
      l_rt_sah.id                     := null;
      l_rt_sah.stn_id                 := rec_say.stn_id;
      l_rt_sah.ssd_id                 := rec_say.ssd_id;
      l_rt_sah.sod_id                 := rec_say.sod_id;
      l_rt_sah.ind_available_derived  := rec_say.ind_available_derived;
      l_rt_sah.event_time             := l_route_infl_timestamp;
      l_rt_sah.function_mode          := rec_say.function_mode;
      l_rt_sah.scope_of_operation     := rec_say.scope_of_operation;
      
      
      if rec_say.ind_available_derived = lm_constant.g_con_yesno_yes
      then
         l_rt_sah.reason                 := lm_constant.g_con_sah_rsn_deactivatedrule;
      else
         l_rt_sah.reason                 := lm_constant.g_con_sah_rsn_activatedrule;
      end if;
      lm_sah_tapi_pck.sah_insert_row( io_rt_sah       => l_rt_sah );

      








      if rec_say.ind_available_derived = lm_constant.g_con_yesno_no
      then
         l_nt_stn_id_eval.extend(1);
         l_nt_stn_id_eval( l_nt_stn_id_eval.count ) := rec_say.stn_id;
      end if;

      
      
      
      
      l_say_found := lm_say_tapi_pck.say_select_row( i_say_stn_id => rec_say.stn_id
                                                   , o_rt_say     => l_rt_say
                                                   );
      
      l_rt_say.ind_dirty             := lm_constant.g_con_yesno_no;
      l_upd_rec_count  := lm_say_tapi_pck.say_update_row( i_say_stn_id      => rec_say.stn_id
                                                        , io_rt_say         => l_rt_say
                                                        );
   end loop;

   
   
   
   
   
   
   
   
   commit;
   
   
   
   
   
   for i in 1..l_nt_stn_id_eval.count
   loop
      
      lm_flow_administration.reevaluate_pae_destination( i_stn_id               => l_nt_stn_id_eval(i)
                                                       , i_type_of_reevaluation => lm_constant.g_con_eval_type_all
                                                       , io_nt_tin_processed    => l_nt_tin_processed
                                                       );
   end loop;

   
   if l_nt_stn_id_report is not empty
   then
      lm_availability_report.send_node_availability_report( i_nt_stn_id => l_nt_stn_id_report);
   end if;

   
   commit;
   
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   
   when exc_resource_busy
   
   
   then
      rollback;   
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      =>    'LM_STATION record(s) locked by another process'
                                                    || ' and NOWAIT specified (lock conflict) '
                             );
      
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_lockfailed
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_warning
                         , i_info_arguments         => lm_stn_tapi_pck.g_con_table_name
                         , i_additional_data        =>    'LM_STATION record(s) locked by another process'
                                                       || ' and NOWAIT specified (lock conflict) '
                         );
   
   
   when others
   then
      rollback;   
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );

end process_stn_availability_infl;


procedure get_nde_upstream_rst
   ( i_area_id_cust          in     lm_areas_v.id_cust%type
   , i_zone_id_cust          in     lm_zones_v.id_cust%type
   , i_identifier_within_sct in     lm_nodes.identifier_within_sct%type
   , o_it_rst                   out lm_topology_administration.g_it_rst
   )
is

l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.GET_NDE_UPSTREAM_RST';


cursor c_aze_nde_rst
 (i_area_id_cust in lm_areas_v.id_cust%type
 ,i_zone_id_cust in lm_zones_v.id_cust%type
 ,i_identifier_within_sct in lm_nodes.identifier_within_sct%type
 )
 is
select rst.id     rst_id
from   lm_areas_v ara
,      lm_zones_v zne
,      lm_nodes nde
,      lm_route_segments rst
where  ara.area_id               = zne.area_id
and    ara.id_cust               = i_area_id_cust
and    zne.zone_id               = nde.sct_id
and    zne.id_cust               = i_zone_id_cust
and    nde.identifier_within_sct = i_identifier_within_sct
and    rst.nde_id_end_node       = nde.id;




























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   open c_aze_nde_rst( i_area_id_cust          => i_area_id_cust
                     , i_zone_id_cust          => i_zone_id_cust
                     , i_identifier_within_sct => i_identifier_within_sct
                     );

   
   fetch c_aze_nde_rst bulk collect
   into  o_it_rst;

   close c_aze_nde_rst;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_aze_nde_rst%isopen
      then
         close c_aze_nde_rst;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_nde_upstream_rst;


procedure get_nde_downstream_rst
 (i_area_id_cust          in     lm_areas_v.id_cust%type
 ,i_zone_id_cust          in     lm_zones_v.id_cust%type
 ,i_identifier_within_sct in     lm_nodes.identifier_within_sct%type
 ,o_it_rst                   out lm_topology_administration.g_it_rst
 )
is
   l_con_proc_name constant lm_constant.st_proc_name := g_con_package||'.get_nde_downstream_rst';

   
   cursor c_aze_nde_rst
   ( i_area_id_cust          in lm_areas_v.id_cust%type
   , i_zone_id_cust          in lm_zones_v.id_cust%type
   , i_identifier_within_sct in lm_nodes.identifier_within_sct%type
   )
   is
   select rst.id     rst_id
   from   lm_areas_v ara
   ,      lm_zones_v zne
   ,      lm_nodes nde
   ,      lm_route_segments rst
   where  ara.area_id               = zne.area_id
   and    ara.id_cust               = i_area_id_cust
   and    zne.zone_id               = nde.sct_id
   and    zne.id_cust               = i_zone_id_cust
   and    nde.identifier_within_sct = i_identifier_within_sct
   and    rst.nde_id_start_node     = nde.id;

   






























begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   open c_aze_nde_rst( i_area_id_cust          => i_area_id_cust
                     , i_zone_id_cust          => i_zone_id_cust
                     , i_identifier_within_sct => i_identifier_within_sct
                     );

   
   fetch c_aze_nde_rst bulk collect
   into  o_it_rst;

   close c_aze_nde_rst;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_aze_nde_rst%isopen
      then
         close c_aze_nde_rst;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_nde_downstream_rst;


procedure process_has_availability_infl
   (i_route_influence_timestamp in timestamp
   )



















































is
   l_con_proc_name       constant lm_constant.st_proc_name := g_con_package
                                                           || '.PROCESS_HAS_AVAILABILITY_INFL';

   l_route_infl_timestamp         lm_constant.st_timestamp;
   l_route_infl_timestamp_fmt     varchar2(240);
   l_rt_hay                       lm_haa_access_availabilities%rowtype;
   l_rt_hss                       lm_haa_access_statuses%rowtype;
   l_hss_id_active                lm_haa_access_statuses.id%type;
   l_upd_rec_count                pls_integer;

   
   cursor c_hay_dirty
   is
   select has.id has_id
   ,      hay.ind_available
   from   lm_handling_area_accesses    has
   ,      lm_haa_access_availabilities hay
   where  hay.has_id    = has.id
   and    hay.ind_dirty = lm_constant.g_con_yesno_yes
   for update of has.id nowait;

   
   cursor c_hss_active( i_has_id lm_haa_access_statuses.has_id%type)
   is
   select hsav.hss_id
   from   lm_hss_active_v hsav
   where  hsav.has_id = i_has_id
   ;

   pragma autonomous_transaction;
begin
   
   
   
   viu_module.enter_module( i_module      => l_con_proc_name );
   
   l_route_infl_timestamp      := nvl( i_route_influence_timestamp
                                     , lm_common.default_timestamp
                                     );
   l_route_infl_timestamp_fmt  := lm_common.timestamp_to_varchar( i_timestamp      => l_route_infl_timestamp );
   
   <<hay_loop>>
   
   
   for rec_hay in c_hay_dirty
   loop
      
      open c_hss_active( i_has_id => rec_hay.has_id);
      fetch c_hss_active
      into  l_hss_id_active;

      if c_hss_active%found
      then
         
         if lm_hss_tapi_pck.hss_select_row( i_hss_id => l_hss_id_active
                                          , o_rt_hss => l_rt_hss
                                          )
         then
            l_rt_hss.time_deactivated := l_route_infl_timestamp;
            l_upd_rec_count := lm_hss_tapi_pck.hss_update_row( i_hss_id  => l_rt_hss.id
                                                             , io_rt_hss => l_rt_hss
                                                             );
         end if;
      end if;
      close c_hss_active;

      
      l_rt_hss := null; 
      l_rt_hss.has_id           := rec_hay.has_id;
      l_rt_hss.time_activated   := l_route_infl_timestamp;
      l_rt_hss.time_deactivated := null;
      case rec_hay.ind_available
         when lm_constant.g_con_yesno_no
         then l_rt_hss.hsm_id := lm_constant.g_con_hsm_blocked;
         when lm_constant.g_con_yesno_yes
         then l_rt_hss.hsm_id := lm_constant.g_con_hsm_operational;
         else
            null;
      end case;

      lm_hss_tapi_pck.hss_insert_row( io_rt_hss => l_rt_hss);

      
      
      
      
      if lm_hay_tapi_pck.hay_select_row( i_hay_has_id => rec_hay.has_id
                                       , o_rt_hay     => l_rt_hay
                                       )
      then
         
         l_rt_hay.ind_dirty := lm_constant.g_con_yesno_no;
         l_upd_rec_count    := lm_hay_tapi_pck.hay_update_row( i_hay_has_id => rec_hay.has_id
                                                             , io_rt_hay    => l_rt_hay
                                                             );
      end if;
   end loop;

   
   commit;
   
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   
   when exc_resource_busy
   
   
   then
      rollback;   
      if c_hss_active%isopen
      then
         close c_hss_active;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      =>    'LM_HANDLING_AREA_ACCESS record(s) locked by another process'
                                                    || ' and NOWAIT specified (lock conflict) '
                             );
      
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_lockfailed
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_warning
                         , i_info_arguments         => lm_has_tapi_pck.g_con_table_name
                         , i_additional_data        =>    'LM_HANDLING_AREA_ACCESS record(s) locked by another process'
                                                       || ' and NOWAIT specified (lock conflict) '
                         );
   
   
   when others
   then
      rollback;   
      if c_hss_active%isopen
      then
         close c_hss_active;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );

end process_has_availability_infl;


function get_nde_from_pon
   ( i_pon_id in lm_physical_destinations.id%type
   )
return nt_nde_id
























is
   l_con_proc_name        constant lm_constant.st_proc_name := g_con_package||'.GET_NDE_FROM_PON';

   l_rt_pon                        lm_physical_destinations%rowtype;
   l_nt_nde_id                     nt_nde_id := nt_nde_id();

   
   cursor c_nde_pon_physical( i_pon_id in lm_physical_destinations.id%type)
   is
   select nde.id
   from   lm_nodes nde
   where  nde.pon_id = i_pon_id
   order by nde.id 
   ;

   
   cursor c_nde_pon_virtual( i_pon_id in lm_physical_destinations.id%type)
   is
   select lnk.nde_id
   from   lm_links                  lnk
   ,      lm_handling_areas         haa
   ,      lm_handling_area_accesses has
   ,      lm_handling_area_stations han
   ,      lm_stations               stn
   ,      lm_station_reachabilities sry
   where  lnk.haa_id_upstream = haa.id
   and    haa.ind_current     = lm_constant.g_con_yesno_yes
   and    has.lnk_id          = lnk.id
   and    has.haa_id          = han.haa_id
   and    han.stn_id          = stn.id
   and    sry.stn_id          = stn.id
   and    sry.mom_id          = lm_constant.g_con_mom_mom_mode_normal
   and    sry.pon_id          = i_pon_id
   order by lnk.nde_id 
   ;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   if lm_pon_tapi_pck.pon_select_row( i_pon_id => i_pon_id
                                    , o_rt_pon => l_rt_pon
                                    )
   then
      if l_rt_pon.sct_id is not null
      then
         
         
         open c_nde_pon_physical( i_pon_id => i_pon_id);
         fetch c_nde_pon_physical
         bulk collect
         into  l_nt_nde_id;

         close c_nde_pon_physical;
      else
         
         
         
         
         
         open c_nde_pon_virtual( i_pon_id => i_pon_id);
         fetch c_nde_pon_virtual
         bulk collect
         into  l_nt_nde_id;

         close c_nde_pon_virtual;
      end if;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );

   return l_nt_nde_id;

exception
   when others
   then
      if c_nde_pon_physical%isopen
      then
         close c_nde_pon_physical;
      end if;
      if c_nde_pon_virtual%isopen
      then
         close c_nde_pon_virtual;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end get_nde_from_pon;


procedure determine_eta_stn
   ( i_rt_pae         in     lm_packages%rowtype
   , i_rst_id         in     lm_route_segments.id%type
   , i_event_type     in     lm_event_types.id%type
   , i_event_time     in     lm_package_events.event_time%type
   , o_nt_stn_id_cust    out nt_stn_id_cust
   , o_haa_id_cust       out lm_handling_areas.id_cust%type
   , o_eta               out lm_package_events.event_time%type
   )











































is
   l_con_proc_name        constant lm_constant.st_proc_name := g_con_package||'.DETERMINE_ETA_STN';

   cursor c_current_tin( i_pid in lm_packages.pid%type)
   is
   



   select tdn.ind_calculate_eta
   from   lm_task_definitions        tdn
   ,      lm_tin_active_of_package_v tin
   where  tin.pid    = i_pid
   and    tin.tdn_id = tdn.id
   ;

   cursor c_pae_destinations( i_pid in lm_packages.pid%type)
   is
   
   
   select pdn.pon_id pon_id
   from   lm_package_destinations  pdn
   
   ,      lm_pin_active_of_package_v  piev
   where  pdn.pin_id = piev.id
   and    piev.pid = i_pid
   order by pdn.pon_id 
   ;

   
   cursor c_stn_list( i_nt_stn_id_cust in nt_stn_id_cust)
   is
   select listagg(column_value, '; ') within group (order by column_value)
   from   table(i_nt_stn_id_cust)
   ;

   l_rt_rst                        lm_route_segments%rowtype;
   l_found                         boolean;
   l_ind_calculate_eta             lm_task_definitions.ind_calculate_eta%type;
   l_reference_time                timestamp;
   l_travel_time                   lm_constant.st_travel_time;
   l_pin_id_dummy                  lm_package_instructions.id%type;
   l_stn_list                      varchar2(2000);
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   if i_rst_id is not null
   then
      
      
      
      
      
      
      l_found := lm_rst_tapi_pck.rst_select_row( i_rst_id => i_rst_id
                                               , o_rt_rst => l_rt_rst
                                               );
   else
      
      l_found := lm_rst_tapi_pck.rst_select_row( i_rst_id => i_rt_pae.rst_id
                                               , o_rt_rst => l_rt_rst
                                               );
   end if;

   
   
   
   translate_pdn_to_stn( i_pid            => i_rt_pae.pid
                       , o_nt_stn_id_cust => o_nt_stn_id_cust
                       , o_haa_id_cust    => o_haa_id_cust
                       );

   if i_event_type not in ( lm_constant.g_con_ete_name_deregistration
                          , lm_constant.g_con_ete_name_ghostbag
                          )
   then
      
      
      open c_current_tin( i_pid => i_rt_pae.pid);
      fetch c_current_tin
      into  l_ind_calculate_eta;
      close c_current_tin;
      
      if l_ind_calculate_eta = lm_constant.g_con_yesno_no
      then
         l_travel_time := null;
      else
         if i_event_type = lm_constant.g_con_ete_name_package_report
         then
            
            
            for l_rt_pae_destinations in c_pae_destinations( i_pid => i_rt_pae.pid)
            loop
               if l_rt_rst.nde_id_start_node
                  member lm_topology_administration.get_nde_from_pon
                                                    ( i_pon_id => l_rt_pae_destinations.pon_id)
               then
                  
                  l_reference_time := i_event_time;
                  l_travel_time    := 0;
                  exit; 
               end if;
            end loop;
         end if; 
         if l_travel_time is null
         then
            

            
            
            lm_in_time_delivery.determine_travel_time( i_pid                      => i_rt_pae.pid
                                                     , i_current_rst_id           => l_rt_rst.id
                                                     , i_average_travel_time      => l_rt_rst.average_travel_time
                                                     , i_report_end_route_segment => l_rt_rst.report_end_node
                                                     , i_start_node_curr_rst      => l_rt_rst.nde_id_start_node
                                                     , i_end_node_curr_rst        => l_rt_rst.nde_id_end_node
                                                     , o_pin_id                   => l_pin_id_dummy
                                                     , o_travel_time              => l_travel_time
                                                     );
            if l_travel_time is null
            then
               
               open c_stn_list( i_nt_stn_id_cust => o_nt_stn_id_cust);
               fetch c_stn_list into l_stn_list;
               close c_stn_list;
               viu_info.operator_info( i_ifo_nr            => viu_constant.c_ifo_notraveltimedetermined
                                     , i_calling_procedure => l_con_proc_name
                                     , i_severity          => viu_info.c_severity_warning
                                     , i_info_arguments    => i_rt_pae.pid || '##' || i_rt_pae.rst_id
                                     , i_additional_data   => 'Assigned stations: ' || l_stn_list
                                     );
            end if;
         end if;

         
         
         o_eta := lm_common.round_timestamp_sec
                  ( nvl(l_reference_time, lm_common.default_timestamp)   
                  + numtodsinterval( l_travel_time, lm_constant.g_con_cmn_numtodsintervalsecon)
                  );
      end if; 

   end if; 

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_current_tin%isopen
      then
         close c_current_tin;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end determine_eta_stn;


procedure translate_pdn_to_stn
   ( i_pid            in     lm_packages.pid%type
   , o_nt_stn_id_cust    out nt_stn_id_cust
   , o_haa_id_cust       out lm_handling_areas.id_cust%type
   )



























is
   l_con_proc_name        constant lm_constant.st_proc_name := g_con_package||'.TRANSLATE_PDN_TO_STN';

   cursor c_last_instruction( i_pid in lm_packages.pid%type)
   is
   
   select piev.id
   ,      piev.haa_id
   from   
          lm_pin_active_of_package_v  piev
   where  piev.pid = i_pid
   ;

   cursor c_pae_destinations( i_pin_id in lm_package_instructions.id%type)
   is
   
   
   select pdn.pon_id pon_id
   from   lm_package_destinations  pdn
   where  pdn.pin_id = i_pin_id
   order by pdn.pon_id 
   ;

   cursor c_stn (i_stn_id in nt_stn_id)
   is
   
   select stn.id_cust
   from   lm_stations stn
         ,table(i_stn_id) tab
   where  tab.column_value = stn.id;

   l_nt_stn_id_cust                nt_stn_id_cust := nt_stn_id_cust();
   l_nt_stn_id                     nt_stn_id      := nt_stn_id();
   l_nt_pon_id                     nt_pon_id      := nt_pon_id();

   l_rec_pin                       c_last_instruction%rowtype;
   l_rt_haa                        lm_handling_areas%rowtype;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   open c_last_instruction( i_pid => i_pid);
   fetch c_last_instruction
   into  l_rec_pin;
   if c_last_instruction%found
   then
      if l_rec_pin.haa_id is not null
      then
         
         if lm_haa_tapi_pck.haa_select_row( i_haa_id => l_rec_pin.haa_id
                                          , o_rt_haa => l_rt_haa
                                          )
         then
            o_haa_id_cust := l_rt_haa.id_cust;
            o_nt_stn_id_cust := nt_stn_id_cust(); 
         end if;
      else
         
         for rec_pae_destinations in c_pae_destinations( i_pin_id => l_rec_pin.id)
         loop
            l_nt_pon_id.extend;
            l_nt_pon_id( l_nt_pon_id.count) := rec_pae_destinations.pon_id;
         end loop;
         
         lm_topology_administration.translate_pon_to_stn(i_nt_pon_id =>  l_nt_pon_id
                                                        ,o_nt_stn_id =>  l_nt_stn_id);
         
         open c_stn(l_nt_stn_id);
         fetch c_stn
           bulk collect into l_nt_stn_id_cust;
         close c_stn;

         o_nt_stn_id_cust := l_nt_stn_id_cust;

      end if; 
   end if;
   close c_last_instruction;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_last_instruction%isopen
      then
         close c_last_instruction;
      end if;
      if c_stn%isopen
      then
         close c_stn;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end translate_pdn_to_stn;


procedure translate_pon_to_stn
   ( i_nt_pon_id  in     nt_pon_id
   , o_nt_stn_id     out nt_stn_id
   )
is
   l_con_proc_name        constant lm_constant.st_proc_name := g_con_package||'.TRANSLATE_PON_TO_STN';

   



























   l_nt_stn_id  nt_stn_id;
   l_stn_id     lm_stations.id%type;
   l_pon_id     lm_physical_destinations.id%type;
   l_rt_lne     lm_ebs_lanes%rowtype;

   cursor c_dest_to_stn( i_pon_id lm_physical_destinations.id%type)
   is
   
   
   select sry.stn_id
   from   lm_station_reachabilities sry
   where  sry.pon_id = i_pon_id
   and    sry.mom_id = lm_constant.g_con_mom_mom_mode_normal
   ;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   l_nt_stn_id  := nt_stn_id();
   if i_nt_pon_id.count > 0
   then
       for idx_i in i_nt_pon_id.first .. i_nt_pon_id.last
       loop
          l_pon_id := i_nt_pon_id(idx_i);
          open c_dest_to_stn( i_pon_id => l_pon_id);
          fetch c_dest_to_stn
          into  l_stn_id;

          if c_dest_to_stn%found
          then
             l_nt_stn_id.extend;
             if lm_lne_tapi_pck.lne_select_row( i_lne_stn_id => l_stn_id
                                              , o_rt_lne     => l_rt_lne
                                              )
             then
                
                l_nt_stn_id(l_nt_stn_id.count) := l_rt_lne.stn_id_part_of;
             else
                
                l_nt_stn_id( l_nt_stn_id.count) := l_stn_id;
             end if;
          else
             
              viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_nostationspdfound
                                    , i_calling_procedure      => l_con_proc_name
                                    , i_severity               => viu_info.c_severity_warning
                                    , i_additional_data        => 'Physical Destination = "' || l_pon_id || '"'
                                    );
          end if;
          close c_dest_to_stn;
       end loop;
   end if;
   o_nt_stn_id := l_nt_stn_id;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
     if c_dest_to_stn%isopen
      then
         close c_dest_to_stn;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end translate_pon_to_stn;


procedure count_bags_in_segment_group
   ( i_nt_brn_id           in      nt_id_coll
   , o_nt_brp_id               out nt_id_coll
   , o_nt_counted_packages     out nt_counted_packages
   , o_nt_pon_id               out nt_pon_id
   )





























is
   
   cursor c_brn
   (i_brn_id in lm_brp_compositions.id%type
   )
   is
   select brn.pon_id
   ,      brn.haa_id
   ,      haa_dest.id                      dest_haa_id
   ,      haa_dest.id_cust                 dest_haa_id_cust
   ,      han.stn_id                       dest_haa_stn_id
   from   lm_brp_compositions       brn
   ,      lm_handling_area_accesses has
   ,      lm_handling_area_stations han
   ,      lm_handling_areas         haa_dest
   where  brn.id     = i_brn_id
   and    brn.has_id = has.id (+)
   and    has.haa_id = haa_dest.id (+)
   and    has.id     = han.has_id (+);

   


   cursor c_brp(i_nt_brn_id in nt_id_coll)
   is
   select /*+ CARDINALITY (tab 4) */  rt_carrier(brn.brp_id
   ,      brn.type_of_count)
   from   table(i_nt_brn_id) tab
   ,      lm_brp_compositions brn
   where  brn.id = tab.column_value
   order by brn.id;
   
   cursor c_stn_by_haa
     (i_haa_id lm_handling_areas.id%type
     ,i_stn_id lm_stations.id%type
     )
   is
   
   select han.stn_id
   from   lm_handling_area_stations han
   where  han.haa_id = i_haa_id
   and    ( han.stn_id = i_stn_id
           or i_stn_id is null
          )
   order by han.stn_id;

   
   
   
   
   
   cursor c_pae(i_nt_brp_id nt_carrier)
   is
   select  /*+ CARDINALITY (brp 4) */
           brp.id brp_id
   ,       count(pae.pid) cnt
   from    lm_segment_group_members sgm
   ,       lm_route_segments rst
   ,       lm_packages pae
   ,       table(i_nt_brp_id) brp
   where   pae.pss_id(+) = lm_constant.g_con_pss_name_open
   and     pae.rst_id(+) = rst.id
   and     sgm.brp_id(+) = brp.id
   and     sgm.lst_id    = rst.lst_id(+)
   group by brp.id
   order by brp.id;

   
   
   
   
   
   cursor c_pae_pon(i_nt_brp_id         nt_carrier
                   ,i_nt_pon_id         nt_pon_id
                   )
   is
   select brp_id
   ,      nvl(round(sum(weight)), 0) weighted_count
   from  (select brp_id
                 ,(select count(*)
                   from   table(t_intersect))/count_pon as weight
          from   (select /*+ INDEX(pdn2 LM_PDN_UK1) */ ilv.pid
                  ,     ilv.brp_id
                        
                        
                  ,     (cast (i_nt_pon_id as nt_id_coll)
                            multiset intersect all
                         cast(collect( pdn2.pon_id) as nt_id_coll)
                         ) t_intersect
                  ,      count(*) count_pon
                         
                         
                         
                         
                         
                         
                         
                  from  (select /*+ ORDERED CARDINALITY (rst 10) CARDINALITY (pon 4) INDEX(pdn LM_PDN_UK1) */
                                distinct pae.pid
                         ,      piev.id pin_id, brp.id as brp_id
                         from   table(i_nt_pon_id)         pon
                         ,      lm_pin_active_of_package_v piev
                         ,      lm_packages                pae
                         ,      lm_package_destinations    pdn
                                
                         ,      lm_route_segments          rst
                         ,      lm_segment_group_members   sgm
                         ,      table(i_nt_brp_id)         brp
                         where  piev.pid   (+) = pae.pid
                         and    pdn.pin_id (+) = piev.id
                         and    pae.pss_id (+) = lm_constant.g_con_pss_name_open
                         and    pdn.pon_id     = pon.column_value (+)
                         and    rst.id         = pae.rst_id (+)
                         and    rst.lst_id (+) = sgm.lst_id
                         and    sgm.brp_id (+) = brp.id
                         and    (   
                                    
                                    pae.rgp_id is null
                                 or
                                    brp.type <> lm_constant.g_con_brp_type_release_groups
                                )
                        ) ilv
                  ,     lm_package_destinations pdn2
                  where pdn2.pin_id (+) = ilv.pin_id
                  group by ilv.pid, ilv.brp_id
                 )
         )
   group by brp_id;
   
   l_con_proc_name           constant lm_constant.st_proc_name := g_con_package||'.COUNT_BAGS_IN_SEGMENT_GROUP';
   l_nt_pon_id_filter        nt_pon_id  := nt_pon_id();
   l_nt_stn_id               nt_stn_id  := nt_stn_id();
   l_it_pon_id               lm_topology_administration.g_it_dst;
   l_rt_haa                  lm_handling_areas%rowtype;

   l_nt_counted_packages     nt_counted_packages := nt_counted_packages();
   l_rt_brn                  c_brn%rowtype;
   l_nt_brp_id               nt_carrier := nt_carrier(rt_carrier()); 


begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   
   
   open c_brn(i_brn_id => i_nt_brn_id(1));
   fetch c_brn
   into l_rt_brn;
   close c_brn;
   
   
   open c_brp(i_nt_brn_id => i_nt_brn_id);
   fetch c_brp
   bulk collect
   into  l_nt_brp_id;
   close c_brp;
   
   
   if l_rt_brn.pon_id is not null
   then
      
      l_nt_pon_id_filter.extend;
      l_nt_pon_id_filter(l_nt_pon_id_filter.count) := l_rt_brn.pon_id;
   else
      
      
      
      
      
      open c_stn_by_haa( i_haa_id => nvl(l_rt_brn.haa_id, l_rt_brn.dest_haa_id)
                        , i_stn_id => l_rt_brn.dest_haa_stn_id);
      fetch c_stn_by_haa bulk collect
      into  l_nt_stn_id;
      close c_stn_by_haa;
      if  l_nt_stn_id.count > 0
      then
         
         lm_topology_administration.determine_destinations(i_nt_stn_id => l_nt_stn_id
                                                          ,i_ind_for_package_instruction => false
                                                          ,o_it_pon_id => l_it_pon_id
                                                          ,o_rt_haa    => l_rt_haa);

         for idx in l_it_pon_id.first .. l_it_pon_id.last
         loop
            l_nt_pon_id_filter.extend;
            l_nt_pon_id_filter(l_nt_pon_id_filter.count) := l_it_pon_id(idx);
         end loop;
      end if;
   end if;
      
      
   
   if l_nt_pon_id_filter.count > 0
   then
      open c_pae_pon( i_nt_brp_id        => l_nt_brp_id
                    , i_nt_pon_id        => l_nt_pon_id_filter
                    );
      fetch c_pae_pon
      bulk collect
      into o_nt_brp_id
         , l_nt_counted_packages;
      close c_pae_pon;
   else
      open c_pae(i_nt_brp_id     => l_nt_brp_id);
      fetch c_pae
      bulk collect
      into  o_nt_brp_id
           ,l_nt_counted_packages;
      close c_pae;
   end if;
   o_nt_counted_packages := l_nt_counted_packages;
   o_nt_pon_id           := l_nt_pon_id_filter;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_pae%isopen
      then
        close c_pae;
      end if;
      if c_pae_pon%isopen
      then
        close c_pae_pon;
      end if;
      if c_brp%isopen
      then
        close c_brp;
      end if;
      if c_brn%isopen
      then
        close c_brn;
      end if;
      if c_stn_by_haa%isopen
      then
        close c_stn_by_haa;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end count_bags_in_segment_group;


procedure determine_stations_ebs
   ( i_tin_id                  in     lm_task_instructions.id%type
   , i_source                  in     varchar2
   , i_pae_rst_id              in     lm_packages.rst_id%type
   , i_task_type               in     lm_task_definitions.task_instruction_type%type
   , i_pcm_name                in     lm_physical_class_dom.name%type
   , i_time_limit              in     timestamp
   , i_sep_id                  in     lm_segregation_groups.id%type
   , i_pid                     in     lm_packages.pid%type
   , i_bid                     in     lm_packages.bid%type
   , i_bid_extension           in     lm_packages.bid_extension%type
   , i_origin                  in     lm_task_instructions.origin%type
   , io_nt_determined_stations in out nt_stn_id
   )




















is

   

   cursor c_ebs_stations(i_nt_determined_stations in nt_stn_id)
   is
   select /*+ CARDINALITY (stn, 4) */
        stn.column_value stn_id
   from  table( i_nt_determined_stations ) stn
   where exists (select '1'
                 from   lm_ebs_lanes lne
                 where  lne.stn_id_part_of = stn.column_value
                );

   



   cursor c_ebs_lane_by_rst( i_nt_stn_id_lbs in nt_stn_id
                           , i_rst_id        in lm_route_segments.id%type
                           )
   is
   select /*+ CARDINALITY (stn, 2) */ lne.stn_id
   from   table(i_nt_stn_id_lbs)             stn
   ,      lm_ebs_lanes                       lne
   ,      lm_lan_active_v                    lan
   ,      lm_technical_segments              tst
   ,      lm_route_segments                  rst
   where  lne.stn_id_part_of = stn.column_value
   and    lan.lne_stn_id     = lne.stn_id
   and    lne.tst_id         = tst.id
   and    rst.lst_id         = tst.lst_id
   and    rst.id             = i_rst_id;

   



   cursor c_candidate_ebs_lanes(i_nt_ebs_stations in nt_stn_id
                               ,i_tin_id in lm_task_instructions.id%type
                               )
   is
   select /*+ CARDINALITY (stn, 2) */
          lne.stn_id lne_stn_id
   from   lm_ebs_lanes lne
        , lm_station_availabilities say
        , table( i_nt_ebs_stations ) stn
   where  say.stn_id = lne.stn_id
   and    say.ssd_id in (lm_constant.g_con_ssd_id_available
                        ,lm_constant.g_con_ssd_id_initial
                        )
   and    say.ind_available_derived = lm_constant.g_con_yesno_yes
   and    not exists (select '1'
                      from   lm_evaluated_stations esn
                      where  esn.stn_id = lne.stn_id
                      and    esn.tin_id = i_tin_id
                      and    esn.time_recirculation_obsolete is not null
                      )
   and    lne.stn_id_part_of = stn.column_value;
   
   l_con_proc_name          constant lm_constant.st_proc_name := g_con_package||'.determine_stations_EBS';
   l_nt_ebs_stations        nt_stn_id := nt_stn_id();
   l_nt_reachable_lanes     nt_stn_id := nt_stn_id();
   l_lne_stn_id             lm_ebs_lanes.stn_id%type;
   l_pae_lne_stn_id         lm_ebs_lanes.stn_id%type;
   l_additional_data        viu_info_logs.additional_data%type;
   l_rt_lbs_bag             rt_lbs_bag;
   l_continue               boolean := true;
   l_fallback_stn_id        lm_stations.id%type;

begin
   viu_module.enter_module( i_module      => l_con_proc_name );
 
   if io_nt_determined_stations is empty
   then
      
      l_continue := false;
   else
      
      open c_ebs_stations(i_nt_determined_stations => io_nt_determined_stations);
      fetch c_ebs_stations
      bulk collect
      into l_nt_ebs_stations;
      close c_ebs_stations;

      if l_nt_ebs_stations is empty
      then
         
         
         l_continue := false;
      elsif l_nt_ebs_stations.count != io_nt_determined_stations.count
      then
         
         
         l_continue := false;

         select listagg(column_value, '; ')
         within group  (order by column_value)
         into   l_additional_data
         from   table(io_nt_determined_stations);
         viu_info.operator_info( i_ifo_nr            => viu_constant.c_ifo_regularlmstationsfound
                               , i_calling_procedure => l_con_proc_name
                               , i_severity          => viu_info.c_severity_warning
                               , i_info_arguments    => i_tin_id
                               , i_additional_data   => 'List of determined stations = ' ||l_additional_data
                               );

         
         io_nt_determined_stations := io_nt_determined_stations multiset except l_nt_ebs_stations;
      end if;
   end if;
   
   if l_continue
   then
      

      
      
      
      
      io_nt_determined_stations.delete;
      
      
      
      
      
      
      
      
      
      if i_source is null
         or
         i_source <> lm_constant.g_con_src_lbs_admin
      then
         
         
         
         
         open c_ebs_lane_by_rst( i_nt_stn_id_lbs => l_nt_ebs_stations
                               , i_rst_id        => i_pae_rst_id
                               );
         fetch c_ebs_lane_by_rst
         into  l_pae_lne_stn_id;
         close c_ebs_lane_by_rst;

      end if;
      
      if l_pae_lne_stn_id is not null
      then
         
         
         
         l_lne_stn_id := l_pae_lne_stn_id;
      else
         
         
         
         
         open c_candidate_ebs_lanes(i_nt_ebs_stations => l_nt_ebs_stations
                                   ,i_tin_id          => i_tin_id
                                   );
         fetch c_candidate_ebs_lanes
         bulk collect
         into l_nt_reachable_lanes;
         close c_candidate_ebs_lanes;
            
         l_rt_lbs_bag                := rt_lbs_bag();
         l_rt_lbs_bag.task_type      := i_task_type;
         l_rt_lbs_bag.physical_class := i_pcm_name;
         l_rt_lbs_bag.time_limit     := i_time_limit;
         l_rt_lbs_bag.segregation    := i_sep_id;
               
         
         lm_lbs_administration.determine_lane(i_rt_lbs_bag         => l_rt_lbs_bag
                                             ,i_nt_reachable_lanes => l_nt_reachable_lanes
                                             ,o_stn_id             => l_lne_stn_id
                                             );
      end if;
      
      if l_lne_stn_id is not null
      then
         
         
         io_nt_determined_stations.extend(1);
         io_nt_determined_stations(1) := l_lne_stn_id;
      else
         
         
         lm_topology_administration.process_tat_exception( i_pid           => i_pid
                                                         , i_bid           => i_bid
                                                         , i_bid_extension => i_bid_extension
                                                         , i_task_type     => i_task_type
                                                         , i_error_type    => lm_constant.g_con_mae_station_unavailable
                                                         , i_source        => i_source
                                                         , i_origin        => i_origin
                                                         , i_stn_found     => false
                                                         , o_stn_id        => l_fallback_stn_id
                                                         );
         if l_fallback_stn_id is not null
         then
            
            io_nt_determined_stations.extend(1);
            io_nt_determined_stations(1) := l_fallback_stn_id;
         end if;
      end if;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      if c_ebs_stations%isopen
      then
         close c_ebs_stations;
      end if;
      if c_candidate_ebs_lanes%isopen
      then
         close c_candidate_ebs_lanes;
      end if;
      if c_ebs_lane_by_rst%isopen
      then
         close c_ebs_lane_by_rst;
      end if;

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end determine_stations_ebs;


end lm_topology_administration;
/