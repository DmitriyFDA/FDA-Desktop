create or replace PACKAGE LM_INTERFACE IS

   g_con_package              CONSTANT lm_constant.st_proc_name := 'LM_INTERFACE';

   TYPE g_rt_ima IS RECORD
      ( attribute lm_constant.st_rt_attribute
      , value     lm_constant.st_rt_value
      );

   TYPE g_it_ima IS TABLE OF lm_interface.g_rt_ima INDEX BY BINARY_INTEGER;


   g_cm_url                            lm_parameter_values.value%TYPE;
   g_it_message_content                lm_interface.g_it_ima;

   /* Exception raised when used URL is unknown or unsupported. */
   exc_unknown_url                     EXCEPTION;
   PRAGMA EXCEPTION_INIT(exc_unknown_url, -29264);

   /* Exception raised when CSCI_CM is not available. */
   exc_cm_not_available                EXCEPTION;
   PRAGMA EXCEPTION_INIT(exc_cm_not_available, -12541);

   exc_xml_parse_error                 EXCEPTION;
   PRAGMA EXCEPTION_INIT(exc_xml_parse_error, -31011);

   /* IFC_001: This is the main entry for the processing of a message. */
   PROCEDURE process_message( i_message IN CLOB);

   /* IFC_002: This is the main entry for the processing of a message. */
   FUNCTION process_message( i_message IN CLOB)
   RETURN CLOB;

   /* IFC_006: This will log the message in the IFC MESSAGE entity. */
   PROCEDURE log_message
             ( i_message IN     XMLTYPE
             , i_imd_id  IN     lm_ifc_msg_definitions.id%TYPE
             , o_ims_id     OUT lm_ifc_messages.id%TYPE
             );

   /* IFC_013: Extract a node from an incoming message */
   PROCEDURE extract_node
             ( i_dom_node  IN DBMS_XMLDOM.domnode
             , i_root_name IN VARCHAR2
             , i_xpath     IN VARCHAR2 := NULL
             );

   /* IFC_007: This function parses the incoming message */
   PROCEDURE parse_message
             ( i_rt_imd   IN lm_ifc_msg_definitions%ROWTYPE
             , i_dom_node IN DBMS_XMLDOM.domnode
             , i_ims_id   IN lm_ifc_messages.id%TYPE
             );
             
   /* IFC_008: Execute the appropriate message handler. */
   PROCEDURE execute_message_hdl(i_processingname IN lm_ifc_msg_definitions.processingname%TYPE);

   /* IFC_008: Execute the appropriate message handler. */
   FUNCTION execute_message_hdl
             ( i_processingname    IN     lm_ifc_msg_definitions.processingname%TYPE
             , i_message           IN     XMLTYPE
             )
   RETURN XMLTYPE;

   /* IFC_028: Send the message as a CLOB to CSCI_LM. */
   PROCEDURE send_clob( i_clob IN CLOB);

   /* IFC_029: Set the URL for sending the message to CSCI_LM. */
   PROCEDURE set_url( i_url IN lm_parameter_values.value%TYPE);

   /* IFC_009: This is the main entrance for sending messages. */
   FUNCTION prepare_and_send_message
            ( i_imd_name              IN lm_ifc_msg_definitions.name%TYPE
            , i_message               IN XMLTYPE
            , i_event_time            IN TIMESTAMP
            , i_pty_id_cust           IN lm_parties.id_cust%TYPE
            , i_pty_instance_id       IN lm_parties.instance_id%TYPE
            , i_sct_id                IN lm_system_components.id%TYPE
            , i_operator_id           IN VARCHAR2 := NULL
            , i_handle_errors_locally IN BOOLEAN := TRUE
            )
    RETURN lm_ifc_messages.id%TYPE;

   /* IFC_009: This is the main entrance for sending messages. */
   FUNCTION prepare_and_send_message
            ( i_imd_name              IN lm_ifc_msg_definitions.name%TYPE
            , i_message               IN XMLTYPE
            , i_event_time            IN TIMESTAMP
            , i_pty_id_cust           IN lm_parties.id_cust%TYPE
            , i_pty_instance_id       IN lm_parties.instance_id%TYPE
            , i_sct_id_cust           IN lm_system_components.id_cust%TYPE
            , i_operator_id           IN VARCHAR2 := NULL
            , i_handle_errors_locally IN BOOLEAN := TRUE
            )
    RETURN lm_ifc_messages.id%TYPE;
    
   /* IFC_012: Send the message to CSCI_CM */
   FUNCTION send_message
            ( i_message               IN XMLTYPE
            , i_imd_id                IN lm_ifc_msg_definitions.id%TYPE
            , i_handle_errors_locally IN BOOLEAN := TRUE
            )
   RETURN lm_ifc_messages.id%TYPE;

   /* IFC_040: This will log the message in the IFC MESSAGE entity. */
   PROCEDURE log_message_autonomous
             ( i_message IN     XMLTYPE
             , i_imd_id  IN     lm_ifc_msg_definitions.id%TYPE
             , io_ims_id IN OUT lm_ifc_messages.id%TYPE
             );

   /* IFC_014: Verifies that given eventtime is not too far in the future */
   PROCEDURE check_event_time
             (i_ims_id         IN lm_ifc_messages.id%TYPE
             ,i_reference_time IN TIMESTAMP
             );

END LM_INTERFACE;
/




package body lm_interface is

   












   







   g_attr_index              binary_integer;
   g_persistent_conn_enabled boolean := false;


procedure process_message_internal( i_message           in      clob
                                  , i_ind_resultmessage in      boolean
                                  , o_resultmessage         out xmltype
                                  )
is
   
























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.process_message_internal';

   l_rt_imd                            lm_ifc_msg_definitions%rowtype;
   l_begin_time                        timestamp;
   l_end_time                          timestamp;
   l_elapsed_time                      interval day to second;
   l_ims_id                            lm_ifc_messages.id%type;
   l_clob_message                      clob;
   l_xml_message                       xmltype;
   l_dom_doc                           dbms_xmldom.domdocument;
   l_dom_node                          dbms_xmldom.domnode;
   l_root_node                         dbms_xmldom.domnode;
   l_node_name                         lm_ifc_msg_definitions.name%type;
begin
   viu_module.enter_module( i_module => l_con_proc_name );

   
   
   
   if not i_ind_resultmessage
   then
      if not acl_application_control.determ_app_operational_status( lm_constant.get_aet_name_csci_lm )
      then
         
         viu_module.leave_module( i_module      => l_con_proc_name );
         return;
      end if;
   end if;

   
   l_begin_time       := lm_common.default_timestamp;

   l_clob_message     := i_message;
   begin
      
      l_xml_message  := xmltype( i_message );
   exception
      
      when lm_interface.exc_xml_parse_error
      then
         viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_xmlparseerror
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_warning
                            , i_additional_data        => substr(l_clob_message, 1 , 4000)
                            );
   end;

   
   l_dom_doc          := dbms_xmldom.newdomdocument( xmldoc      => l_xml_message );
   l_dom_node         := dbms_xmldom.makenode( doc      => l_dom_doc );
   l_root_node        := dbms_xmldom.getfirstchild( n      => l_dom_node );

   
   l_node_name        := dbms_xmldom.getnodename( n      => l_root_node );

   
   if not lm_imd_tapi_pck.imd_select_row_uk1( i_imd_name           => l_node_name
                                            , i_imd_direction      => lm_constant.g_con_direction_in
                                            , o_rt_imd             => l_rt_imd
                                            )
   then
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_nomessagedefinition
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => l_node_name
                         , i_additional_data        => substr(l_clob_message, 1 , 4000)
                         );
   end if;

   
   begin
      
      
      log_message( i_message      => l_xml_message
                 , i_imd_id       => nvl( l_rt_imd.id, 0)
                 , o_ims_id       => l_ims_id
                 );
   exception
      when others
      then
         viu_info.handle_info;
   end;

   if l_rt_imd.processingname is null
   then
      
      
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_nomessagehandler
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => l_rt_imd.name
                         , i_additional_data        => substr(l_clob_message, 1 , 4000)
                         );
   end if;

   
   
   parse_message( i_rt_imd            => l_rt_imd
                , i_dom_node          => l_root_node
                , i_ims_id            => l_ims_id
                );

   
   check_event_time( i_ims_id              => l_ims_id
                   , i_reference_time      => l_begin_time
                   );

   
   if not i_ind_resultmessage
   then
      
      
      execute_message_hdl( i_processingname => l_rt_imd.processingname);
   else
      
      
      o_resultmessage := execute_message_hdl( i_processingname => l_rt_imd.processingname
                                            , i_message        => l_xml_message
                                            );
   end if;
   
   
   commit;

   
   dbms_xmldom.freedocument( doc      => l_dom_doc );

   
   if lm_common.get_parameter_value( i_prr_name      => lm_constant.g_con_pve_log_msgproctime ) = lm_constant.g_con_yesno_yes
   then
      l_end_time      := lm_common.default_timestamp;
      l_elapsed_time  := l_end_time - l_begin_time;
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_messageprocessingtime
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_autonomous             => false
                            , i_info_arguments         => l_node_name || '##' || to_char( extract( second from l_elapsed_time )
                                                                                        + 60 * extract( minute from l_elapsed_time )
                                                                                        , 'FM99990.000'
                                                                                        )
                            , i_additional_data        => 'Message ID: ' || l_ims_id
                            );
      
      
      
      
      commit write batch nowait;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      
      rollback;

      
      dbms_xmldom.freedocument( doc      => l_dom_doc );

      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );

      
      viu_info.handle_info;

      
      
      
      
      begin
         
         
         lm_interface.log_message_autonomous( i_message  => nvl( l_xml_message
                                                               , xmltype('<NoXML>'||dbms_xmlgen.convert(l_clob_message, dbms_xmlgen.entity_encode)||'</NoXML>')
                                                               )
                                            , i_imd_id   => nvl( l_rt_imd.id, 0)
                                            , io_ims_id  => l_ims_id
                                            );
      exception
         when others
         then
            viu_info.handle_info;
      end;
end process_message_internal;


procedure process_message( i_message in clob)
is
   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.process_message';

   



















   l_result_msg_dummy                  xmltype;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   process_message_internal( i_message           => i_message
                           , i_ind_resultmessage => false
                           , o_resultmessage     => l_result_msg_dummy
                           );

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      
      
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );

      viu_info.handle_info;
end process_message;

procedure log_result_message( i_message in xmltype )
is
   l_con_proc_name   constant cmn_constant.st_proc_name := g_con_package || '.log_result_message';

   



















   l_rt_imd                   lm_ifc_msg_definitions%rowtype;
   l_ims_id                   lm_ifc_messages.id%type;

begin
   viu_module.enter_module( i_module => l_con_proc_name );
   
   
   if not lm_imd_tapi_pck.imd_select_row_uk1( i_imd_name           => i_message.getrootelement()
                                            , i_imd_direction      => lm_constant.g_con_direction_out
                                            , o_rt_imd             => l_rt_imd
                                            )
   then
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_nomessagedefinition
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => i_message.getrootelement()
                         );
   end if;

   lm_interface.log_message_autonomous( i_message  => i_message
                                      , i_imd_id   => l_rt_imd.id
                                      , io_ims_id  => l_ims_id
                                      );
   
   viu_module.leave_module( i_module => l_con_proc_name );

exception
   when others
   then

      viu_module.leave_module( i_module     => l_con_proc_name
                             , i_debug_info => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure => l_con_proc_name );
end log_result_message;


function process_message( i_message in clob)
return clob
is
   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.process_message';

   



















   l_result_msg                        xmltype;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   process_message_internal( i_message           => i_message
                           , i_ind_resultmessage => true
                           , o_resultmessage     => l_result_msg
                           );

   log_result_message(i_message => l_result_msg);
   
   viu_module.leave_module( i_module      => l_con_proc_name );
   return l_result_msg.getclobval();
exception
   when others
   then
      
      
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );

      viu_info.handle_info;
      
      
      if l_result_msg is null
      then
         return null;
      else
         return l_result_msg.getclobval();
      end if;

end process_message;


procedure log_message
          ( i_message in     xmltype
          , i_imd_id  in     lm_ifc_msg_definitions.id%type
          , o_ims_id     out lm_ifc_messages.id%type
          )
is





























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.log_message';

   l_rt_ims                            lm_ifc_messages%rowtype;
begin
   viu_module.enter_module( i_module => l_con_proc_name );

   l_rt_ims.imd_id       := i_imd_id;
   l_rt_ims.message      := i_message;
   l_rt_ims.date_created := lm_common.default_timestamp;

   lm_ims_tapi_pck.ims_insert_row( io_rt_ims => l_rt_ims );

   o_ims_id          := l_rt_ims.id;

   viu_module.leave_module( i_module => l_con_proc_name );
exception

   when others
   then
      viu_module.leave_module( i_module     => l_con_proc_name
                             , i_debug_info => sqlerrm
                             );
      viu_info.raise_info( i_ifo_nr => viu_constant.c_ifo_messagelogerror );
end log_message;


procedure extract_node
          ( i_dom_node  in dbms_xmldom.domnode
          , i_root_name in varchar2
          , i_xpath     in varchar2 := null
          )
is



























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package||'.extract_node';

   l_node_name                         lm_constant.st_rt_attribute;
   l_child_node                        dbms_xmldom.domnode;
   l_child_nodes                       dbms_xmldom.domnodelist;
   l_node_length                       integer;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   


   l_node_name    := dbms_xmldom.getnodename( n      => i_dom_node );
   l_child_node   := dbms_xmldom.getfirstchild( n      => i_dom_node );

   








   l_child_nodes  := dbms_xmldom.getchildnodes( n => i_dom_node );
   l_node_length  := dbms_xmldom.getlength( nl => l_child_nodes );
   if (l_node_length = 1
       and
       dbms_xmldom.getnodetype( l_child_node ) = dbms_xmldom.text_node
      ) 
      or
      l_node_length = 0
        
   then
      g_attr_index                                                := g_attr_index + 1;
      lm_interface.g_it_message_content( g_attr_index ).attribute := i_xpath||l_node_name;
      lm_interface.g_it_message_content( g_attr_index ).value     := dbms_xmldom.getnodevalue( n => l_child_node );
   else
      
      for i in 1 .. l_node_length
      loop
         l_child_node := dbms_xmldom.item( nl       => l_child_nodes
                                         , idx      => i - 1
                                         );
         lm_interface.extract_node( i_dom_node  => l_child_node
                                  , i_root_name => i_root_name
                                  , i_xpath     => case
                                                   
                                                   when l_node_name != i_root_name
                                                   then
                                                      i_xpath||l_node_name||'/'
                                                   end
                                  );
      end loop;
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end extract_node;


procedure parse_message
          ( i_rt_imd   in lm_ifc_msg_definitions%rowtype
          , i_dom_node in dbms_xmldom.domnode
          , i_ims_id   in lm_ifc_messages.id%type
          )
is


























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.parse_message';

   l_it_message_content_empty          lm_interface.g_it_ima;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   lm_interface.g_it_message_content               := l_it_message_content_empty;
   g_attr_index                                    := 0;
   


   extract_node( i_dom_node  => i_dom_node
               , i_root_name => i_rt_imd.name
               );

   
   g_attr_index                                    := g_attr_index + 1;
   g_it_message_content( g_attr_index ).attribute  := lm_constant.g_con_ifc_ims_id_attribute;
   g_it_message_content( g_attr_index ).value      := i_ims_id;

   viu_module.leave_module( i_module          => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end parse_message;


procedure execute_message_hdl(i_processingname in lm_ifc_msg_definitions.processingname%type)
is
























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.execute_message_hdl';

begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   execute immediate 'BEGIN ' || i_processingname || '; END;';

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end execute_message_hdl;


function execute_message_hdl
          ( i_processingname    in     lm_ifc_msg_definitions.processingname%type
          , i_message           in     xmltype
          )
return xmltype
is


























   l_con_proc_name            constant lm_constant.st_proc_name := g_con_package || '.execute_message_hdl';

   l_result_message                    xmltype;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   execute immediate 'BEGIN :1 := ' || i_processingname || '(:2); END;'
   using out l_result_message
   ,     in  i_message
   ;

   viu_module.leave_module( i_module      => l_con_proc_name );
   
   return l_result_message;
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end execute_message_hdl;


procedure send_clob( i_clob in clob)
is



























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.send_clob';

   l_req                    cmn_http.req;
   l_resp                   cmn_http.resp;
   l_buffer                 varchar2(32767);
   l_pos                    integer := 1;
   l_rem_size               binary_integer := 32000;
   l_clob_length            binary_integer := dbms_lob.getlength( lob_loc => i_clob );
   l_amount                 binary_integer := 32767;
   l_url                    lm_parameter_values.value%type;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );
   l_url   := g_cm_url;
   
   if not g_persistent_conn_enabled
   then
      
      cmn_http.set_response_error_check( enable      => true );
      cmn_http.set_detailed_excp_support( enable      => true );

      
      cmn_http.set_transfer_timeout (timeout =>
         lm_common.get_parameter_value( i_prr_name => lm_constant.g_con_pve_http_timeout));

      cmn_http.close_persistent_conns;
      cmn_http.set_persistent_conn_support(true, 1);   
      g_persistent_conn_enabled := true;
   end if;
      
   
   begin
      l_req   := cmn_http.begin_request( url               => l_url
                                       , method            => lm_constant.g_con_ifc_http_post_method
                                       , http_version      => utl_http.http_version_1_1
                                       );
      
      cmn_http.set_header( r          => l_req
                         , name       => lm_constant.g_con_ifc_http_name_type
                         , value      => lm_constant.g_con_ifc_http_header_value
                         );
      cmn_http.set_header( r          => l_req
                         , name       => lm_constant.g_con_ifc_http_name_length
                         , value      => l_clob_length
                         );

      if l_clob_length <= l_amount
      then
         
         dbms_lob.read( lob_loc      => i_clob
                      , amount       => l_clob_length
                      , offset       => l_pos
                      , buffer       => l_buffer
                      );
         cmn_http.write_text( r         => l_req
                            , data      => l_buffer
                            );
      else
         
         while l_pos <= l_clob_length
         loop
            dbms_lob.read( lob_loc      => i_clob
                         , amount       => l_rem_size
                         , offset       => l_pos
                         , buffer       => l_buffer
                         );
            cmn_http.write_text( r         => l_req
                               , data      => l_buffer
                               );
            l_pos  := l_pos + l_rem_size;
         end loop;
      end if;
   exception
      when others
      then
         
         
         
         begin
            cmn_http.end_request(r => l_req);
         exception
         when others
         then
            
            
            null;
         end;
         raise;
   end;
   
   begin
      
      l_resp := cmn_http.get_response( r => l_req );
      
      cmn_http.end_response( r => l_resp );
   exception
      when others
      then
         
         
         
         begin
            cmn_http.end_response( r => l_resp );
         exception
            when others
            then
               null;
         end;
         raise;
   end;

   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when lm_interface.exc_cm_not_available
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_cmnotavailable
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => l_url
                         , i_additional_data        => 'CM server not found'
                         );
   when utl_http.transfer_timeout
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );

      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_cmnotavailable
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => l_url
                         , i_additional_data        => 'Transfer timeout'
                         );
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_cmnotavailable
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => l_url
                         , i_additional_data        => sqlerrm
                         );
end send_clob;


procedure set_url( i_url in lm_parameter_values.value%type)
is

























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.set_url';
begin
   viu_module.enter_module( i_module      => l_con_proc_name );
   g_cm_url  := i_url;
   viu_module.leave_module( i_module      => l_con_proc_name );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end set_url;
 

function prepare_and_send_message
         ( i_imd_name              in lm_ifc_msg_definitions.name%type
         , i_message               in xmltype
         , i_event_time            in timestamp
         , i_pty_id_cust           in lm_parties.id_cust%type
         , i_pty_instance_id       in lm_parties.instance_id%type
         , i_sct_id                in lm_system_components.id%type
         , i_operator_id           in varchar2 := null
         , i_handle_errors_locally in boolean := true
         )
return lm_ifc_messages.id%type
is
































   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.prepare_and_send_message';

   cursor c_pty(i_sct_id in lm_system_components.id%type)
   is
   select pty.id_cust
         ,pty.instance_id
   from   lm_parties pty
         ,lm_lifesign_parties lpy
         ,lm_system_component_statuses  scs
   where  scs.lpy_id = lpy.id
   and    lpy.pty_id = pty.id
   and    scs.sct_id = i_sct_id;
    
   r_pty                    c_pty%rowtype;
   l_ims_id                 lm_ifc_messages.id%type;
   l_rt_imd                 lm_ifc_msg_definitions%rowtype;
   l_message                xmltype;
   l_message_header         xmltype;
   l_header_name            lm_ifc_msg_definitions.name%type;
   l_pty_found              boolean;
   
begin
   viu_module.enter_module( i_module      => l_con_proc_name );

   
   if not lm_imd_tapi_pck.imd_select_row_uk1( i_imd_name           => i_imd_name
                                            , i_imd_direction      => lm_constant.g_con_direction_out
                                            , o_rt_imd             => l_rt_imd
                                            )
   then
      viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_nomessagedefinition
                         , i_calling_procedure      => l_con_proc_name
                         , i_severity               => viu_info.c_severity_error
                         , i_info_arguments         => i_imd_name
                         );
   end if;

   
   if (    l_rt_imd.header_type  in ( lm_constant.g_con_msg_hdr_no_hdr_no_evt
                                    , lm_constant.g_con_msg_hdr_evt_no_hdr
                                    )
       and (   i_pty_id_cust     is not null
            or i_pty_instance_id is not null
            or i_sct_id          is not null
           )
      )
      or
      (    l_rt_imd.header_type not in ( lm_constant.g_con_msg_hdr_no_hdr_no_evt
                                       , lm_constant.g_con_msg_hdr_evt_no_hdr
                                       )
       and i_pty_id_cust is null
       and i_sct_id      is null
      )
   then
      viu_info.raise_info( i_ifo_nr            => viu_constant.c_ifo_invalidmsgtargetident
                         , i_calling_procedure => l_con_proc_name
                         , i_severity          => viu_info.c_severity_error
                         , i_info_arguments    => i_imd_name
                         , i_additional_data   => 'sct_id: '||i_sct_id||', pty_id_cust: '||i_pty_id_cust||', pty_instance_id: '||i_pty_instance_id
                         );
   end if;

   if   l_rt_imd.header_type is null
     or l_rt_imd.header_type not in ( lm_constant.g_con_msg_hdr_no_hdr_no_evt
                                    , lm_constant.g_con_msg_hdr_evt_no_hdr
                                    )
   then
      
      if i_sct_id is not null
      then
         



         open c_pty(i_sct_id => i_sct_id);
         fetch c_pty
         into r_pty;
         l_pty_found := c_pty%found;
         close c_pty;
       
         if not l_pty_found
         then
            
            viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_areahasnotreportedyet
                               , i_calling_procedure      => l_con_proc_name
                               , i_severity               => viu_info.c_severity_error
                               , i_info_arguments         => i_sct_id
                               );
         end if;
      else
         r_pty.id_cust     := i_pty_id_cust;
         r_pty.instance_id := i_pty_instance_id;
      end if;

      
      l_header_name := 'Header';
      if l_rt_imd.header_type = lm_constant.g_con_msg_hdr_mhdr_evt
      then
         l_header_name := 'MessageHeader';
      end if;
      select xmlelement( evalname (l_header_name)
                        , xmlelement( "MessageTime", lm_common.timestamp_to_varchar( lm_common.default_timestamp)
                                    )
                        , xmlelement( "Source"
                                    , xmlelement( "ProcessID", lm_common.get_parameter_value( lm_constant.g_con_pve_lm_source_process_id ))
                                    )
                        , xmlelement( "Target"
                                    , xmlelement( "ProcessID",  r_pty.id_cust)
                                    , nvl2( i_pty_instance_id
                                            , xmlelement( "InstanceID", r_pty.instance_id)
                                            , null
                                            )
                                    )
                        , nvl2( i_operator_id
                              , xmlelement( "OperatorID", substr(i_operator_id, 1, 30))
                              , null
                              )
                        )
      into   l_message_header
      from   dual
      ;
   end if;
   
   select xmlroot
    ( xmlelement
      ( evalname(i_imd_name)
       ,case
          when l_rt_imd.header_type = lm_constant.g_con_msg_hdr_no_hdr_no_evt
            then i_message
          when l_rt_imd.header_type = lm_constant.g_con_msg_hdr_evt_no_hdr
            then xmlconcat( xmlelement( "EventTime", lm_common.timestamp_to_varchar(i_event_time))
                           ,i_message
                          )
          when l_rt_imd.header_type = lm_constant.g_con_msg_hdr_hdr_no_evt
            then xmlconcat( l_message_header
                           ,i_message
                          )
          when l_rt_imd.header_type = lm_constant.g_con_msg_hdr_evt_hdr
            then xmlconcat( xmlelement( "EventTime", lm_common.timestamp_to_varchar(i_event_time))
                           ,l_message_header
                           ,i_message
                          )
          when    l_rt_imd.header_type = lm_constant.g_con_msg_hdr_hdr_evt
               or l_rt_imd.header_type = lm_constant.g_con_msg_hdr_mhdr_evt
            then xmlconcat( l_message_header
                           ,xmlelement( "EventTime", lm_common.timestamp_to_varchar(i_event_time))
                           ,i_message
                          )
        end
      )
    , version lm_constant.g_con_msg_xmlroot
    )
   into   l_message
   from   dual;
  
   
   l_ims_id := send_message( i_message               => l_message
                           , i_imd_id                => l_rt_imd.id
                           , i_handle_errors_locally => i_handle_errors_locally
                           );
   viu_module.leave_module( i_module      => l_con_proc_name );
   
   return l_ims_id;
exception
   when others
   then
      if c_pty%isopen
      then
        close c_pty;
      end if;
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      if i_handle_errors_locally
      then
         viu_info.handle_info;
         
         return null;
      else
         viu_info.raise_info( i_calling_procedure => l_con_proc_name );
      end if;
end prepare_and_send_message;


function prepare_and_send_message
         ( i_imd_name              in lm_ifc_msg_definitions.name%type
         , i_message               in xmltype
         , i_event_time            in timestamp
         , i_pty_id_cust           in lm_parties.id_cust%type
         , i_pty_instance_id       in lm_parties.instance_id%type
         , i_sct_id_cust           in lm_system_components.id_cust%type
         , i_operator_id           in varchar2 := null
         , i_handle_errors_locally in boolean := true
         )
return lm_ifc_messages.id%type
is






   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.prepare_and_send_message';

   l_sct_found      boolean;
   l_rt_sct         lm_system_components%rowtype;
   
begin
   viu_module.enter_module( i_module      => l_con_proc_name );
  
   if i_sct_id_cust is not null
   then
      
      l_sct_found := lm_sct_tapi_pck.sct_select_row_uk1( i_sct_sct_type            => lm_constant.g_con_sct_type_ara
                                                       , i_sct_id_cust             => i_sct_id_cust
                                                       , i_sct_sct_id_section_zone => null
                                                       , i_sct_sct_id_zone_area    => null
                                                       , o_rt_sct                  => l_rt_sct
                                                       );
   end if;
                                                            
   viu_module.leave_module( i_module      => l_con_proc_name );
   return lm_interface.prepare_and_send_message
                 ( i_imd_name              => i_imd_name
                 , i_message               => i_message
                 , i_event_time            => i_event_time
                 , i_pty_id_cust           => i_pty_id_cust
                 , i_pty_instance_id       => i_pty_instance_id
                 , i_sct_id                => l_rt_sct.id
                 , i_operator_id           => i_operator_id
                 , i_handle_errors_locally => i_handle_errors_locally
                );
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      if i_handle_errors_locally
      then
         viu_info.handle_info;
         
         return null;
      else
         viu_info.raise_info( i_calling_procedure => l_con_proc_name );
      end if;
end prepare_and_send_message;


function send_message
         ( i_message               in xmltype
         , i_imd_id                in lm_ifc_msg_definitions.id%type
         , i_handle_errors_locally in boolean := true
         )
return lm_ifc_messages.id%type
is

























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.send_message';

   l_clob_message           clob := i_message.getclobval( );
   l_message_name           lm_ifc_msg_definitions.name%type;
   l_begin_time             lm_constant.st_timestamp;
   l_end_time               lm_constant.st_timestamp;
   l_elapsed_time           interval day to second;
   l_cm_url                 lm_parameter_values.value%type;
   l_ims_id                 lm_ifc_messages.id%type;
begin
   viu_module.enter_module( i_module      => l_con_proc_name );
  
   
   l_cm_url      := lm_common.get_parameter_value( lm_constant.g_con_pve_cm_url );
   set_url( i_url      => l_cm_url );

   
   l_begin_time  := lm_common.default_timestamp;

   begin
      send_clob( i_clob => convert( l_clob_message, 'AL32UTF8'));
   exception
      when others
      then
        if i_handle_errors_locally
        then
           
           
           
           
           viu_info.handle_info;
        else
           raise;
        end if;
   end;

   
   l_end_time      := lm_common.default_timestamp;
   l_elapsed_time  := l_end_time - l_begin_time;

   
   begin
      


      lm_interface.log_message( i_message      => i_message
                              , i_imd_id       => nvl( i_imd_id, 0)
                              , o_ims_id       => l_ims_id
                              );
   exception
      when others
      then
         viu_info.handle_info;
   end;

   
   if lm_common.get_parameter_value( i_prr_name      => lm_constant.g_con_pve_log_msgproctime ) = lm_constant.g_con_yesno_yes
   then
      l_message_name  := i_message.getrootelement( );
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_cmconfirmationtime
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => l_message_name || '##'
                                                          || to_char( extract( second from l_elapsed_time )
                                                                    , 'FM99990.000'
                                                                    )
                            , i_additional_data        => 'Message ID: ' || l_ims_id
                            );
   end if;

   viu_module.leave_module( i_module      => l_con_proc_name );
   
   return l_ims_id;
exception
   when others
   then
      viu_module.leave_module( i_module          => l_con_proc_name
                             , i_debug_info      => sqlerrm
                             );
      viu_info.raise_info( i_calling_procedure      => l_con_proc_name );
end send_message;


procedure log_message_autonomous
          ( i_message in     xmltype
          , i_imd_id  in     lm_ifc_msg_definitions.id%type
          , io_ims_id in out lm_ifc_messages.id%type
          )
is





























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.log_message_autonomous';

   l_rt_ims                 lm_ifc_messages%rowtype;
pragma autonomous_transaction;
begin
   viu_module.enter_module( i_module => l_con_proc_name );

   l_rt_ims.imd_id       := i_imd_id;
   l_rt_ims.message      := i_message;
   l_rt_ims.date_created := lm_common.default_timestamp;
   l_rt_ims.id           := io_ims_id;

   lm_ims_tapi_pck.ims_insert_row( io_rt_ims => l_rt_ims );

   io_ims_id := l_rt_ims.id;

   
   commit;

   viu_module.leave_module( i_module => l_con_proc_name );
exception

   when others
   then
      
      rollback;

      viu_module.leave_module( i_module     => l_con_proc_name
                             , i_debug_info => sqlerrm
                             );

      viu_info.raise_info( i_ifo_nr => viu_constant.c_ifo_messagelogerror );
end log_message_autonomous;


procedure check_event_time
          (i_ims_id         in lm_ifc_messages.id%type
          ,i_reference_time in timestamp
          )
is


























   l_con_proc_name constant lm_constant.st_proc_name := g_con_package || '.check_event_time';

   l_interval               lm_parameter_values.value%type;
   l_time_difference        interval day(9) to second(5);
   l_index                  binary_integer;
   l_eventtime_found        boolean := false;
begin
   viu_module.enter_module( i_module => l_con_proc_name );

   
   l_index := g_it_message_content.first;
   
   
   
   while ( not l_eventtime_found )
   and   ( l_index is not null )
   loop
      
      if g_it_message_content(l_index).attribute = lm_constant.g_con_msg_event_time
      then
      	 
         l_eventtime_found := true;
        
         
         
         l_time_difference := lm_common.varchar_to_timestamp(i_timestamp => g_it_message_content(l_index).value) - i_reference_time;
         

         
         l_interval := lm_common.get_parameter_value( i_prr_name => lm_constant.g_con_pve_max_msg_time_diff );
         
         
         if  l_time_difference > lm_common.varchar_to_interval( i_int => l_interval)
         then
            viu_info.raise_info( i_ifo_nr                 => viu_constant.c_ifo_futuremessage
                               , i_calling_procedure      => l_con_proc_name
                               , i_severity               => viu_info.c_severity_warning
                               , i_info_arguments         => i_ims_id                  ||
                                                             '##' || l_time_difference ||
                                                             '##' || l_interval
                               , i_additional_data        => 'EventTime in message: ' ||
                                                             g_it_message_content(l_index).value
                               );
         end if;
      else
      	 
         l_index := g_it_message_content.next(l_index);
      end if;
   end loop;

   viu_module.leave_module( i_module => l_con_proc_name );
exception
   when viu_constant.exc_futuremessage
   then
      viu_module.leave_module( i_module     => l_con_proc_name
                             , i_debug_info => sqlerrm
                             );

      viu_info.handle_info;
   when others
   then
      viu_module.leave_module( i_module     => l_con_proc_name
                             , i_debug_info => sqlerrm
                             );

      viu_info.raise_info( i_calling_procedure => l_con_proc_name );
end check_event_time;

end lm_interface;
/