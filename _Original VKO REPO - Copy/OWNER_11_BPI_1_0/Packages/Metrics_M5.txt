create or replace PACKAGE Metrics_M5 IS
G_CON_PACKAGE CONSTANT VARCHAR2(30) := 'Metrics_M5';

PROCEDURE registers_agg_m5;
PROCEDURE deregisters_agg_m5;
PROCEDURE idchanges_agg_m5;
PROCEDURE handoverreports_agg_m5;
PROCEDURE scanresults_agg_m5;
PROCEDURE screen_analysis_agg_m5;
PROCEDURE applogging_agg_m5;
PROCEDURE bagsummaries_agg_m5;
PROCEDURE trackingreports_agg_m5;
PROCEDURE extmetrics_agg_m5;
PROCEDURE traveltimes_agg_m5;
PROCEDURE mcscanresults_agg_m5;
PROCEDURE screen_reports_agg_m5;
PROCEDURE ldrtrackreports_agg_m5;
PROCEDURE flighttrend_agg_m5;
PROCEDURE bsmtraffic_agg_m5;
PROCEDURE bpmtraffic_agg_m5;

END Metrics_M5;
/




package body metrics_m5 is

procedure registers_agg_m5
is
   l_con_proc         constant varchar2(61) := g_con_package||'.REGISTERS_AGG_M5';
   
   type err_t is table of err$_fact_registers_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_max_id           fact_registers_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_max_rows         metric_config.max_measurements%type;
   l_from_dt          wc_registerpackage.eventts%type;
   l_until_dt         wc_registerpackage.eventts%type;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   l_count            number := 0;
   l_msg              viu_info_logs.additional_data%type;
   

   begin
   bpi_trace.enter_module( i_module => l_con_proc );

  begin
    begin
      select * into l_mcg from metric_config where upper(metric_procedure) = upper(l_con_proc);
    exception
      when others then l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc, viu_info.c_severity_warning, null
                            , l_con_proc||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).'
                            );
    else

      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc, l_con_proc||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time   := sys_extract_utc(systimestamp);
         
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                          );
      
      l_max_rows := l_mcg.max_measurements;
           
      select nvl(max(id), 0) into l_max_id from fact_registers_agg_m5;
      select max(eventts) into l_from_dt from fact_registers_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_registerpackage;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
      delete from err$_fact_registers_agg_m5;
      while l_max_rows > 0  and l_from_dt < l_until_dt
      loop
         merge into fact_registers_agg_m5 rc5
         using ( select *
                 from ( select max(wc.key)                                                            as id
                        ,      period.to_stamp(wc.eventts, 'M5')                                      as eventts 
                        ,      period.periodid(wc.eventts, 'M5')                                      as m5_periodid 
                        ,      period.periodid(wc.eventts, 'H1')                                      as h1_periodid 
                        ,      dim.nodeid
                        ,      substr(trim(wc.areaid),1,5)                                            as areaid
                        ,      substr(trim(wc.zoneid),1,3)                                            as zoneid
                        ,      substr(nvl(trim(wc.equipmentid), '-'),1,3)                             as equipmentid
                        ,      dim.station_id
                        ,      dimisc.customer_id                                                     as end_user_id
                        ,      dim.mark_code
                        ,      dim.subjecttype
                        ,      dim.subsystem_type
                        ,      dim.process_step
                        ,      dim.logistic_step_description
                        ,      dim.stype
                        ,      count(wc.key)                                                          as number_of_registerpackages
                        ,      sum( case dim.ind_initial_registration when 'TRUE' then 1 else 0 end ) as at_initial_reg
                        ,      sum( case dim.ind_initial_registration when 'TRUE' then 0 else 1 end ) as unexpected
                        from wc_registerpackage wc
                           , dim_node_area_zone_equipment dim
                           , dim_iscs dimisc
                        where wc.key > l_max_id
                        and   wc.areaid = dim.areaid(+) and wc.zoneid = dim.zoneid(+) and wc.equipmentid = dim.equipmentid(+)
                        and   wc.areaid = dimisc.areaid(+) and wc.zoneid = dimisc.zoneid(+) and wc.equipmentid = dimisc.equipmentid(+)
                        and   eventts >= l_from_dt
                        and   eventts < l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(wc.eventts, 'M5')
                               , period.periodid(wc.eventts, 'M5')
                               , period.periodid(wc.eventts, 'H1')
                               , dim.nodeid, substr(trim(wc.areaid),1,5)
                               , substr(trim(wc.zoneid),1,3)
                               , substr(nvl(trim(wc.equipmentid), '-'),1,3)
                               , dim.station_id
                               , dimisc.customer_id
                               , dim.mark_code
                               , dim.subjecttype
                               , dim.subsystem_type
                               , dim.process_step
                               , dim.logistic_step_description
                               , dim.stype
                        order by id
                        )
                        where rownum <= l_max_rows
               )mtc
           on (     rc5.m5_periodid = mtc.m5_periodid
               and  rc5.areaid      = mtc.areaid
               and  rc5.zoneid      = mtc.zoneid
               and  rc5.equipmentid = mtc.equipmentid
              )
           when matched then
           update
           set id                         = mtc.id
           ,   updatets                   = sys_extract_utc(systimestamp)
           ,   number_of_registerpackages = rc5.number_of_registerpackages + mtc.number_of_registerpackages
           ,   at_initial_reg             = rc5.at_initial_reg + mtc.at_initial_reg
           ,   unexpected                 = rc5.unexpected + mtc.unexpected
         where rc5.id < mtc.id
           
           when not matched then
           insert( id
                 , insertts
                 , updatets
                 , eventts
                 , m5_periodid
                 , h1_periodid
                 , nodeid
                 , areaid
                 , zoneid
                 , equipmentid
                 , station_id
                 , end_user_id
                 , mark_code
                 , subjecttype
                 , subsystem_type
                 , process_step
                 , logistic_step_description
                 , stype
                 , number_of_registerpackages
                 , at_initial_reg
                 , unexpected
                 )
           values( mtc.id
                 , sys_extract_utc(systimestamp)
                 , sys_extract_utc(systimestamp)
                 , mtc.eventts
                 , mtc.m5_periodid
                 , mtc.h1_periodid
                 , mtc.nodeid
                 , mtc.areaid
                 , mtc.zoneid
                 , mtc.equipmentid
                 , mtc.station_id
                 , mtc.end_user_id
                 , mtc.mark_code
                 , mtc.subjecttype
                 , mtc.subsystem_type
                 , mtc.process_step
                 , mtc.logistic_step_description
                 , mtc.stype
                 , mtc.number_of_registerpackages
                 , mtc.at_initial_reg
                 , mtc.unexpected
                 )
                 
         log errors into err$_fact_registers_agg_m5 reject limit unlimited;
         
         l_count    := l_count + sql%rowcount;
         l_max_rows := l_max_rows - sql%rowcount;
         l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
         
         commit;
        
      end loop;
      
      
      select *
      bulk  collect into l_err
      from  err$_fact_registers_agg_m5
      order by ora_err_number$
      ;
         
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc =>   l_con_proc
                                , i_msg      =>   l_con_proc||' ERROR. Insert/update FACT_REGISTERS_AGG_M5 failed. '
                                                            ||'ID='           ||to_char(l_err(i).id)
                                                            ||',M5_PERIODID=' ||to_char(l_err(i).m5_periodid)
                                                            ||',AREAID='      ||to_char(l_err(i).areaid)
                                                            ||',ZONEID='      ||to_char(l_err(i).zoneid)
                                                            ||',EQUIPMENTID=' ||to_char(l_err(i).equipmentid)
                                                            ||'. '            ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;

      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc);
      end if;
      
      viu_info.operator_info( i_ifo_nr       => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc||' finished successfully. Processed '||to_char(l_count)||' Metrics. '
                                                                    ||to_char(l_err.count)||' error Metrics.'
                            );
      
    end if;
  exception when others then
    l_msg := substr(l_con_proc||' ERROR. Insert/update FACT_REGISTERS_AGG_M5 failed. '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc );
end;

procedure deregisters_agg_m5
is

   l_con_proc         constant varchar2(61) := g_con_package||'.DEREGISTERS_AGG_M5';
   
   type err_t is table of err$_fact_deregisters_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_max_id           fact_deregisters_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_max_rows         metric_config.max_measurements%type;
   l_from_dt          wc_deregisterpackage.eventts%type;
   l_until_dt         wc_deregisterpackage.eventts%type;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   l_count            number := 0;
   l_msg              viu_info_logs.additional_data%type;

   
begin
   bpi_trace.enter_module( i_module => l_con_proc );

  begin
    begin
      select * into l_mcg from metric_config where upper(metric_procedure) = upper(l_con_proc);
    exception
      when others then l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc, viu_info.c_severity_warning, null
                            , l_con_proc||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).'
                            );
    else

      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc, l_con_proc||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                          );
      
      l_max_rows := l_mcg.max_measurements;
           
      select nvl(max(id), 0) into l_max_id from fact_deregisters_agg_m5;
      select max(eventts) into l_from_dt from fact_deregisters_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_deregisterpackage;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
      delete from err$_fact_deregisters_agg_m5;
      while l_max_rows > 0  and l_from_dt < l_until_dt
      loop
         merge into fact_deregisters_agg_m5 dc5
               using (select *
                      from ( select max(wc.key)                                                             as id
                             ,      period.to_stamp(wc.eventts, 'M5')                                       as eventts 
                             ,      period.periodid(wc.eventts, 'M5')                                       as m5_periodid 
                             ,      period.periodid(wc.eventts, 'H1')                                       as h1_periodid 
                             ,      dim.nodeid
                             ,      substr(trim(wc.areaid),1,5)                                             as areaid
                             ,      substr(trim(wc.zoneid),1,3)                                             as zoneid
                             ,      substr(nvl(trim(wc.equipmentid), '-'),1,3)                              as equipmentid
                             ,      dim.station_id
                             ,      dimstat.end_user_id
                             ,      dim.mark_code
                             ,      dim.subjecttype
                             ,      dim.subsystem_type
                             ,      dim.process_step
                             ,      dim.logistic_step_description
                             ,      dim.stype
                             ,      count(wc.key)                                                           as number_of_deregisterpackages
                             ,      sum( case wc.deregisterreason when 'MISSING' then 1 else 0 end )        as missings
                             ,      sum( case wc.deregisterreason when 'HAND-OVER' then 1 else 0 end )      as handovers
                             ,      sum( case wc.deregisterreason when 'END-OF-TRACING' then 1 else 0 end ) as endoftracings
                             from   wc_deregisterpackage wc
                             ,      dim_node_area_zone_equipment dim
                             ,      dim_node_area_zone_equipment dimstat
                             where wc.key > l_max_id
                             and   wc.areaid = dim.areaid(+) and wc.zoneid = dim.zoneid(+) and wc.equipmentid = dim.equipmentid(+)
                             and   dim.destination_id = dimstat.station_id(+)
                             and   wc.eventts >= l_from_dt
                             and   wc.eventts <  l_from_dt + numtodsinterval(1, 'HOUR')
                          group by period.to_stamp(wc.eventts, 'M5')
                             ,     period.periodid(wc.eventts, 'M5')
                             ,     period.periodid(wc.eventts, 'H1')
                             ,     dim.nodeid, substr(trim(wc.areaid),1,5)
                             ,     substr(trim(wc.zoneid),1,3)
                             ,     substr(nvl(trim(wc.equipmentid), '-'),1,3)
                             ,     dim.station_id
                             ,     dimstat.end_user_id
                             ,     dim.mark_code
                             ,     dim.subjecttype
                             ,     dim.subsystem_type
                             ,     dim.process_step
                             ,     dim.logistic_step_description
                             ,     dim.stype
                             order by id
                             )
                        where rownum <= l_max_rows
               )mtc
           on (     dc5.m5_periodid    = mtc.m5_periodid
                and dc5.areaid         = mtc.areaid
                and dc5.zoneid         = mtc.zoneid
                and dc5.equipmentid    = mtc.equipmentid
         )
       when matched then
       update
          set id                           = mtc.id
          ,   updatets                     = sys_extract_utc(systimestamp)
          ,   number_of_deregisterpackages = dc5.number_of_deregisterpackages + mtc.number_of_deregisterpackages
          ,   missings                     = dc5.missings + mtc.missings
          ,   handovers                    = dc5.handovers + mtc.handovers
          ,   endoftracings                = dc5.endoftracings + mtc.endoftracings
        where dc5.id < mtc.id
          
       when not matched then
       insert( id
             , insertts
             , updatets
             , eventts
             , m5_periodid
             , h1_periodid
             , nodeid
             , areaid
             , zoneid
             , equipmentid
             , station_id
             , end_user_id
             , mark_code
             , subjecttype
             , subsystem_type
             , process_step
             , logistic_step_description
             , stype
             , number_of_deregisterpackages
             , missings
             , handovers
             , endoftracings)
       values( mtc.id
             , sys_extract_utc(systimestamp)
             , sys_extract_utc(systimestamp)
             , mtc.eventts
             , mtc.m5_periodid
             , mtc.h1_periodid
             , mtc.nodeid
             , mtc.areaid
             , mtc.zoneid
             , mtc.equipmentid
             , mtc.station_id
             , mtc.end_user_id
             , mtc.mark_code
             , mtc.subjecttype
             , mtc.subsystem_type
             , mtc.process_step
             , mtc.logistic_step_description
             , mtc.stype
             , mtc.number_of_deregisterpackages
             , mtc.missings
             , mtc.handovers
             , mtc.endoftracings
             )
             
         log errors into err$_fact_deregisters_agg_m5 reject limit unlimited;
             
         l_count    := l_count + sql%rowcount;
         l_max_rows := l_max_rows - sql%rowcount;
         l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
        
         commit;

      end loop;
      
      
      select *
      bulk   collect into l_err
      from   err$_fact_deregisters_agg_m5
      order by ora_err_number$
      ;
         
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc =>   l_con_proc
                                , i_msg      =>   l_con_proc||' ERROR. Insert/update FACT_DEREGISTERS_AGG_M5 failed. '
                                                            ||'ID='            ||to_char(l_err(i).id)
                                                            ||',M5_PERIODID='  ||to_char(l_err(i).m5_periodid)
                                                            ||',AREAID='       ||to_char(l_err(i).areaid)
                                                            ||',ZONEID='       ||to_char(l_err(i).zoneid)
                                                            ||',EQUIPMENTID='  ||to_char(l_err(i).equipmentid)
                                                            ||'. '             ||l_err(i).ora_err_mesg$
                                 );
         end loop;
      end if;
            
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc||' finished successfully. Processed '||to_char(l_count)||' Metrics. '
                                                                    ||to_char(l_err.count)||' error Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc||' ERROR. Insert/update FACT_DEREGISTERS_AGG_M5 failed. '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc, viu_info.c_severity_error, null, l_msg);
  end;
  bpi_trace.leave_module( i_module => l_con_proc );
end;

procedure idchanges_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.IDCHANGES_AGG_M5';
   type err_t is table of err$_fact_idchanges_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_idchanges_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         wc_idchangereport.eventts%type;
   l_from_dt          wc_idchangereport.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
           
      select nvl(max(id), 0) into l_max_id from fact_idchanges_agg_m5;
      select max(eventts) into l_from_dt from fact_idchanges_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_idchangereport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
  
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                            
      delete from err$_fact_idchanges_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_idchanges_agg_m5 ec5
         using ( select *
                 from (select max(key)                       as id
                      ,       period.to_stamp(eventts, 'M5') as eventts 
                      ,       period.periodid(eventts, 'M5') as m5_periodid 
                      ,       period.periodid(eventts, 'H1') as h1_periodid 
                      ,       sourceprocessid                as processid
                      ,       count(key)                     as number_of_idchanges
                      from wc_idchangereport
                      where key      > l_max_id
                      and   eventts  >= l_from_dt
                      and   eventts  <  l_from_dt + numtodsinterval(1, 'HOUR')
                      group by period.to_stamp(eventts, 'M5')
                      ,        period.periodid(eventts, 'M5')
                      ,        period.periodid(eventts, 'H1')
                      ,        sourceprocessid
                      order by id
                     )
                 where rownum <= l_max_rows
               ) mtc
         on (
                  ec5.m5_periodid = mtc.m5_periodid
              and ec5.processid   = mtc.processid
            )
         when matched then
            update
            set     id = mtc.id
            ,       updatets = sys_extract_utc(systimestamp)
            ,       number_of_idchanges = ec5.number_of_idchanges + mtc.number_of_idchanges
            where   ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , processid
                   , number_of_idchanges
                   )
            values
                   ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.processid
                   , mtc.number_of_idchanges
                   )
            log errors into err$_fact_idchanges_agg_m5 reject limit unlimited;
            
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_idchanges_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_IDCHANGES_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',PROCESSID='            ||to_char(l_err(i).processid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;

      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_IDCHANGES_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure handoverreports_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.HANDOVERREPORTS_AGG_M5';
   
   type err_t is table of err$_fact_handoverrep_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_handoverreports_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         wc_handoverdatareport.eventts%type;
   l_from_dt          wc_handoverdatareport.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
      
      select nvl(max(id), 0) into l_max_id from fact_handoverreports_agg_m5;
      select max(eventts) into l_from_dt from fact_handoverreports_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_handoverdatareport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_handoverrep_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_handoverreports_agg_m5 ec5
         using ( select *
                 from (select max(key)                                                        as id
                       ,      period.to_stamp(eventts, 'M5')                                  as eventts 
                       ,      period.periodid(eventts, 'M5')                                  as m5_periodid 
                       ,      period.periodid(eventts, 'H1')                                  as h1_periodid 
                       ,      count(key)                                                      as number_of_handovers
                       ,      sum( case status when 'EMPTY'               then 1 else 0 end ) as empty
                       ,      sum( case status when 'EMPTY_NORMAL'        then 1 else 0 end ) as empty_normal
                       ,      sum( case status when 'EMPTY_OCCUPIED'      then 1 else 0 end ) as empty_occupied
                       ,      sum( case status when 'LOADED'              then 1 else 0 end ) as loaded
                       ,      sum( case status when 'LOADED_NORMAL'       then 1 else 0 end ) as loaded_normal
                       ,      sum( case status when 'LOADED_PRIORITY'     then 1 else 0 end ) as loaded_priority
                       ,      sum( case status when 'MAINTENANCE'         then 1 else 0 end ) as maintenance
                       ,      sum( case status when 'SUSPECT_CART'        then 1 else 0 end ) as suspect_cart
                       ,      sum( case status when 'SUSPECT_BAG'         then 1 else 0 end ) as suspect_bag
                       ,      sum( case status when 'EMPTY_CARRIER'       then 1 else 0 end ) as empty_carrier
                       ,      sum( case status when 'SPECIAL_HANDLING'    then 1 else 0 end ) as special_handling
                       ,      sum( case status when 'LOADED_NO_DEST'      then 1 else 0 end ) as loaded_no_dest
                       ,      sum( case status when 'LOADED_DEFAULT_DEST' then 1 else 0 end ) as loaded_default_dest
                       from   wc_handoverdatareport
                       where  key       >  l_max_id
                       and    eventts   >= l_from_dt
                       and    eventts   <  l_from_dt + numtodsinterval(1, 'HOUR')
                       group by period.to_stamp(eventts, 'M5')
                       ,        period.periodid(eventts, 'M5')
                       ,        period.periodid(eventts, 'H1')
                       order by id
                      )
                 where rownum <= l_max_rows) mtc
         on (
              ec5.m5_periodid = mtc.m5_periodid
            )
         when matched then
            update
            set       id                  = mtc.id
            ,         updatets            = sys_extract_utc(systimestamp)
            ,         number_of_handovers = ec5.number_of_handovers + mtc.number_of_handovers
            ,         empty               = ec5.empty + mtc.empty
            ,         empty_normal        = ec5.empty_normal + mtc.empty_normal
            ,         empty_occupied      = ec5.empty_occupied + mtc.empty_occupied
            ,         loaded              = ec5.loaded + mtc.loaded
            ,         loaded_normal       = ec5.loaded_normal + mtc.loaded_normal
            ,         loaded_priority     = ec5.loaded_priority + mtc.loaded_priority
            ,         maintenance         = ec5.maintenance + mtc.maintenance
            ,         suspect_cart        = ec5.suspect_cart + mtc.suspect_cart
            ,         suspect_bag         = ec5.suspect_bag + mtc.suspect_bag
            ,         empty_carrier       = ec5.empty_carrier + mtc.empty_carrier
            ,         special_handling    = ec5.special_handling + mtc.special_handling
            ,         loaded_no_dest      = ec5.loaded_no_dest + mtc.loaded_no_dest
            ,         loaded_default_dest = ec5.loaded_default_dest + mtc.loaded_default_dest
            where     ec5.id < mtc.id
          when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , number_of_handovers
                   , empty
                   , empty_normal
                   , empty_occupied
                   , loaded
                   , loaded_normal
                   , loaded_priority
                   , maintenance
                   , suspect_cart
                   , suspect_bag
                   , empty_carrier
                   , special_handling
                   , loaded_no_dest
                   , loaded_default_dest )
            values
                   ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.number_of_handovers
                   , mtc.empty
                   , mtc.empty_normal
                   , mtc.empty_occupied
                   , mtc.loaded
                   , mtc.loaded_normal
                   , mtc.loaded_priority
                   , mtc.maintenance
                   , mtc.suspect_cart
                   , mtc.suspect_bag
                   , mtc.empty_carrier
                   , mtc.special_handling
                   , mtc.loaded_no_dest
                   , mtc.loaded_default_dest
                   )
            log errors into err$_fact_handoverrep_agg_m5 reject limit unlimited;
        
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_handoverrep_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_HANDOVERREPORTS_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_HANDOVERREPORTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure scanresults_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.scanresults_agg_m5';
   
   type err_t is table of err$_fact_scanresults_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_scanresults_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_max_rows         metric_config.max_measurements%type;
   l_from_dt          wc_packagereport.eventts%type;
   l_until_dt         wc_packagereport.eventts%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    if l_mcg.status != 1 then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).'
                            );
    else
    
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;

      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                          );

      l_max_rows := l_mcg.max_measurements;
      
      select nvl(max(id), 0) into l_max_id from fact_scanresults_agg_m5;
      select max(eventts) into l_from_dt from fact_scanresults_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_packagereport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
      
      delete from err$_fact_scanresults_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_scanresults_agg_m5 ec5
         using ( select *
                 from ( select   max(wc.key)                                                                           as id
                        ,          period.to_stamp(eventts, 'M5')                                                      as eventts 
                        ,          period.periodid(eventts, 'M5')                                                      as m5_periodid 
                        ,          period.periodid(eventts, 'H1')                                                      as h1_periodid 
                        ,          dim.nodeid
                        ,          substr(trim(wc.areaid),1,5)                                                         as areaid
                        ,          substr(trim(wc.zoneid),1,3)                                                         as zoneid
                        ,          substr(nvl(trim(wc.equipmentid), '-'),1,3)                                          as equipmentid
                        ,          dim.station_id, dim.end_user_id, dim.mark_code, dim.subjecttype
                        ,          dim.subsystem_type, dim.process_step, dim.stype
                        ,          count(wc.key)                                                                       as number_of_scanresults
                        ,          sum( case when csv.tag_count_in_csv('LPC', wc.l_baggagetag) = 0 then 1 else 0 end ) as no_reads
                        ,          sum( case when csv.tag_count_in_csv('LPC', wc.l_baggagetag) = 1 then 1 else 0 end ) as normal_reads
                        ,          sum( case when csv.tag_count_in_csv('LPC', wc.l_baggagetag) > 1 then 1 else 0 end ) as multi_reads
                        from wc_packagereport wc, dim_node_area_zone_equipment dim
                        where wc.key         > l_max_id
                        and   wc.areaid      = dim.areaid(+)
                        and   wc.zoneid      = dim.zoneid(+)
                        and   wc.equipmentid = dim.equipmentid(+)
                        and   wc.resulttype  = 'ScanResult'
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(eventts, 'M5')
                        ,          period.periodid(eventts, 'M5')
                        ,          period.periodid(eventts, 'H1')
                        ,          dim.nodeid
                        ,          substr(trim(wc.areaid),1,5)
                        ,          substr(trim(wc.zoneid),1,3)
                        ,          substr(nvl(trim(wc.equipmentid), '-'),1,3)
                        ,          dim.station_id
                        ,          dim.end_user_id
                        ,          dim.mark_code
                        ,          dim.subjecttype
                        ,          dim.subsystem_type
                        ,          dim.process_step
                        ,          dim.stype
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid = mtc.m5_periodid
                and ec5.areaid      = mtc.areaid
                and ec5.zoneid      = mtc.zoneid
                and ec5.equipmentid = mtc.equipmentid
               )
            when matched then
                 update
                 set id                    = mtc.id
                 ,   updatets              = sys_extract_utc(systimestamp)
                 ,   number_of_scanresults = ec5.number_of_scanresults + mtc.number_of_scanresults
                 ,   no_reads              = ec5.no_reads + mtc.no_reads
                 ,   normal_reads          = ec5.normal_reads + mtc.normal_reads
                 ,   multi_reads           = ec5.multi_reads + mtc.multi_reads
                 where ec5.id < mtc.id
            when not matched then
                 insert ( id
                        , insertts
                        , updatets
                        , eventts
                        , m5_periodid
                        , h1_periodid
                        , nodeid
                        , areaid
                        , zoneid
                        , equipmentid
                        , station_id
                        , end_user_id
                        , mark_code
                        , subjecttype
                        , subsystem_type
                        , process_step
                        , stype
                        , number_of_scanresults
                        , no_reads
                        , normal_reads
                        , multi_reads )
                 values
                        ( mtc.id
                        , sys_extract_utc(systimestamp)
                        , sys_extract_utc(systimestamp)
                        , mtc.eventts
                        , mtc.m5_periodid
                        , mtc.h1_periodid
                        , mtc.nodeid
                        , mtc.areaid
                        , mtc.zoneid
                        , mtc.equipmentid
                        , mtc.station_id
                        , mtc.end_user_id
                        , mtc.mark_code
                        , mtc.subjecttype
                        , mtc.subsystem_type
                        , mtc.process_step
                        , mtc.stype
                        , mtc.number_of_scanresults
                        , mtc.no_reads
                        , mtc.normal_reads
                        , mtc.multi_reads
                        )
                log errors into err$_fact_scanresults_agg_m5 reject limit unlimited;
                
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_scanresults_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_SCANRESULTS_AGG_M5 failed. '
                                                ||'ID='                    ||to_char(l_err(i).id)
                                                ||'M5_PERIODID='           ||to_char(l_err(i).m5_periodid)
                                                ||'AREAID='                ||to_char(l_err(i).areaid)
                                                ||'ZONEID='                ||to_char(l_err(i).zoneid)
                                                ||'EQUIPMENTID='           ||to_char(l_err(i).equipmentid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr       => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_SCANRESULTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure screen_analysis_agg_m5 is
   l_con_proc_name constant varchar2(61) := g_con_package||'.SCREEN_ANALYSIS_AGG_M5';
   type err_t is table of err$_fact_screen_analys_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   l_screeningconcept varchar2(50);
   
   l_max_id           fact_screen_analysis_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         wc_packagereport.eventts%type;
   l_from_dt          wc_packagereport.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;
   
begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
      
      select nvl(max(id), 0) into l_max_id from fact_screen_analysis_agg_m5;
      select max(eventts) into l_from_dt from fact_screen_analysis_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_packagereport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
  
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );

      begin
         begin
            select 'ID='||to_char(id)
            into   l_screeningconcept
            from   dim_screening_processes
            where  is_default = 'Y';
         exception
            when others then
               
               l_screeningconcept := cmn_common.get_parameter_value('SCREENING_CONCEPT');
         end;
      exception
         when others then
           l_screeningconcept := null;
      end;

      delete from err$_fact_screen_analys_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_screen_analysis_agg_m5 ec5
         using (select *
                from ( select max(wc.key) + nvl(wc.screening_process_id, 0) as id
                       ,      period.to_stamp(wc.eventts, 'M5')             as eventts
                       ,      period.periodid(wc.eventts, 'M5')             as m5_periodid
                       ,      period.periodid(wc.eventts, 'H1')             as h1_periodid
                       ,      substr(trim(wc.areaid),1,5)                   as areaid
                       ,      substr(trim(wc.zoneid),1,3)                   as zoneid
                       ,      substr(nvl(trim(wc.equipmentid), '-'),1,3)    as equipmentid
                       ,      wc.screening_process_id
                       ,      wc.screening_process_name
                       ,      dim.nodeid, dim.station_id, dim.end_user_id, dim.mark_code, dim.subjecttype
                       ,      dim.subsystem_type, dim.process_step, dim.stype
                       ,      count(wc.key)                                 as number_of_screeningresults
                       ,      sum(wc.cleared)                               as cleared
                       ,      sum(wc.nodecision)                            as nodecision
                       ,      sum(wc.uncleared)                             as uncleared
                       ,      sum(wc.l1_cleared)                            as l1_cleared
                       ,      sum(wc.l1_nodecision)                         as l1_nodecision
                       ,      sum(wc.l1_uncleared)                          as l1_uncleared
                       ,      sum(wc.l1_required_cleared)                   as l1_required_cleared
                       ,      sum(wc.l1_required_nodecision)                as l1_required_nodecision
                       ,      sum(wc.l1_required_uncleared)                 as l1_required_uncleared
                       ,      sum(wc.l2_cleared)                            as l2_cleared
                       ,      sum(wc.l2_nodecision)                         as l2_nodecision
                       ,      sum(wc.l2_uncleared)                          as l2_uncleared
                       ,      sum(wc.l2_required_cleared)                   as l2_required_cleared
                       ,      sum(wc.l2_required_nodecision)                as l2_required_nodecision
                       ,      sum(wc.l2_required_uncleared)                 as l2_required_uncleared
                       ,      sum(wc.l3_cleared)                            as l3_cleared
                       ,      sum(wc.l3_nodecision)                         as l3_nodecision
                       ,      sum(wc.l3_uncleared)                          as l3_uncleared
                       ,      sum(wc.l3_required_cleared)                   as l3_required_cleared
                       ,      sum(wc.l3_required_nodecision)                as l3_required_nodecision
                       ,      sum(wc.l3_required_uncleared)                 as l3_required_uncleared
                       ,      sum(wc.l4_cleared)                            as l4_cleared
                       ,      sum(wc.l4_nodecision)                         as l4_nodecision
                       ,      sum(wc.l4_uncleared)                          as l4_uncleared
                       ,      sum(wc.l4_required_cleared)                   as l4_required_cleared
                       ,      sum(wc.l4_required_nodecision)                as l4_required_nodecision
                       ,      sum(wc.l4_required_uncleared)                 as l4_required_uncleared
                       ,      sum(wc.l5_cleared)                            as l5_cleared
                       ,      sum(wc.l5_nodecision)                         as l5_nodecision
                       ,      sum(wc.l5_uncleared)                          as l5_uncleared
                       ,      sum(wc.l5_required_cleared)                   as l5_required_cleared
                       ,      sum(wc.l5_required_nodecision)                as l5_required_nodecision
                       ,      sum(wc.l5_required_uncleared)                 as l5_required_uncleared
                       from ( select key
                            ,        eventts
                            ,        areaid
                            ,        zoneid
                            ,        equipmentid
                            ,        screening_process_id
                            ,        screening_process_name
                            ,        cleared, nodecision, uncleared
                            ,        case when screening_level='1' then cleared            else 0 end as l1_cleared
                            ,        case when screening_level='1' then nodecision         else 0 end as l1_nodecision
                            ,        case when screening_level='1' then uncleared          else 0 end as l1_uncleared
                            ,        case when screening_level='1' and  required_level='1' then cleared    else 0 end as l1_required_cleared
                            ,        case when screening_level='1' and  required_level='1' then nodecision else 0 end as l1_required_nodecision
                            ,        case when screening_level='1' and  required_level='1' then uncleared  else 0 end as l1_required_uncleared
                            ,        case when screening_level='2' then cleared            else 0 end as l2_cleared
                            ,        case when screening_level='2' then nodecision         else 0 end as l2_nodecision
                            ,        case when screening_level='2' then uncleared          else 0 end as l2_uncleared
                            ,        case when screening_level='2' and  required_level='2' then cleared    else 0 end as l2_required_cleared
                            ,        case when screening_level='2' and  required_level='2' then nodecision else 0 end as l2_required_nodecision
                            ,        case when screening_level='2' and  required_level='2' then uncleared  else 0 end as l2_required_uncleared
                            ,        case when screening_level='3' then cleared            else 0 end as l3_cleared
                            ,        case when screening_level='3' then nodecision         else 0 end as l3_nodecision
                            ,        case when screening_level='3' then uncleared          else 0 end as l3_uncleared
                            ,        case when screening_level='3' and  required_level='3' then cleared    else 0 end as l3_required_cleared
                            ,        case when screening_level='3' and  required_level='3' then nodecision else 0 end as l3_required_nodecision
                            ,        case when screening_level='3' and  required_level='3' then uncleared  else 0 end as l3_required_uncleared
                            ,        case when screening_level='4' then cleared            else 0 end as l4_cleared
                            ,        case when screening_level='4' then nodecision         else 0 end as l4_nodecision
                            ,        case when screening_level='4' then uncleared          else 0 end as l4_uncleared
                            ,        case when screening_level='4' and  required_level='3' then cleared    else 0 end as l4_required_cleared
                            ,        case when screening_level='4' and  required_level='3' then nodecision else 0 end as l4_required_nodecision
                            ,        case when screening_level='4' and  required_level='3' then uncleared  else 0 end as l4_required_uncleared
                            ,        case when screening_level='5' then cleared            else 0 end as l5_cleared
                            ,        case when screening_level='5' then nodecision         else 0 end as l5_nodecision
                            ,        case when screening_level='5' then uncleared          else 0 end as l5_uncleared
                            ,        case when screening_level='5' and  required_level='3' then cleared    else 0 end as l5_required_cleared
                            ,        case when screening_level='5' and  required_level='3' then nodecision else 0 end as l5_required_nodecision
                            ,        case when screening_level='5' and  required_level='3' then uncleared  else 0 end as l5_required_uncleared
                            from ( select key
                                   ,      eventts
                                   ,      areaid
                                   ,      zoneid
                                   ,      nvl(equipmentid, '-') as equipmentid
                                   ,      sp.id as screening_process_id
                                   ,      sp.name as screening_process_name
                                   ,      bagsummary.get_tag_delimited_value(pr.l_screeningresult, 'ScreeningLevel', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept))                                  as screening_level
                                   ,      bagsummary.get_tag_delimited_value(pr.l_birscreeninginfo, 'RequiredScreeningLevel', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept))                         as required_level
                                   ,      bagsummary.get_tag_delimited_value(pr.l_birscreeninginfo, 'ReachedScreeningLevel', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept))                          as reached_level
                                   ,      case when bagsummary.get_tag_delimited_value(pr.l_screeningresult, 'Result', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept))='CLEARED'    then 1 else 0 end as cleared
                                   ,      case when bagsummary.get_tag_delimited_value(pr.l_screeningresult, 'Result', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept))='NODECISION' then 1 else 0 end as nodecision
                                   ,      case when bagsummary.get_tag_delimited_value(pr.l_screeningresult, 'Result', nvl2(sp.id, 'ID='||sp.id, l_screeningconcept)) in ('UNCLEARED','REJECT')  then 1 else 0 end as uncleared
                                   from  wc_packagereport pr, dim_screening_processes sp
                                   where key > l_max_id
                                   and   eventts             >= l_from_dt
                                   and   eventts             <  l_from_dt + numtodsinterval(1, 'HOUR')
                                   and   resulttype like '%ScreeningResult%'
                                   and ( instr(chr(10)||pr.l_birscreeninginfo, chr(10)||'ID='||sp.id) > 0
                                         or
                                         instr(chr(10)||pr.l_screeningresult, chr(10)||'ID='||sp.id) > 0
                                       )
                                 )
                            ) wc, dim_node_area_zone_equipment dim
                       where wc.areaid      = dim.areaid(+)
                       and   wc.zoneid      = dim.zoneid(+)
                       and   wc.equipmentid = dim.equipmentid(+)
                       group by period.to_stamp(wc.eventts, 'M5')
                       ,        period.periodid(wc.eventts, 'M5')
                       ,        period.periodid(wc.eventts, 'H1')
                       ,        substr(trim(wc.areaid),1,5), substr(trim(wc.zoneid),1,3), substr(nvl(trim(wc.equipmentid), '-'),1,3)
                       ,        wc.screening_process_id
                       ,        wc.screening_process_name
                       ,        dim.nodeid, dim.station_id, dim.end_user_id, dim.mark_code, dim.subjecttype
                       ,        dim.subsystem_type, dim.process_step, dim.stype
                       order by id
                     )
                 where rownum <= l_max_rows
               ) mtc
         on (
                  ec5.m5_periodid = mtc.m5_periodid
              and ec5.areaid      = mtc.areaid
              and ec5.zoneid      = mtc.zoneid
              and ec5.equipmentid = mtc.equipmentid
              and (    ec5.screening_process_id is null
                   and mtc.screening_process_id is null
                   or  ec5.screening_process_id = mtc.screening_process_id
                  )
            )
         when matched then
            update
            set         id                            = mtc.id
            ,             updatets                    = sys_extract_utc(systimestamp)
            ,             number_of_screeningresults  = ec5.number_of_screeningresults + mtc.number_of_screeningresults
            ,             cleared                     = ec5.cleared + mtc.cleared
            ,             nodecision                  = ec5.nodecision + mtc.nodecision
            ,             uncleared                   = ec5.uncleared + mtc.uncleared
            ,             l1_cleared                  = ec5.l1_cleared + mtc.l1_cleared
            ,             l1_nodecision               = ec5.l1_nodecision + mtc.l1_nodecision
            ,             l1_uncleared                = ec5.l1_uncleared + mtc.l1_uncleared
            ,             l1_required_cleared         = ec5.l1_required_cleared + mtc.l1_required_cleared
            ,             l1_required_nodecision      = ec5.l1_required_nodecision + mtc.l1_required_nodecision
            ,             l1_required_uncleared       = ec5.l1_required_uncleared + mtc.l1_required_uncleared
            ,             l2_cleared                  = ec5.l2_cleared + mtc.l2_cleared
            ,             l2_nodecision               = ec5.l2_nodecision + mtc.l2_nodecision
            ,             l2_uncleared                = ec5.l2_uncleared + mtc.l2_uncleared
            ,             l2_required_cleared         = ec5.l2_required_cleared + mtc.l2_required_cleared
            ,             l2_required_nodecision      = ec5.l2_required_nodecision + mtc.l2_required_nodecision
            ,             l2_required_uncleared       = ec5.l2_required_uncleared + mtc.l2_required_uncleared
            ,             l3_cleared                  = ec5.l3_cleared + mtc.l3_cleared
            ,             l3_nodecision               = ec5.l3_nodecision + mtc.l3_nodecision
            ,             l3_uncleared                = ec5.l3_uncleared + mtc.l3_uncleared
            ,             l3_required_cleared         = ec5.l3_required_cleared + mtc.l3_required_cleared
            ,             l3_required_nodecision      = ec5.l3_required_nodecision + mtc.l3_required_nodecision
            ,             l3_required_uncleared       = ec5.l3_required_uncleared + mtc.l3_required_uncleared
            ,             l4_cleared                  = ec5.l4_cleared + mtc.l4_cleared
            ,             l4_nodecision               = ec5.l4_nodecision + mtc.l4_nodecision
            ,             l4_uncleared                = ec5.l4_uncleared + mtc.l4_uncleared
            ,             l4_required_cleared         = ec5.l4_required_cleared + mtc.l4_required_cleared
            ,             l4_required_nodecision      = ec5.l4_required_nodecision + mtc.l4_required_nodecision
            ,             l4_required_uncleared       = ec5.l4_required_uncleared + mtc.l4_required_uncleared
            ,             l5_cleared                  = ec5.l5_cleared + mtc.l5_cleared
            ,             l5_nodecision               = ec5.l5_nodecision + mtc.l5_nodecision
            ,             l5_uncleared                = ec5.l5_uncleared + mtc.l5_uncleared
            ,             l5_required_cleared         = ec5.l5_required_cleared + mtc.l5_required_cleared
            ,             l5_required_nodecision      = ec5.l5_required_nodecision + mtc.l5_required_nodecision
            ,             l5_required_uncleared       = ec5.l5_required_uncleared + mtc.l5_required_uncleared
            where      ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , areaid
                   , zoneid
                   , equipmentid
                   , screening_process_id
                   , screening_process_name
                   , nodeid
                   , station_id
                   , end_user_id
                   , mark_code
                   , subjecttype
                   , subsystem_type
                   , process_step
                   , stype
                   , number_of_screeningresults
                   , cleared
                   , nodecision
                   , uncleared
                   , l1_cleared
                   , l1_nodecision
                   , l1_uncleared
                   , l1_required_cleared
                   , l1_required_nodecision
                   , l1_required_uncleared
                   , l2_cleared
                   , l2_nodecision
                   , l2_uncleared
                   , l2_required_cleared
                   , l2_required_nodecision
                   , l2_required_uncleared
                   , l3_cleared
                   , l3_nodecision
                   , l3_uncleared
                   , l3_required_cleared
                   , l3_required_nodecision
                   , l3_required_uncleared
                   , l4_cleared
                   , l4_nodecision
                   , l4_uncleared
                   , l4_required_cleared
                   , l4_required_nodecision
                   , l4_required_uncleared
                   , l5_cleared
                   , l5_nodecision
                   , l5_uncleared
                   , l5_required_cleared
                   , l5_required_nodecision
                   , l5_required_uncleared )
            values ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.areaid
                   , mtc.zoneid
                   , mtc.equipmentid
                   , mtc.screening_process_id
                   , mtc.screening_process_name
                   , mtc.nodeid
                   , mtc.station_id
                   , mtc.end_user_id
                   , mtc.mark_code
                   , mtc.subjecttype
                   , mtc.subsystem_type
                   , mtc.process_step
                   , mtc.stype
                   , mtc.number_of_screeningresults
                   , mtc.cleared
                   , mtc.nodecision
                   , mtc.uncleared
                   , mtc.l1_cleared
                   , mtc.l1_nodecision
                   , mtc.l1_uncleared
                   , mtc.l1_required_cleared
                   , mtc.l1_required_nodecision
                   , mtc.l1_required_uncleared
                   , mtc.l2_cleared
                   , mtc.l2_nodecision
                   , mtc.l2_uncleared
                   , mtc.l2_required_cleared
                   , mtc.l2_required_nodecision
                   , mtc.l2_required_uncleared
                   , mtc.l3_cleared
                   , mtc.l3_nodecision
                   , mtc.l3_uncleared
                   , mtc.l3_required_cleared
                   , mtc.l3_required_nodecision
                   , mtc.l3_required_uncleared
                   , mtc.l4_cleared
                   , mtc.l4_nodecision
                   , mtc.l4_uncleared
                   , mtc.l4_required_cleared
                   , mtc.l4_required_nodecision
                   , mtc.l4_required_uncleared
                   , mtc.l5_cleared
                   , mtc.l5_nodecision
                   , mtc.l5_uncleared
                   , mtc.l5_required_cleared
                   , mtc.l5_required_nodecision
                   , mtc.l5_required_uncleared )
            log errors into err$_fact_screen_analys_agg_m5 reject limit unlimited;
        
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_screen_analys_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_SCREEN_ANALYSIS_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',SCREENING_PROCESS_ID=' ||to_char(l_err(i).screening_process_id)
                                                ||',AREAID='               ||to_char(l_err(i).areaid)
                                                ||',ZONEID='               ||to_char(l_err(i).zoneid)
                                                ||',EQUIPMENTID='          ||to_char(l_err(i).equipmentid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;

      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_SCREEN_ANALYSIS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure applogging_agg_m5 is
   l_con_proc_name constant varchar2(61) := g_con_package||'.APPLOGGING_AGG_M5';
   
   type err_t is table of err$_fact_applogging_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_applogging_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         wc_applicationlogdata.eventts%type;
   l_from_dt          wc_applicationlogdata.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
      
      select nvl(max(id), 0) into l_max_id from fact_applogging_agg_m5;
      select max(eventts) into l_from_dt from fact_applogging_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_applicationlogdata;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_applogging_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_applogging_agg_m5 ec5
         using ( select *
                 from (select max(key)                       as id
                      ,       period.to_stamp(eventts, 'M5') as eventts 
                      ,       period.periodid(eventts, 'M5') as m5_periodid 
                      ,       period.periodid(eventts, 'H1') as h1_periodid 
                      ,       nvl(host, '-')                 as host
                      ,       nvl(processid, '-')            as processid
                      ,       nvl(logmessageseverity, '-')   as logmessageseverity
                      ,       nvl(logmessageid, '-')         as logmessageid
                      ,       nvl(applicationelementid,'-')  as applicationelementid
                      ,       nvl(sessionid,'-')             as sessionid
                      ,       nvl(subcomponent,'-')          as subcomponent
                      ,       nvl(threadid,'-')              as threadid
                      ,       count(key)                     as number_of_logs
                      from    wc_applicationlogdata
                      where   key                 > l_max_id
                      and     eventts             >= l_from_dt
                      and     eventts             <  l_from_dt + numtodsinterval(1, 'HOUR')
                      and     areaid              is null 
                      group by period.to_stamp(eventts, 'M5')
                      ,        period.periodid(eventts, 'M5')
                      ,        period.periodid(eventts, 'H1')
                      ,        host
                      ,        processid
                      ,        logmessageseverity
                      ,        logmessageid
                      ,        applicationelementid
                      ,        sessionid
                      ,        subcomponent
                      ,        threadid
                      order by id
                      )
                 where rownum <= l_max_rows
               ) mtc
         on (
                  ec5.m5_periodid          = mtc.m5_periodid
              and ec5.host                 = mtc.host
              and ec5.processid            = mtc.processid
              and ec5.logmessageseverity   = mtc.logmessageseverity
              and ec5.logmessageid         = mtc.logmessageid
              and ec5.applicationelementid = mtc.applicationelementid
              and ec5.sessionid            = mtc.sessionid
              and ec5.subcomponent         = mtc.subcomponent
              and ec5.threadid             = mtc.threadid
            )
         when matched then
            update
            set     id             = mtc.id
            ,       updatets       = sys_extract_utc(systimestamp)
            ,       number_of_logs = ec5.number_of_logs + mtc.number_of_logs
            where   ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , host
                   , processid
                   , logmessageseverity
                   , logmessageid
                   , applicationelementid
                   , sessionid
                   , subcomponent
                   , threadid
                   , number_of_logs
                   )
            values ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.host
                   , mtc.processid
                   , mtc.logmessageseverity
                   , mtc.logmessageid
                   , mtc.applicationelementid
                   , mtc.sessionid
                   , mtc.subcomponent
                   , mtc.threadid
                   , mtc.number_of_logs )
            log errors into err$_fact_applogging_agg_m5 reject limit unlimited;
        
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_applogging_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_APPLOGGING_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',HOST='                 ||to_char(l_err(i).host)
                                                ||',PROCESSID='            ||to_char(l_err(i).processid)
                                                ||',LOGMESSAGESEVERITY='   ||to_char(l_err(i).logmessageseverity)
                                                ||',LOGMESSAGEID='         ||to_char(l_err(i).logmessageid)
                                                ||',APPLICATIONELEMENTID=' ||to_char(l_err(i).applicationelementid)
                                                ||',SESSIONID='            ||to_char(l_err(i).sessionid)
                                                ||',SUBCOMPONENT='         ||to_char(l_err(i).subcomponent)
                                                ||',THREADID='             ||to_char(l_err(i).threadid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_APPLOGGING_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure bagsummaries_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.BAGSUMMARIES_AGG_M5';
   
   type err_t is table of err$_fact_bagsummaries_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_bagsummaries_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  fact_bag_summaries.enter_dt%type;
   l_from_dt   fact_bag_summaries.enter_dt%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;

begin
   bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception when others then
      l_mcg.status := 0;
    end;
   
    
    if l_mcg.status != 1 then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).'
                            );
    else

      if l_mcg.period_type <> 'M5' then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;

      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );
      
      l_max_rows := l_mcg.max_measurements;
  
      select nvl(max(id), 0) into l_max_id from fact_bagsummaries_agg_m5;
      select min(enter_dt) into l_from_dt from fact_bag_summaries where  id > l_max_id;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      else
        l_from_dt := period.startts(sys_extract_utc(systimestamp), l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => to_char(l_until_dt)||', '||to_char(l_max_rows)
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
      delete from err$_fact_bagsummaries_agg_m5;
      
      while l_max_rows > 0  and l_from_dt < l_until_dt
      loop
         merge into fact_bagsummaries_agg_m5 ec5
         using ( select *
                 from ( select max(id)                                                              as id
                        ,      period.to_stamp(m5_periodid, 'M5')                                   as eventts 
                        ,      m5_periodid                                                                     
                        ,      period.periodid(m5_periodid                        ,      'H1')      as h1_periodid 
                        ,      count(id)                                                            as number_of_bags
                        ,      sum( case completion_status             when 'D' then 1 else 0 end ) as deregistered_bags
                        ,      sum( case ind_crew_bag                  when 'Y' then 1 else 0 end ) as crew_bags
                        ,      sum( case ind_rush_bag                  when 'Y' then 1 else 0 end ) as rush_bags
                        ,      sum( case ind_non_conveyable            when 'Y' then 1 else 0 end ) as non_conveyables
                        ,      sum( case ind_delay_due_to_operator     when 'Y' then 1 else 0 end ) as operator_delays
                        ,      sum( case ind_manual_identification_req when 'Y' then 1 else 0 end ) as manual_identifications
                        ,      sum( case ind_in_system_time_ok         when 'Y' then 1 else 0 end ) as system_time_oks
                        ,      sum( case ind_in_system_time_w1         when 'Y' then 1 else 0 end ) as system_time_w1s
                        ,      sum( case ind_in_system_time_w2         when 'Y' then 1 else 0 end ) as system_time_w2s
                        ,      sum( case ind_in_system_time_w3         when 'Y' then 1 else 0 end ) as system_time_w3s
                        ,      sum( case ind_system_attributable       when 'Y' then 1 else 0 end ) as system_attributables
                        ,      sum( case ind_lost_occurred             when 'Y' then 1 else 0 end ) as lost_bags
                        ,      sum( case ind_recovered                 when 'Y' then 1 else 0 end ) as recovered_bags
                        ,      sum( case ind_sorted_correctly          when 'Y' then 1 else 0 end ) as bags_sorted_correctly
                        ,      sum( case when ind_sorted_correctly is null or ind_sorted_correctly ='N'
                                         then 1 else 0 end )                                        as bags_not_sorted
                        ,      sum( case when store_dt is null
                                         then 0 else 1 end )                                        as bags_stored
                        ,      sum( case when total_duration_stored is null
                                         then 0 else 1 end )                                        as bags_stored_outflow
                        ,      sum(transport_exception_count)                                       as sum_transport_exceptions
                        ,      sum(total_delay_due_to_operator)                                     as sum_operator_delays
                        ,      sum(interval_in_seconds(enter_dt , last_event_dt))                   as sum_durations
                        ,      max(perf_duration_rp_pi)                                             as dur_max_rp_pi
                        ,      max(perf_duration_pr_tr)                                             as dur_max_pr_tr
                        ,      max(perf_duration_ti_pi)                                             as dur_max_ti_pi
                        ,      max(perf_duration_tr_ti)                                             as dur_max_tr_ti
                        ,      max(perf_duration_pir_pi)                                            as dur_max_pir_pi
                        ,      sum( case intimeliness       when 'Early'         then 1 else 0 end) as bags_in_early
                        ,      sum( case intimeliness       when 'In Time'       then 1 else 0 end) as bags_in_time
                        ,      sum( case intimeliness       when 'Time Critical' then 1 else 0 end) as bags_in_critical
                        ,      sum( case intimeliness       when 'Too Late'      then 1 else 0 end) as bags_in_toolate
                        ,      sum( case outtimeliness      when 'EARLY'         then 1 else 0 end) as bags_out_early
                        ,      sum( case outtimeliness      when 'ONTIME'        then 1 else 0 end) as bags_out_ontime
                        ,      sum( case outtimeliness      when 'EXPEDITE'      then 1 else 0 end) as bags_out_expedite
                        ,      sum( case outtimeliness      when 'LATE'          then 1 else 0 end) as bags_out_late
                        ,      sum( case outtimeliness      when 'MISSED'        then 1 else 0 end) as bags_out_missed
                        ,      sum( case screen_latest_lvl  when '1'             then 1 else 0 end) as bags_screen_l1
                        ,      sum( case screen_latest_lvl  when '2'             then 1 else 0 end) as bags_screen_l2
                        ,      sum( case screen_latest_lvl  when '3'             then 1 else 0 end) as bags_screen_l3
                        ,      sum( case screen_latest_lvl  when '4'             then 1 else 0 end) as bags_screen_l4
                        ,      sum( case screen_latest_lvl  when '5'             then 1 else 0 end) as bags_screen_l5
                        ,      sum( case when screen_latest_lvl is null or screen_latest_lvl ='0'
                                         then 1 else 0 end)                                         as bags_not_screened
                        ,      sum( case source             when 'L'             then 1 else 0 end) as local_bags
                        ,      sum( case source             when 'T'             then 1 else 0 end) as transfer_bags
                        ,      sum( case when scan_latest_result like 'Auto%'    then 1 else 0 end) as auto_identifications
                        ,      sum( case when source = 'L' and outtimeliness = 'MISSED'  then 1 else 0 end) as localbags_out_missed
                        ,      sum( case when source = 'T' and outtimeliness = 'MISSED'  then 1 else 0 end) as transferbags_out_missed
                        ,      sum( case when screen_latest_lvl >= screen_latest_lvl_req then 1 else 0 end) as bags_screen_req
                        ,      sum( case when source is null                             then 1 else 0 end) as source_unknown_bags
                        from fact_bag_summaries
                        where enter_dt >= l_from_dt
                        and   enter_dt < l_from_dt + numtodsinterval(1, 'HOUR')
                        group by m5_periodid
                        order by id
                      )
                 where rownum <= l_max_rows
               ) mtc
         on (
              ec5.m5_periodid = mtc.m5_periodid
            )
         when matched then
             update
             set id                       = mtc.id
             ,   updatets                 = sys_extract_utc(systimestamp)
             ,   number_of_bags           = mtc.number_of_bags
             ,   deregistered_bags        = mtc.deregistered_bags
             ,   crew_bags                = mtc.crew_bags
             ,   rush_bags                = mtc.rush_bags
             ,   non_conveyables          = mtc.non_conveyables
             ,   operator_delays          = mtc.operator_delays
             ,   manual_identifications   = mtc.manual_identifications
             ,   system_time_oks          = mtc.system_time_oks
             ,   system_time_w1s          = mtc.system_time_w1s
             ,   system_time_w2s          = mtc.system_time_w2s
             ,   system_time_w3s          = mtc.system_time_w3s
             ,   system_attributables     = mtc.system_attributables
             ,   lost_bags                = mtc.lost_bags
             ,   recovered_bags           = mtc.recovered_bags
             ,   bags_sorted_correctly    = mtc.bags_sorted_correctly
             ,   bags_not_sorted          = mtc.bags_not_sorted
             ,   bags_stored              = mtc.bags_stored
             ,   bags_stored_outflow      = mtc.bags_stored_outflow
             ,   sum_transport_exceptions = mtc.sum_transport_exceptions
             ,   sum_operator_delays      = mtc.sum_operator_delays
             ,   sum_durations            = mtc.sum_durations
             ,   dur_max_rp_pi            = mtc.dur_max_rp_pi
             ,   dur_max_pr_tr            = mtc.dur_max_pr_tr
             ,   dur_max_ti_pi            = mtc.dur_max_ti_pi
             ,   dur_max_tr_ti            = mtc.dur_max_tr_ti
             ,   dur_max_pir_pi           = mtc.dur_max_pir_pi
             ,   bags_in_early            = mtc.bags_in_early
             ,   bags_in_time             = mtc.bags_in_time
             ,   bags_in_critical         = mtc.bags_in_critical
             ,   bags_in_toolate          = mtc.bags_in_toolate
             ,   bags_out_early           = mtc.bags_out_early
             ,   bags_out_ontime          = mtc.bags_out_ontime
             ,   bags_out_expedite        = mtc.bags_out_expedite
             ,   bags_out_late            = mtc.bags_out_late
             ,   bags_out_missed          = mtc.bags_out_missed
             ,   bags_screen_l1           = mtc.bags_screen_l1
             ,   bags_screen_l2           = mtc.bags_screen_l2
             ,   bags_screen_l3           = mtc.bags_screen_l3
             ,   bags_screen_l4           = mtc.bags_screen_l4
             ,   bags_screen_l5           = mtc.bags_screen_l5
             ,   bags_not_screened        = mtc.bags_not_screened
             ,   local_bags               = mtc.local_bags
             ,   transfer_bags            = mtc.transfer_bags
             ,   auto_identifications     = mtc.auto_identifications
             ,   localbags_out_missed     = mtc.localbags_out_missed
             ,   transferbags_out_missed  = mtc.transferbags_out_missed
             ,   bags_screen_req          = mtc.bags_screen_req
             ,   source_unknown_bags      = mtc.source_unknown_bags
             where ec5.id < mtc.id
         when not matched then
              insert
             (   id
             ,   insertts
             ,   updatets
             ,   eventts
             ,   m5_periodid
             ,   h1_periodid
             ,   number_of_bags
             ,   deregistered_bags
             ,   crew_bags
             ,   rush_bags
             ,   non_conveyables
             ,   operator_delays
             ,   manual_identifications
             ,   system_time_oks
             ,   system_time_w1s
             ,   system_time_w2s
             ,   system_time_w3s
             ,   system_attributables
             ,   lost_bags
             ,   recovered_bags
             ,   bags_sorted_correctly
             ,   bags_not_sorted
             ,   bags_stored
             ,   bags_stored_outflow
             ,   sum_transport_exceptions
             ,   sum_operator_delays
             ,   sum_durations
             ,   dur_max_rp_pi
             ,   dur_max_pr_tr
             ,   dur_max_ti_pi
             ,   dur_max_tr_ti
             ,   dur_max_pir_pi
             ,   bags_in_early
             ,   bags_in_time
             ,   bags_in_critical
             ,   bags_in_toolate
             ,   bags_out_early
             ,   bags_out_ontime
             ,   bags_out_expedite
             ,   bags_out_late
             ,   bags_out_missed
             ,   bags_screen_l1
             ,   bags_screen_l2
             ,   bags_screen_l3
             ,   bags_screen_l4
             ,   bags_screen_l5
             ,   bags_not_screened
             ,   local_bags
             ,   transfer_bags
             ,   auto_identifications
             ,   localbags_out_missed
             ,   transferbags_out_missed
             ,   bags_screen_req
             ,   source_unknown_bags
             )
             values
             (   mtc.id
             ,   sys_extract_utc(systimestamp)
             ,   sys_extract_utc(systimestamp)
             ,   mtc.eventts
             ,   mtc.m5_periodid
             ,   mtc.h1_periodid
             ,   mtc.number_of_bags
             ,   mtc.deregistered_bags
             ,   mtc.crew_bags
             ,   mtc.rush_bags
             ,   mtc.non_conveyables
             ,   mtc.operator_delays
             ,   mtc.manual_identifications
             ,   mtc.system_time_oks
             ,   mtc.system_time_w1s
             ,   mtc.system_time_w2s
             ,   mtc.system_time_w3s
             ,   mtc.system_attributables
             ,   mtc.lost_bags
             ,   mtc.recovered_bags
             ,   mtc.bags_sorted_correctly
             ,   mtc.bags_not_sorted
             ,   mtc.bags_stored
             ,   mtc.bags_stored_outflow
             ,   mtc.sum_transport_exceptions
             ,   mtc.sum_operator_delays
             ,   mtc.sum_durations
             ,   mtc.dur_max_rp_pi
             ,   mtc.dur_max_pr_tr
             ,   mtc.dur_max_ti_pi
             ,   mtc.dur_max_tr_ti
             ,   mtc.dur_max_pir_pi
             ,   mtc.bags_in_early
             ,   mtc.bags_in_time
             ,   mtc.bags_in_critical
             ,   mtc.bags_in_toolate
             ,   mtc.bags_out_early
             ,   mtc.bags_out_ontime
             ,   mtc.bags_out_expedite
             ,   mtc.bags_out_late
             ,   mtc.bags_out_missed
             ,   mtc.bags_screen_l1
             ,   mtc.bags_screen_l2
             ,   mtc.bags_screen_l3
             ,   mtc.bags_screen_l4
             ,   mtc.bags_screen_l5
             ,   mtc.bags_not_screened
             ,   mtc.local_bags
             ,   mtc.transfer_bags
             ,   mtc.auto_identifications
             ,   mtc.localbags_out_missed
             ,   mtc.transferbags_out_missed
             ,   mtc.bags_screen_req
             ,   mtc.source_unknown_bags
          )
          log errors into err$_fact_bagsummaries_agg_m5 reject limit unlimited;
         
         l_count    := l_count + sql%rowcount;
         l_max_rows := l_max_rows - sql%rowcount;
         l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');

         commit;

      end loop;
      
      
      select *
      bulk collect into l_err
      from  err$_fact_bagsummaries_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_BAGSUMMARIES_AGG_M5 failed. '
                                                ||'ID='                    ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||l_err(i).m5_periodid
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_BAGSUMMARIES_AGG_M5 failed. '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure trackingreports_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.TRACKINGREPORTS_AGG_M5';
   
   type err_t is table of err$_fact_trackingrep_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_trackingreports_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  wc_trackingreport.eventts%type;
   l_from_dt   wc_trackingreport.eventts%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;

begin
   bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
    
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := nvl(l_mcg.max_measurements, 10000);
      
      select nvl(max(id), 0) into l_max_id from fact_trackingreports_agg_m5;
      select max(eventts) into l_from_dt from fact_trackingreports_agg_m5 where id = l_max_id;

      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_trackingreport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_trackingrep_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_trackingreports_agg_m5 ec5
         using ( select *
                 from ( select   max(wc.key)                                                  as id
                        ,        period.to_stamp(wc.eventts, 'M5')                            as eventts 
                        ,        period.periodid(wc.eventts, 'M5')                            as m5_periodid 
                        ,        period.periodid(wc.eventts, 'H1')                            as h1_periodid 
                        ,        nvl(dim.nodeid, -1)                                          as nodeid
                        ,        substr(trim(wc.areaid),1,5)                                  as areaid
                        ,        substr(trim(wc.zoneid),1,3)                                  as zoneid
                        ,        substr(nvl(trim(wc.equipmentid), '-'),1,3)                   as equipmentid
                        ,        dim.station_id, dimisc.customer_id                           as end_user_id
                        ,        dim.mark_code, dim.subjecttype
                        ,        dim.family, dim.subsystem_type, dim.process_step, dim.logistic_step_description, dim.stype
                        ,        wc.decisionlevel
                        ,        count(wc.key)                                                as number_of_trackingreports
                        ,        sum( case when l_faileddirection is null then 1 else 0 end ) as direction_ok
                        ,        sum( case when l_faileddirection is null then 0 else 1 end ) as direction_failed
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=CAPACITY TOO HIGH') > 0              then 1 else 0 end) as capacity_too_high
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NO DIRECTION - LM ROUTING') > 0      then 1 else 0 end) as no_direction_lm_routing
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NO ROUTING DEFAULT') > 0             then 1 else 0 end) as no_routing_default
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT ALLOWED - BLOCKED BY LM') > 0    then 1 else 0 end) as not_allowed_blocked_by_lm
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT ALLOWED - DIMENSIONS') > 0       then 1 else 0 end) as not_allowed_dimensions
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT ALLOWED - FLOW CONTROL') > 0     then 1 else 0 end) as not_allowed_flow_control
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT ALLOWED - FORCED DIRECTION') > 0 then 1 else 0 end) as not_allowed_forced_direction
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT ALLOWED - SECURITY') > 0         then 1 else 0 end) as not_allowed_security
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=NOT AVAILABLE OR FULL') > 0          then 1 else 0 end) as not_available_or_full
                        ,        sum( case when instr(upper(wc.l_faileddirection),'FAILEDREASON=TECHNICAL FAILURE') > 0              then 1 else 0 end) as technical_failure
                        from wc_trackingreport wc, dim_node_area_zone_equipment dim, dim_iscs dimisc
                        where wc.key         > l_max_id
                        and   wc.areaid      = dim.areaid
                        and   wc.zoneid      = dim.zoneid
                        and   wc.equipmentid = dim.equipmentid
                        and   wc.areaid      = dimisc.areaid(+)
                        and   wc.zoneid      = dimisc.zoneid(+)
                        and   wc.equipmentid = dimisc.equipmentid(+)
                        and   dim.ntype      ='DVT'
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(wc.eventts, 'M5')
                        ,        period.periodid(wc.eventts, 'M5')
                        ,        period.periodid(wc.eventts, 'H1')
                        ,        wc.decisionlevel
                        ,        dim.nodeid
                        ,        substr(trim(wc.areaid),1,5)
                        ,        substr(trim(wc.zoneid),1,3)
                        ,        substr(nvl(trim(wc.equipmentid), '-'),1,3)
                        ,        dim.station_id, dimisc.customer_id, dim.mark_code, dim.subjecttype
                        ,        dim.family, dim.subsystem_type, dim.process_step, dim.logistic_step_description, dim.stype
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid   = mtc.m5_periodid
                and ec5.decisionlevel = mtc.decisionlevel
                and ec5.nodeid        = mtc.nodeid
                and ec5.areaid        = mtc.areaid
                and ec5.zoneid        = mtc.zoneid
                and ec5.equipmentid   = mtc.equipmentid
               )
            when matched then
                 update
                 set id                           = mtc.id
                 ,   updatets                     = sys_extract_utc(systimestamp)
                 ,   number_of_trackingreports    = ec5.number_of_trackingreports + mtc.number_of_trackingreports
                 ,   direction_ok                 = ec5.direction_ok + mtc.direction_ok
                 ,   direction_failed             = ec5.direction_failed + mtc.direction_failed
                 ,   capacity_too_high            = ec5.capacity_too_high + mtc.capacity_too_high
                 ,   no_direction_lm_routing      = ec5.no_direction_lm_routing + mtc.no_direction_lm_routing
                 ,   no_routing_default           = ec5.no_routing_default + mtc.no_routing_default
                 ,   not_allowed_blocked_by_lm    = ec5.not_allowed_blocked_by_lm + mtc.not_allowed_blocked_by_lm
                 ,   not_allowed_dimensions       = ec5.not_allowed_dimensions + mtc.not_allowed_dimensions
                 ,   not_allowed_flow_control     = ec5.not_allowed_flow_control + mtc.not_allowed_flow_control
                 ,   not_allowed_forced_direction = ec5.not_allowed_forced_direction + mtc.not_allowed_forced_direction
                 ,   not_allowed_security         = ec5.not_allowed_security + mtc.not_allowed_security
                 ,   not_available_or_full        = ec5.not_available_or_full + mtc.not_available_or_full
                 ,   technical_failure            = ec5.technical_failure + mtc.technical_failure
                 where ec5.id < mtc.id
            when not matched then
                 insert ( id
                        , insertts
                        , updatets
                        , eventts
                        , m5_periodid
                        , h1_periodid
                        , nodeid
                        , areaid
                        , zoneid
                        , equipmentid
                        , station_id
                        , end_user_id
                        , mark_code
                        , subjecttype
                        , family
                        , subsystem_type
                        , process_step
                        , logistic_step_description
                        , stype
                        , decisionlevel
                        , number_of_trackingreports
                        , direction_ok
                        , direction_failed
                        , capacity_too_high
                        , no_direction_lm_routing
                        , no_routing_default
                        , not_allowed_blocked_by_lm
                        , not_allowed_dimensions
                        , not_allowed_flow_control
                        , not_allowed_forced_direction
                        , not_allowed_security
                        , not_available_or_full
                        , technical_failure
                        )
                 values
                        ( mtc.id
                        , sys_extract_utc(systimestamp)
                        , sys_extract_utc(systimestamp)
                        , mtc.eventts
                        , mtc.m5_periodid
                        , mtc.h1_periodid
                        , mtc.nodeid
                        , mtc.areaid
                        , mtc.zoneid
                        , mtc.equipmentid
                        , mtc.station_id
                        , mtc.end_user_id
                        , mtc.mark_code
                        , mtc.subjecttype
                        , mtc.family
                        , mtc.subsystem_type
                        , mtc.process_step
                        , mtc.logistic_step_description
                        , mtc.stype
                        , mtc.decisionlevel
                        , mtc.number_of_trackingreports
                        , mtc.direction_ok
                        , mtc.direction_failed
                        , mtc.capacity_too_high
                        , mtc.no_direction_lm_routing
                        , mtc.no_routing_default
                        , mtc.not_allowed_blocked_by_lm
                        , mtc.not_allowed_dimensions
                        , mtc.not_allowed_flow_control
                        , mtc.not_allowed_forced_direction
                        , mtc.not_allowed_security
                        , mtc.not_available_or_full
                        , mtc.technical_failure
                        )
                log errors into err$_fact_trackingrep_agg_m5 reject limit unlimited;
       
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
       
      select *
      bulk collect into l_err
      from   err$_fact_trackingrep_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_TRACKINGREPORTS_AGG_M5 failed. '
                                                ||'ID='                    ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',DECISIONLEVEL='        ||to_char(l_err(i).decisionlevel)
                                                ||',NODEID='               ||to_char(l_err(i).nodeid)
                                                ||',AREAID='               ||to_char(l_err(i).areaid)
                                                ||',ZONEID='               ||to_char(l_err(i).zoneid)
                                                ||',EQUIPMENTID='          ||to_char(l_err(i).equipmentid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_TRACKINGREPORTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure extmetrics_agg_m5
is
   l_con_proc         constant varchar2(61) := g_con_package||'.EXTMETRICS_AGG_M5';
   
   type err_t is table of err$_fact_extmetrics_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_max_id           fact_extmetrics_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_max_rows         metric_config.max_measurements%type;
   l_from_dt          fact_external_metrics.eventts%type;
   l_until_dt         fact_external_metrics.eventts%type;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   l_count            number := 0;
   l_msg              viu_info_logs.additional_data%type;


begin
   bpi_trace.enter_module( i_module => l_con_proc );

  begin
    begin
      select * into l_mcg from metric_config where upper(metric_procedure) = upper(l_con_proc);
    exception
      when others then l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc, viu_info.c_severity_warning, null
                            , l_con_proc||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).'
                            );
    else

      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc, l_con_proc||', PERIOD_TYPE must be configured as M5');
      end if;

      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                          );

      l_max_rows := l_mcg.max_measurements;

      select nvl(max(id), 0) into l_max_id from fact_extmetrics_agg_m5;
      select max(eventts) into l_from_dt from fact_extmetrics_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   fact_external_metrics;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
      delete from err$_fact_extmetrics_agg_m5;
      while l_max_rows > 0  and l_from_dt < l_until_dt
      loop
         merge into fact_extmetrics_agg_m5 ec5
         using ( select *
                 from ( select max(id)                                                        as id
                        ,      period.to_stamp(m5_periodid, 'M5')                             as eventts 
                        ,      m5_periodid 
                        ,      period.periodid(m5_periodid, 'H1')                             as h1_periodid 
                        ,      statisticalid
                        ,      family
                        ,      subsystem_type
                        ,      subjecttype
                        ,      subjectid
                        ,      areaid
                        ,      zoneid
                        ,      equipmentid
                        ,      sampletype
                        ,      max(process_step)          keep (dense_rank last order by id)  as process_step  
                        ,      max(mark_code)             keep (dense_rank last order by id)  as mark_code
                        ,      max(statistical)           keep (dense_rank last order by id)  as statistical
                        ,      max(statistical_group)     keep (dense_rank last order by id)  as statistical_group
                        ,      max(statistical_subgroup)  keep (dense_rank last order by id)  as statistical_subgroup
                        ,      max(unit)                  keep (dense_rank last order by id)  as unit
                        ,      min(value)                                                     as min_value
                        ,      max(value)                                                     as max_value
                        ,      sum(value)                                                     as sum_value
                        ,      count(id)                                                      as number_of_messages
                        from  fact_external_metrics
                        where id > l_max_id
                        and   eventts >= l_from_dt
                        and   eventts <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by m5_periodid
                        ,        statisticalid
                        ,        family
                        ,        subsystem_type
                        ,        subjecttype
                        ,        subjectid
                        ,        areaid
                        ,        zoneid
                        ,        equipmentid
                        ,        sampletype
                        order by id
                 )
            where rownum <= l_max_rows
         ) mtc
      on (     ec5.m5_periodid    = mtc.m5_periodid
           and ec5.statisticalid  = mtc.statisticalid
           and ec5.family         = mtc.family
           and ec5.subsystem_type = mtc.subsystem_type
           and ec5.subjecttype    = mtc.subjecttype
           and ec5.subjectid      = mtc.subjectid
           and ec5.areaid         = mtc.areaid
           and ec5.zoneid         = mtc.zoneid
           and ec5.equipmentid    = mtc.equipmentid
           and ec5.sampletype     = mtc.sampletype
         )
      when matched then
           update
           set id                 = mtc.id
           ,   updatets           = sys_extract_utc(systimestamp)
           ,   min_value          = least(ec5.min_value, mtc.min_value)
           ,   max_value          = greatest(ec5.max_value, mtc.max_value)
           ,   sum_value          = ec5.sum_value + mtc.sum_value
           ,   number_of_messages = ec5.number_of_messages + mtc.number_of_messages
          where  ec5.id < mtc.id
      when not matched then
           insert ( id
                  , insertts
                  , updatets
                  , eventts
                  , m5_periodid
                  , h1_periodid
                  , statisticalid
                  , family
                  , subsystem_type
                  , subjecttype
                  , subjectid
                  , areaid
                  , zoneid
                  , equipmentid
                  , sampletype
                  , process_step
                  , mark_code
                  , statistical
                  , statistical_group
                  , statistical_subgroup
                  , unit
                  , min_value
                  , max_value
                  , sum_value
                  , number_of_messages
                  )
           values( mtc.id
                 , sys_extract_utc(systimestamp)
                 , sys_extract_utc(systimestamp)
                 , mtc.eventts
                 , mtc.m5_periodid
                 , mtc.h1_periodid
                 , mtc.statisticalid
                 , mtc.family
                 , mtc.subsystem_type
                 , mtc.subjecttype
                 , mtc.subjectid
                 , mtc.areaid
                 , mtc.zoneid
                 , mtc.equipmentid
                 , mtc.sampletype
                 , mtc.process_step
                 , mtc.mark_code
                 , mtc.statistical
                 , mtc.statistical_group
                 , mtc.statistical_subgroup
                 , mtc.unit
                 , mtc.min_value
                 , mtc.max_value
                 , mtc.sum_value
                 , mtc.number_of_messages
                 )
         log errors into err$_fact_extmetrics_agg_m5 reject limit unlimited;
         
         l_count    := l_count + sql%rowcount;
         l_max_rows := l_max_rows - sql%rowcount;
         l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
        
         commit;

      end loop;
      
      select *
      bulk collect into l_err
      from   err$_fact_extmetrics_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc
                                , i_msg      =>   l_con_proc||' ERROR. Insert/update FACT_EXTMETRICS_AGG_M5 failed. '
                                                ||'ID='                     ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='           ||to_char(l_err(i).m5_periodid)
                                                ||',STATISTICALID='         ||to_char(l_err(i).statisticalid)
                                                ||',FAMILY='                ||to_char(l_err(i).family)
                                                ||',SUBSYSTEM_TYPE='        ||to_char(l_err(i).subsystem_type)
                                                ||',SUBJECTTYPE='           ||to_char(l_err(i).subjecttype)
                                                ||',SUBJECTID='             ||to_char(l_err(i).subjectid)
                                                ||',AREAID='                ||to_char(l_err(i).areaid)
                                                ||',ZONEID='                ||to_char(l_err(i).zoneid)
                                                ||',EQUIPMENTID='           ||to_char(l_err(i).equipmentid)
                                                ||',SAMPLETYPE='            ||to_char(l_err(i).sampletype)
                                                ||'. '                      ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;

      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc);
      end if;
      
      viu_info.operator_info( i_ifo_nr            => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure => l_con_proc
                            , i_severity          => viu_info.c_severity_notification
                            , i_info_arguments    => null
                            , i_additional_data   => l_con_proc||' finished successfully. Processed '||to_char(l_count)||' Metrics. '
                                                               ||to_char(l_err.count)||' error Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc||' ERROR. Insert/update FACT_EXTMETRICS_AGG_M5 failed. '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc );
end;

procedure traveltimes_agg_m5 is
   l_con_proc_name constant varchar2(61) := g_con_package||'.TRAVELTIMES_AGG_M5';
   
   type err_t is table of err$_fact_traveltimes_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_traveltimes_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         fact_travel_time_summaries.end_eventts%type;
   l_from_dt          fact_travel_time_summaries.end_eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
      
      select nvl(max(id), 0) into l_max_id from fact_traveltimes_agg_m5;
      select max(eventts) into l_from_dt from fact_traveltimes_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(end_eventts)
        into   l_from_dt
        from   fact_travel_time_summaries;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_traveltimes_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         l_err.delete;
         merge into fact_traveltimes_agg_m5 ec5
         using ( select *
                 from (select max(id)                            as id
                       ,      sys_extract_utc(systimestamp)      as insertts
                       ,      sys_extract_utc(systimestamp)      as updatets
                       ,      period.to_stamp(end_eventts, 'M5') as eventts
                       ,      m5_periodid
                       ,      h1_periodid
                       ,      start_node
                       ,      end_node
                       ,      min(duration)                      as min_duration
                       ,      max(duration)                      as max_duration
                       ,      sum(duration)                      as sum_duration
                       ,      count(id)                          as counted
                       from   fact_travel_time_summaries
                       where  id           >  l_max_id
                       and    end_eventts  >= l_from_dt
                       and    end_eventts  <  l_from_dt + numtodsinterval(1, 'HOUR')
                       group by period.to_stamp(end_eventts, 'M5')
                       ,        m5_periodid
                       ,        h1_periodid
                       ,        start_node
                       ,        end_node
                       order by id
                      )
                   where rownum <= l_max_rows
               ) mtc
         on (
                  ec5.m5_periodid = mtc.m5_periodid
              and ec5.h1_periodid = mtc.h1_periodid
              and ec5.start_node  = mtc.start_node
              and ec5.end_node    = mtc.end_node
            )
         when matched then
            update
            set     id           = mtc.id
            ,       updatets     = sys_extract_utc(systimestamp)
            ,       min_duration = least(ec5.min_duration, mtc.min_duration)
            ,       max_duration = greatest(ec5.max_duration, mtc.max_duration)
            ,       sum_duration = ec5.sum_duration + mtc.sum_duration
            ,       counted      = ec5.counted + mtc.counted
            where   ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , start_node
                   , end_node
                   , min_duration
                   , max_duration
                   , sum_duration
                   , counted
                   )
            values ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.start_node
                   , mtc.end_node
                   , mtc.min_duration
                   , mtc.max_duration
                   , mtc.sum_duration
                   , mtc.counted )
            log errors into err$_fact_traveltimes_agg_m5 reject limit unlimited;
        
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_traveltimes_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_TRAVELTIMES_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',H1_PERIODID='          ||to_char(l_err(i).h1_periodid)
                                                ||',START_NODE='           ||to_char(l_err(i).start_node)
                                                ||',END_NODE='             ||to_char(l_err(i).end_node)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_TRAVELTIMES_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure mcscanresults_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.MCSCANRESULTS_AGG_M5';
   
   type err_t is table of err$_fact_mcscanresults_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_mcscanresults_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         wc_trackingreport.eventts%type;
   l_from_dt          wc_trackingreport.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;
begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;
  
      select nvl(max(id), 0) into l_max_id from fact_mcscanresults_agg_m5;
      select max(eventts) into l_from_dt from fact_mcscanresults_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_taskreport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_mcscanresults_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_mcscanresults_agg_m5 ec5
         using ( select *
                 from (select max(wc.key)                    as id
                       ,      sys_extract_utc(systimestamp)  as insertts
                       ,      sys_extract_utc(systimestamp)  as updatets
                       ,      period.to_stamp(eventts, 'M5') as eventts 
                       ,      period.periodid(eventts, 'M5') as m5_periodid 
                       ,      period.periodid(eventts, 'H1') as h1_periodid 
                       ,      to_number(wc.stationid)        as station_id
                       ,      dim.end_user_id                as end_user_id
                       ,      count(wc.key)                  as totalhandled
                       ,      sum( case wc.tasktype when     'LinkToFlight'       then 1 else 0 end ) as linktoflight
                       ,      sum( case wc.tasktype when     'LinkToHandler'      then 1 else 0 end ) as linktohandler
                       ,      sum( case wc.tasktype when     'SpecialDestination' then 1 else 0 end ) as special_destination
                       ,      sum( case wc.tasktype when     'Retag'              then 1 else 0 end ) as tags_reprinted
                       ,      sum( case wc.method   when     'MANUAL'             then 1 else 0 end ) as manual_count
                       ,      sum( case wc.method   when     'ENTERED'            then 1 else 0 end ) as entered_count
                       from   wc_taskreport wc, dim_stations dim
                       where  wc.key       > l_max_id
                       and    to_number(wc.stationid) = dim.id
                       and    dim.stype    = 'ManualEncoding'
                       and    eventts      >= l_from_dt
                       and    eventts      <  l_from_dt + numtodsinterval(1, 'HOUR')
                       group by period.to_stamp(eventts, 'M5')
                       ,        period.periodid(eventts, 'M5')
                       ,        period.periodid(eventts, 'H1')
                       ,        wc.stationid
                       ,        dim.end_user_id
                       order by id
                      )
                 where rownum <= l_max_rows
               ) mtc
         on (     ec5.m5_periodid = mtc.m5_periodid
              and ec5.station_id  = mtc.station_id
              and ec5.h1_periodid = mtc.h1_periodid
              and ec5.end_user_id = mtc.end_user_id
            )
         when matched then
            update
            set       id                   = mtc.id
            ,         updatets             = sys_extract_utc(systimestamp)
            ,         totalhandled         = ec5.totalhandled + mtc.totalhandled
            ,         linktoflight         = ec5.linktoflight  + mtc.linktoflight
            ,         linktohandler        = ec5.linktohandler + mtc.linktohandler
            ,         special_destination  = ec5.special_destination + mtc.special_destination
            ,         tags_reprinted       = ec5.tags_reprinted + mtc.tags_reprinted
            ,         manual_count         = ec5.manual_count + mtc.manual_count
            ,         entered_count        = ec5.entered_count + mtc.entered_count
            where     ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , station_id
                   , end_user_id
                   , totalhandled
                   , linktoflight
                   , linktohandler
                   , special_destination
                   , tags_reprinted
                   , manual_count
                   , entered_count
                   )
            values ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.station_id
                   , mtc.end_user_id
                   , mtc.totalhandled
                   , mtc.linktoflight
                   , mtc.linktohandler
                   , mtc.special_destination
                   , mtc.tags_reprinted
                   , mtc.manual_count
                   , mtc.entered_count
                   )
            log errors into err$_fact_mcscanresults_agg_m5 reject limit unlimited;
                   
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_mcscanresults_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_MCSCANRESULTS_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',STATION_ID='           ||to_char(l_err(i).station_id)
                                                ||',H1_PERIODID='          ||to_char(l_err(i).h1_periodid)
                                                ||',END_USER_ID='          ||to_char(l_err(i).end_user_id)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;

      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                         );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_MCSCANRESULTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure screen_reports_agg_m5 is
   l_con_proc_name constant varchar2(61) := g_con_package||'.SCREEN_REPORTS_AGG_M5';

   type err_t is table of err$_fact_screen_report_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            pls_integer := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id           fact_screen_reports_agg_m5.id%type;
   l_mcg              metric_config%rowtype;
   l_until_dt         fact_screening_results_reports.eventts%type;
   l_from_dt          fact_screening_results_reports.eventts%type;
   l_max_rows         metric_config.max_measurements%type;
   l_msg              viu_info_logs.additional_data%type;

begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      
      l_current_time := sys_extract_utc(systimestamp);
      
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := l_mcg.max_measurements;

      select nvl(max(id), 0) into l_max_id from fact_screen_reports_agg_m5;
      select max(eventts) into l_from_dt from fact_screen_reports_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   fact_screening_results_reports;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_screen_report_agg_m5;
      
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_screen_reports_agg_m5 ec5
         using ( select *
                 from (select max(wc.id)                        as id
                       ,      period.to_stamp(wc.eventts, 'M5') as eventts
                       ,      period.periodid(wc.eventts, 'M5') as m5_periodid
                       ,      period.periodid(wc.eventts, 'H1') as h1_periodid
                       ,      screening_process_id
                       ,      screening_process_name
                       ,      dim.nodeid, dim.station_id
                       ,      dim.end_user_id
                       ,      dim.stype, dim.mark_code
                       ,      dim.subsystem_type, dim.process_step
                       ,      sum(wc.bags_arrived_at_screening) as total_tracked
                       ,      sum(wc.l1_cleared)                as l1_cleared
                       ,      sum(wc.l1_reject)                 as l1_reject
                       ,      sum(wc.l1_unknown )               as l1_unknown
                       ,      sum(wc.l2_cleared)                as l2_cleared
                       ,      sum(wc.l2_reject)                 as l2_reject
                       ,      sum(wc.l2_unknown )               as l2_unknown
                       ,      sum(wc.l2_operator_time_out )     as l2_operator_time_out
                       ,      sum(wc.machine_fault)             as machine_fault
                       ,      sum(wc.sent_to_l3_while_cleared)  as sent_to_l3_while_cleared
                       ,      sum(wc.bags_deregistered)         as bags_deregistered
                       ,      sum(wc.l3_cleared)                as l3_cleared
                       ,      sum(wc.l3_reject)                 as l3_reject
                       ,      sum(wc.l3_unknown )               as l3_unknown
                       from ( select id
                              ,      eventts
                              ,      screening_process_id
                              ,      screening_process_name
                              ,      screening_node
                              ,      bags_arrived_at_screening
                              ,      case when screening_level='1' then 1                  else 0 end as l1_reported 
                              ,      case when screening_level='1' then cleared            else 0 end as l1_cleared
                              ,      case when screening_level='1' then uncleared + reject else 0 end as l1_reject
                              ,      case when screening_level='1' then nodecision         else 0 end as l1_unknown
                              ,      case when screening_level='2' then cleared            else 0 end as l2_cleared
                              ,      case when screening_level='2' then uncleared + reject else 0 end as l2_reject
                              ,      case when screening_level='2' then nodecision         else 0 end as l2_unknown
                              ,      case when screening_level='2' then operator_time_out  else 0 end as l2_operator_time_out
                              ,      case when ((screening_level='1' and required_level='1')
                                             or (screening_level='3' and required_level='3'))
                                                                   then nodecision         else 0 end as machine_fault
                              ,      sent_to_l3_while_cleared
                              ,      bags_deregistered
                              ,      case when screening_level='3' then cleared            else 0 end as l3_cleared
                              ,      case when screening_level='3' then uncleared + reject else 0 end as l3_reject
                              ,      case when screening_level='3' then nodecision         else 0 end as l3_unknown
                              from fact_screening_results_reports
                            ) wc, dim_node_area_zone_equipment dim
                       where wc.id               > l_max_id
                       and   wc.screening_node   = dim.nodeid
                       and   eventts             >= l_from_dt
                       and   eventts             <  l_from_dt + numtodsinterval(1, 'HOUR')
                       group by  period.to_stamp(wc.eventts, 'M5')
                       ,         period.periodid(wc.eventts, 'M5')
                       ,         period.periodid(wc.eventts, 'H1')
                       ,         wc.screening_process_id
                       ,         wc.screening_process_name
                       ,         dim.nodeid
                       ,         dim.station_id
                       ,         dim.end_user_id
                       ,         dim.stype
                       ,         dim.mark_code
                       ,         dim.subsystem_type
                       ,         dim.process_step
                       order by  id
                       )
                 where rownum <= l_max_rows
               ) mtc
         on (
                  ec5.m5_periodid = mtc.m5_periodid
              and ec5.nodeid      = mtc.nodeid
              and (    ec5.screening_process_id  is null
                   and mtc.screening_process_id  is null
                   or  ec5.screening_process_id = mtc.screening_process_id
                  )
            )
         when matched then
            update
            set         id                       = mtc.id
            ,           updatets                 = sys_extract_utc(systimestamp)
            ,           total_tracked            = ec5.total_tracked + mtc.total_tracked
            ,           l1_cleared               = ec5.l1_cleared + mtc.l1_cleared
            ,           l1_reject                = ec5.l1_reject + mtc.l1_reject
            ,           l1_unknown               = ec5.l1_unknown + mtc.l1_unknown
            ,           l2_cleared               = ec5.l2_cleared + mtc.l2_cleared
            ,           l2_reject                = ec5.l2_reject + mtc.l2_reject
            ,           l2_unknown               = ec5.l2_unknown + mtc.l2_unknown
            ,           l2_operator_time_out     = ec5.l2_operator_time_out + mtc.l2_operator_time_out
            ,           machine_fault            = ec5.machine_fault + mtc.machine_fault
            ,           sent_to_l3_while_cleared = ec5.sent_to_l3_while_cleared + mtc.sent_to_l3_while_cleared
            ,           bags_deregistered        = ec5.bags_deregistered + mtc.bags_deregistered
            ,           l3_cleared               = ec5.l3_cleared + mtc.l3_cleared
            ,           l3_reject                = ec5.l3_reject + mtc.l3_reject
            ,           l3_unknown               = ec5.l3_unknown + mtc.l3_unknown
            where     ec5.id < mtc.id
         when not matched then
            insert ( id
                   , insertts
                   , updatets
                   , eventts
                   , m5_periodid
                   , h1_periodid
                   , screening_process_id
                   , screening_process_name
                   , nodeid
                   , station_id
                   , end_user_id
                   , stype
                   , mark_code
                   , subsystem_type
                   , process_step
                   , total_tracked
                   , l1_cleared
                   , l1_reject
                   , l1_unknown
                   , l2_cleared
                   , l2_reject
                   , l2_unknown
                   , l2_operator_time_out
                   , machine_fault
                   , sent_to_l3_while_cleared
                   , bags_deregistered
                   , l3_cleared
                   , l3_reject
                   , l3_unknown
                   )
            values ( mtc.id
                   , sys_extract_utc(systimestamp)
                   , sys_extract_utc(systimestamp)
                   , mtc.eventts
                   , mtc.m5_periodid
                   , mtc.h1_periodid
                   , mtc.screening_process_id
                   , mtc.screening_process_name
                   , mtc.nodeid
                   , mtc.station_id
                   , mtc.end_user_id
                   , mtc.stype
                   , mtc.mark_code
                   , mtc.subsystem_type
                   , mtc.process_step
                   , mtc.total_tracked
                   , mtc.l1_cleared
                   , mtc.l1_reject
                   , mtc.l1_unknown
                   , mtc.l2_cleared
                   , mtc.l2_reject
                   , mtc.l2_unknown
                   , mtc.l2_operator_time_out
                   , mtc.machine_fault
                   , mtc.sent_to_l3_while_cleared
                   , mtc.bags_deregistered
                   , mtc.l3_cleared
                   , mtc.l3_reject
                   , mtc.l3_unknown )
            log errors into err$_fact_screen_report_agg_m5 reject limit unlimited;
        
        l_count    := l_count + sql%rowcount;
        l_max_rows := l_max_rows - sql%rowcount;
        l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
      end loop;
      
      
      select *
      bulk collect into l_err
      from   err$_fact_screen_report_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_SCREEN_REPORTS_AGG_M5 failed. '
                                                ||' ID='                   ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',NODEID='               ||to_char(l_err(i).nodeid)
                                                ||',SCREENING_PROCESS_ID=' ||to_char(l_err(i).screening_process_id)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_SCREEN_REPORTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;


procedure ldrtrackreports_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.LDRTRACKREPORTS_AGG_M5';
   
   type err_t is table of err$_fact_ldrtrackrep_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
   
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_ldrtrackreports_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  wc_trackingreport.eventts%type;
   l_from_dt   wc_trackingreport.eventts%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;

begin
   bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
      select * into l_mcg
      from   metric_config
      where  upper(metric_procedure) = upper(l_con_proc_name);
    exception
      when others then
        l_mcg.status := 0;
    end;
    
    if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
    
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := nvl(l_mcg.max_measurements, 10000);

      select nvl(max(id), 0) into l_max_id from fact_ldrtrackreports_agg_m5;
      select max(eventts) into l_from_dt from fact_ldrtrackreports_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_trackingreport;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_ldrtrackrep_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_ldrtrackreports_agg_m5 ec5
         using ( select *
                 from ( select   max(wc.key)                                                  as id
                        ,        period.to_stamp(wc.eventts, 'M5')                            as eventts
                        ,        period.periodid(wc.eventts, 'M5')                            as m5_periodid
                        ,        period.periodid(wc.eventts, 'H1')                            as h1_periodid
                        ,        nvl(dim.nodeid, -1)                                         as nodeid
                        ,        substr(trim(wc.areaid),1,5)                                  as areaid
                        ,        substr(trim(wc.zoneid),1,3)                                  as zoneid
                        ,        substr(nvl(trim(wc.equipmentid), '-'),1,3)                   as equipmentid
                        ,        dim.end_user_id                                              as end_user_id
                        ,        dim.mark_code
                        ,        dim.process_step, dim.stype, dimn.ps_emu_type
                        ,        count(wc.key)                                                as number_of_trackingreports
                        ,        sum( case when l_faileddirection is null then 1 else 0 end ) as direction_ok
                        ,        sum( case when l_faileddirection is null then 0 else 1 end ) as direction_failed
                        from wc_trackingreport wc, dim_node_area_zone_equipment dim, dim_nodes dimn
                        where wc.key         > l_max_id
                        and   wc.areaid            = dim.areaid
                        and   wc.zoneid            = dim.zoneid
                        and   wc.equipmentid       = dim.equipmentid
                        and   dim.isc_id_reporting = dimn.isc_id_reporting
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(wc.eventts, 'M5')
                        ,        period.periodid(wc.eventts, 'M5')
                        ,        period.periodid(wc.eventts, 'H1')
                        ,        dim.nodeid
                        ,        substr(trim(wc.areaid),1,5)
                        ,        substr(trim(wc.zoneid),1,3)
                        ,        substr(nvl(trim(wc.equipmentid), '-'),1,3)
                        ,        dim.end_user_id, dim.mark_code
                        ,        dim.process_step, dim.stype,  dimn.ps_emu_type
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid   = mtc.m5_periodid
                and ec5.nodeid        = mtc.nodeid
                and ec5.areaid        = mtc.areaid
                and ec5.zoneid        = mtc.zoneid
                and ec5.equipmentid   = mtc.equipmentid
               )
            when matched then
                 update
                 set id                           = mtc.id
                 ,   updatets                     = sys_extract_utc(systimestamp)
                 ,   number_of_trackingreports    = ec5.number_of_trackingreports + mtc.number_of_trackingreports
                 ,   direction_ok                 = ec5.direction_ok + mtc.direction_ok
                 ,   direction_failed             = ec5.direction_failed + mtc.direction_failed
                 where ec5.id < mtc.id
            when not matched then
                 insert ( id
                        , insertts
                        , updatets
                        , eventts
                        , m5_periodid
                        , h1_periodid
                        , nodeid
                        , areaid
                        , zoneid
                        , equipmentid
                        , end_user_id
                        , mark_code
                        , process_step
                        , stype
                        , ps_emu_type
                        , number_of_trackingreports
                        , direction_ok
                        , direction_failed
                        )
                 values
                        ( mtc.id
                        , sys_extract_utc(systimestamp)
                        , sys_extract_utc(systimestamp)
                        , mtc.eventts
                        , mtc.m5_periodid
                        , mtc.h1_periodid
                        , mtc.nodeid
                        , mtc.areaid
                        , mtc.zoneid
                        , mtc.equipmentid
                        , mtc.end_user_id
                        , mtc.mark_code
                        , mtc.process_step
                        , mtc.stype
                        , mtc.ps_emu_type
                        , mtc.number_of_trackingreports
                        , mtc.direction_ok
                        , mtc.direction_failed
                        )
                log errors into err$_fact_ldrtrackrep_agg_m5 reject limit unlimited;
       
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
       
      select *
      bulk collect into l_err
      from   err$_fact_ldrtrackrep_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name            ||' ERROR. Insert/update FACT_LDRTRACKREPORTS_AGG_M5 failed. '
                                                ||'ID='                    ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='          ||to_char(l_err(i).m5_periodid)
                                                ||',NODEID='               ||to_char(l_err(i).nodeid)
                                                ||',AREAID='               ||to_char(l_err(i).areaid)
                                                ||',ZONEID='               ||to_char(l_err(i).zoneid)
                                                ||',EQUIPMENTID='          ||to_char(l_err(i).equipmentid)
                                                ||', '                     ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_LDRTRACKREPORTS_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;

procedure flighttrend_agg_m5
is
   l_con_proc_name constant varchar2(61) := g_con_package||'.FLIGHTTREND_AGG_M5';
  
   type err_t is table of err$_fact_flight_trend_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
  
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_flight_trend_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  wc_processplanmessage.eventts%type;
   l_from_dt   wc_processplanmessage.eventts%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;
  
     
  begin
    bpi_trace.enter_module( i_module => l_con_proc_name );
  
    begin
      begin
        select * into l_mcg
        from metric_config
        where upper(metric_procedure) = upper(l_con_proc_name);
      exception
      when others then
           l_mcg.status := 0;
      end;
      if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
    
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := nvl(l_mcg.max_measurements, 10000);
      
      select nvl(max(id), 0) into l_max_id from fact_flight_trend_agg_m5;
      select max(eventts) into l_from_dt from fact_flight_trend_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_processplanmessage;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
                         
      delete from err$_fact_flight_trend_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_flight_trend_agg_m5 ec5
         using ( select *
                 from ( select max(key) as id
                        ,      period.to_stamp(eventts, 'M5')                            as eventts
                        ,      period.periodid(eventts, 'M5')                            as m5_periodid
                        ,      period.periodid(eventts, 'H1')                            as h1_periodid
                        ,      flights.flightnr(trim(wc.airline)||trim(wc.flightnumber)) as flightnr
                        ,      wc.scheduleddatetime                                      as scheduled_flight_time
                        ,      count(wc.key)                                             as number_of_flight_updates
                        from wc_processplanmessage wc
                        where key > l_max_id
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(eventts, 'M5')
                        ,        period.periodid(eventts, 'M5')
                        ,        period.periodid(eventts, 'H1')
                        ,        flights.flightnr(trim(wc.airline)||trim(wc.flightnumber))
                        ,        wc.scheduleddatetime
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid   = mtc.m5_periodid
               )
            when matched then
                 update
                 set id                           = mtc.id
                 ,   updatets                     = sys_extract_utc(systimestamp)
                 ,   number_of_flight_updates     = mtc.number_of_flight_updates
                 where ec5.id < mtc.id
                 and   ec5.m5_periodid                  = mtc.m5_periodid
                 and nvl(ec5.flightnr,'-')              = nvl(mtc.flightnr,'-')
                 and nvl(ec5.scheduled_flight_time,'-') = nvl(mtc.scheduled_flight_time,'-')
            when not matched then
                 insert
                 ( id
                 , insertts
                 , updatets
                 , eventts
                 , m5_periodid
                 , h1_periodid
                 , flightnr
                 , scheduled_flight_time
                 , number_of_flight_updates )
                 values
                 ( mtc.id
                 , sys_extract_utc(systimestamp)
                 , sys_extract_utc(systimestamp)
                 , mtc.eventts
                 , mtc.m5_periodid
                 , mtc.h1_periodid
                 , nvl(mtc.flightnr,'-')
                 , nvl(mtc.scheduled_flight_time,'-')
                 , mtc.number_of_flight_updates )
             log errors into err$_fact_flight_trend_agg_m5 reject limit unlimited;
       
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
       
      select *
      bulk collect into l_err
      from   err$_fact_flight_trend_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name              ||' ERROR. Insert/update FACT_FLIGHT_TREND_AGG_M5 failed. '
                                                ||'ID='                      ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='            ||to_char(l_err(i).m5_periodid)
                                                ||',FLIGHTNR='               ||to_char(l_err(i).flightnr)
                                                ||',SCHEDULED_FLIGHT_TIME='  ||to_char(l_err(i).scheduled_flight_time)
                                                ||', '                       ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_FLIGHT_TREND_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;
   
procedure bsmtraffic_agg_m5
is
  l_con_proc_name constant varchar2(61) := g_con_package||'.BSMTRAFFIC_AGG_M5';
  
  type err_t is table of err$_fact_bsm_traffic_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
  
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_bsm_traffic_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  wc_packagedata.eventts%type;
   l_from_dt   wc_packagedata.eventts%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;
  
  begin
    bpi_trace.enter_module( i_module => l_con_proc_name );
  
    begin
      begin
        select * into l_mcg
        from metric_config
        where upper(metric_procedure) = upper(l_con_proc_name);
      exception
      when others then
           l_mcg.status := 0;
      end;
      if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := nvl(l_mcg.max_measurements, 10000);
      
      select nvl(max(id), 0) into l_max_id from fact_bsm_traffic_agg_m5;
      select max(eventts) into l_from_dt from fact_bsm_traffic_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_packagedata;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );
 
      delete from err$_fact_bsm_traffic_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_bsm_traffic_agg_m5 ec5
         using ( select *
                 from ( select max(key) as id
                        ,      period.to_stamp(eventts, 'M5') as eventts
                        ,      period.periodid(eventts, 'M5') as m5_periodid
                        ,      period.periodid(eventts, 'H1') as h1_periodid
                        ,      flights.flightnr(trim(wc.depairline) || trim(wc.depflight)) as flightnr
                        ,      wc.depflightdate as scheduled_flight_time
                        ,      count(wc.key) as number_of_bsm_updates
                        from wc_packagedata wc
                        where key > l_max_id
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        group by period.to_stamp(eventts, 'M5')
                        ,        period.periodid(eventts, 'M5')
                        ,        period.periodid(eventts, 'H1')
                        ,        flights.flightnr(trim(wc.depairline) || trim(wc.depflight))
                        ,        wc.depflightdate
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid   = mtc.m5_periodid
               )
            when matched then
                 update
                 set id                           = mtc.id
                 ,   updatets                     = sys_extract_utc(systimestamp)
                 ,   number_of_bsm_updates        = mtc.number_of_bsm_updates
                 where ec5.id < mtc.id
                 and   ec5.m5_periodid                  = mtc.m5_periodid
                 and nvl(ec5.flightnr,'-')              = nvl(mtc.flightnr,'-')
                 and nvl(ec5.scheduled_flight_time,'-') = nvl(mtc.scheduled_flight_time,'-')
            when not matched then
                 insert
                 ( id
                 , insertts
                 , updatets
                 , eventts
                 , m5_periodid
                 , h1_periodid
                 , flightnr
                 , scheduled_flight_time
                 , number_of_bsm_updates )
                 values
                 ( mtc.id
                 , sys_extract_utc(systimestamp)
                 , sys_extract_utc(systimestamp)
                 , mtc.eventts
                 , mtc.m5_periodid
                 , mtc.h1_periodid
                 , nvl(mtc.flightnr,'-')
                 , nvl(mtc.scheduled_flight_time,'-')
                 , mtc.number_of_bsm_updates )
             log errors into err$_fact_bsm_traffic_agg_m5 reject limit unlimited;
       
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
       
      select *
      bulk collect into l_err
      from   err$_fact_bsm_traffic_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name              ||' ERROR. Insert/update FACT_BSM_TRAFFIC_AGG_M5 failed. '
                                                ||'ID='                      ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='            ||to_char(l_err(i).m5_periodid)
                                                ||',FLIGHTNR='               ||to_char(l_err(i).flightnr)
                                                ||',SCHEDULED_FLIGHT_TIME='  ||to_char(l_err(i).scheduled_flight_time)
                                                ||', '                       ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_BSM_TRAFFIC_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;
         
procedure bpmtraffic_agg_m5
is
  l_con_proc_name constant varchar2(61) := g_con_package||'.BPMTRAFFIC_AGG_M5';
  
   type err_t is table of err$_fact_bpm_traffic_agg_m5%rowtype index by pls_integer;
   l_err              err_t;
  
   l_count            number := 0;
   l_lag_time         timestamp;
   l_exclude_time     timestamp;
   l_current_time     timestamp;
   
   l_max_id    fact_bpm_traffic_agg_m5.id%type;
   l_mcg       metric_config%rowtype;
   l_until_dt  wc_iata.eventts%type;
   l_from_dt   wc_iata.eventts%type;
   l_max_rows  metric_config.max_measurements%type;
   l_msg       viu_info_logs.additional_data%type;
   
  cursor c_metrics(c_id number, c_until timestamp, c_maxrecs number) is
     select *
      from (select max(key) as id,
                   period.to_stamp(eventts, 'M5') as eventts 
                  ,
                   period.periodid(eventts, 'M5') as m5_periodid 
                  ,
                   period.periodid(eventts, 'H1') as h1_periodid 
                  ,
                   count(wc.key) as number_of_bpm_updates
              from wc_iata wc
             where key > c_id
               and eventts < c_until
               and message like 'BPM%'
             group by period.to_stamp(eventts, 'M5'),
                      period.periodid(eventts, 'M5'),
                      period.periodid(eventts, 'H1')
             order by id)
     where rownum <= c_maxrecs;

  cursor c_m5_measure
   (c_m5_periodid            fact_bpm_traffic_agg_m5.m5_periodid%type
   )
   is
    select count(1) as number_of_bpm_updates
      from wc_iata wc
     where period.periodid(eventts, 'M5') = c_m5_periodid;

      measure_rec c_m5_measure%rowtype;
begin
  bpi_trace.enter_module( i_module => l_con_proc_name );

  begin
    begin
        select * into l_mcg
        from metric_config
        where upper(metric_procedure) = upper(l_con_proc_name);
      exception
      when others then
           l_mcg.status := 0;
      end;
      if l_mcg.status <> 1
    then
      viu_info.operator_info( viu_constant.c_ifo_bpidebuginfo, l_con_proc_name, viu_info.c_severity_warning, null
                            , l_con_proc_name||' NOT CONFIGURED TO RUN. Check METRIC_CONFIG.. (STATUS <> 1).' );
    else
    
      if l_mcg.period_type <> 'M5'
      then
        bpi_log.raise_fatal_error(l_con_proc_name, l_con_proc_name||', PERIOD_TYPE must be configured as M5');
      end if;
      
      l_current_time   := sys_extract_utc(systimestamp);
      
      if nvl(l_mcg.lag, 0) > 0
      then
         l_lag_time := l_current_time - numtodsinterval(l_mcg.lag, 'DAY');
      end if;
      
      if nvl(l_mcg.exclude_current_period,0) = 1
      then
         l_exclude_time := period.startts(l_current_time, l_mcg.period_type);
      end if;
      
      l_until_dt := least(l_current_time
                         ,nvl(l_lag_time    ,l_current_time + 1)
                         ,nvl(l_exclude_time,l_current_time + 1)
                         );

      l_max_rows := nvl(l_mcg.max_measurements, 10000);
      
      select nvl(max(id), 0) into l_max_id from fact_bpm_traffic_agg_m5;
      select max(eventts) into l_from_dt from fact_bpm_traffic_agg_m5 where id = l_max_id;
      
      if l_from_dt is null
      then
        select min(eventts)
        into   l_from_dt
        from   wc_iata;
      end if;
      
      if l_from_dt is not null
      then
        l_from_dt := period.startts(l_from_dt, l_mcg.period_type);
      end if;
      
      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' STARTED. Processing Metrics with ID greater than '||to_char(l_max_id)
                            );

      delete from err$_fact_bpm_traffic_agg_m5;
      while l_max_rows > 0 and l_from_dt < l_until_dt
      loop
         merge into fact_bpm_traffic_agg_m5 ec5
         using ( select *
                 from ( select max(key) as id
                        ,      period.to_stamp(eventts, 'M5') as eventts
                        ,      period.periodid(eventts, 'M5') as m5_periodid
                        ,      period.periodid(eventts, 'H1') as h1_periodid
                        ,      count(wc.key) as number_of_bpm_updates
                        from wc_iata wc
                        where key > l_max_id
                        and   eventts        >= l_from_dt
                        and   eventts        <  l_from_dt + numtodsinterval(1, 'HOUR')
                        and   message        like 'BPM%'
                        group by period.to_stamp(eventts, 'M5')
                        ,        period.periodid(eventts, 'M5')
                        ,        period.periodid(eventts, 'H1')
                        order by id
                      )
                  where rownum <= l_max_rows
               ) mtc
            on (
                    ec5.m5_periodid   = mtc.m5_periodid
               )
            when matched then
                 update
                 set id                           = mtc.id
                 ,   updatets                     = sys_extract_utc(systimestamp)
                 ,   number_of_bpm_updates        = mtc.number_of_bpm_updates
                 where ec5.id < mtc.id
            when not matched then
                 insert
                 ( id
                 , insertts
                 , updatets
                 , eventts
                 , m5_periodid
                 , h1_periodid
                 , number_of_bpm_updates)
                 values
                 ( mtc.id
                 , sys_extract_utc(systimestamp)
                 , sys_extract_utc(systimestamp)
                 , mtc.eventts
                 , mtc.m5_periodid
                 , mtc.h1_periodid
                 , mtc.number_of_bpm_updates )
             log errors into err$_fact_bpm_traffic_agg_m5 reject limit unlimited;
       
          l_count    := l_count + sql%rowcount;
          l_max_rows := l_max_rows - sql%rowcount;
          l_from_dt  := l_from_dt + numtodsinterval(1, 'HOUR');
          
        commit;
        
      end loop;
      
       
      select *
      bulk collect into l_err
      from   err$_fact_bpm_traffic_agg_m5
      order by ora_err_number$
      ;
      
      if l_err.count > 0
      then
         for i in l_err.first..l_err.last
         loop
            bpi_log.handle_error( i_con_proc => l_con_proc_name
                                , i_msg      => l_con_proc_name              ||' ERROR. Insert/update FACT_BPM_TRAFFIC_AGG_M5 failed. '
                                                ||'ID='                      ||to_char(l_err(i).id)
                                                ||',M5_PERIODID='            ||to_char(l_err(i).m5_periodid)
                                                ||', '                       ||l_err(i).ora_err_mesg$
                                );
         end loop;
      end if;
      
      if l_count >= l_mcg.max_measurements
      then
         metrics.unfinished( i_proc => l_con_proc_name);
      end if;

      viu_info.operator_info( i_ifo_nr                 => viu_constant.c_ifo_bpidebuginfo
                            , i_calling_procedure      => l_con_proc_name
                            , i_severity               => viu_info.c_severity_notification
                            , i_info_arguments         => null
                            , i_additional_data        => l_con_proc_name||' finished successfully. Processed '||to_char(l_count)||' Metrics.'
                            );
    end if;
  exception when others then
    l_msg := substr(l_con_proc_name||' ERROR. Insert/update FACT_BPM_TRAFFIC_AGG_M5 failed. '||', '||sqlerrm||chr(10)||dbms_utility.format_error_backtrace,1,4000);
    viu_info.operator_info(viu_constant.c_ifo_bpidebuginfo,l_con_proc_name, viu_info.c_severity_error, null, l_msg);
  end;
  
  bpi_trace.leave_module( i_module => l_con_proc_name );
end;
 
end metrics_m5;
/